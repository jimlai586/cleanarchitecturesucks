<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>You don’t need MVVM</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">You don’t need MVVM</h1>
</header>
<section data-field="subtitle" class="p-summary">
or why MVVM can easily be a boilerplate mess
</section>
<section data-field="body" class="e-content">
<section name="42c8" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="dd08" id="dd08" class="graf graf--h3 graf--leading graf--title">You don’t need MVVM</h3><p name="6c62" id="6c62" class="graf graf--p graf-after--h3">or why MVVM can easily be a boilerplate mess</p><blockquote name="4bbf" id="4bbf" class="graf graf--blockquote graf-after--p">So what do you think about MVVM?</blockquote><blockquote name="25cf" id="25cf" class="graf graf--blockquote graf-after--blockquote">— an iOS interview question</blockquote><blockquote name="9a86" id="9a86" class="graf graf--pullquote graf-after--blockquote">I think it’s shit sir. Wait, are you telling me you are still using MVVM in 2019?</blockquote><p name="1792" id="1792" class="graf graf--p graf-after--pullquote">In case you are wondering, I did NOT get the job. Thank god.</p><figure name="d66f" id="d66f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*VmX-spl4_1S0uWicXD8UYg.jpeg" data-width="620" data-height="330" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*VmX-spl4_1S0uWicXD8UYg.jpeg"><figcaption class="imageCaption">This is a click-bait</figcaption></figure><h4 name="931f" id="931f" class="graf graf--h4 graf-after--figure">TL:DR</h4><p name="a6ae" id="a6ae" class="graf graf--p graf-after--h4">View update when model changes is automatic in SwiftUI. Without its binding, what is left with MVVM?</p><p name="6021" id="6021" class="graf graf--p graf-after--p">When you refactor out stored properties, you introduce new reference types (MVVM likes to put states inside, so not value type) to store it. You also need to send message to or call back from it. These overheads do not scale well, and can easily cancel out any benefits.</p><p name="fca6" id="fca6" class="graf graf--p graf-after--p">When you refactor out most stored properties, view controller is left with complex interactions across various classes. It might not even actually control view depending on how much is moved to these classes.</p><p name="5dfe" id="5dfe" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">MVVM is one way of refactor, not the only way.</strong></p><p name="fcf6" id="fcf6" class="graf graf--p graf-after--p">Protocol extension, when used to describe control flow, is a refactor of control. When you refactor out business logic, view controller is left with simple view update logic, which is exactly what it should do! You also don’t need new classes to conform to these control protocols, let view controller conform to it!</p><figure name="f4eb" id="f4eb" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*J7hzRYR3lruwZPCxbeyq0g.jpeg" data-width="500" data-height="500" src="https://cdn-images-1.medium.com/max/800/1*J7hzRYR3lruwZPCxbeyq0g.jpeg"></figure><h4 name="120b" id="120b" class="graf graf--h4 graf-after--figure">View-Model is harmless</h4><p name="6cab" id="6cab" class="graf graf--p graf-after--h4">UI is all about updating view whenever data changes, either by function call or binding.</p><h4 name="2190" id="2190" class="graf graf--h4 graf-after--p"><strong class="markup--strong markup--h4-strong">But MVVM is ambiguous</strong></h4><p name="2cf1" id="2cf1" class="graf graf--p graf-after--h4">It hints at you that you can use view-model in some way that is more than a refactor. Throw in some additional functionalities and a view-model becomes a presenter!</p><p name="85c2" id="85c2" class="graf graf--p graf-after--p">Does MVVM have clear guidelines on what kind of functionalities a presenter should have?</p><p name="e13d" id="e13d" class="graf graf--p graf-after--p">No, it all depends.</p><p name="e031" id="e031" class="graf graf--p graf-after--p">Worst yet, it adds complexity of binding. But binding is not unique to MVVM, you can use it in plain-old MVC to simplify(?) view update if needed.</p><p name="0238" id="0238" class="graf graf--p graf-after--p">So if you remove view-model refactoring, binding, what is left with MVVM?</p><p name="97ca" id="97ca" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">You are then forced to invent things for your presenter to do.</strong></p><h4 name="f6eb" id="f6eb" class="graf graf--h4 graf-after--p">Typical MVVM flow</h4><ol class="postList"><li name="21e1" id="21e1" class="graf graf--li graf-after--h4">Create some model</li><li name="d5f0" id="d5f0" class="graf graf--li graf-after--li">Create binding between model and view</li><li name="a05f" id="a05f" class="graf graf--li graf-after--li">Since you created a model, might as well do some shit in it</li><li name="a2a5" id="a2a5" class="graf graf--li graf-after--li">Since you do some shit in it, let’s move shits from view controller to view-models</li><li name="902e" id="902e" class="graf graf--li graf-after--li">Claim these view-models are easier to test, and help avoiding massive view controller problem.</li><li name="46e9" id="46e9" class="graf graf--li graf-after--li">Profit???</li></ol><h4 name="f991" id="f991" class="graf graf--h4 graf-after--li">Where shit hit the fan</h4><p name="cfbb" id="cfbb" class="graf graf--p graf-after--h4">Step 1, 2 are just view-model.</p><p name="61ce" id="61ce" class="graf graf--p graf-after--p">Step 3 may be dangerous depending on what kind of shit you put in.</p><p name="8cc9" id="8cc9" class="graf graf--p graf-after--p">Step 4 is where shit hit the fan.</p><p name="7980" id="7980" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Because you are mixing control with view-model.</strong></p><p name="9a02" id="9a02" class="graf graf--p graf-after--p">Think of MVC as 3 mother boxes in Justice League. When you put them together in iOS, you have a view controller.</p><figure name="1d82" id="1d82" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*8VQNz-s9CD8glqmj-_ooKg.jpeg" data-width="1280" data-height="720" src="https://cdn-images-1.medium.com/max/800/1*8VQNz-s9CD8glqmj-_ooKg.jpeg"><figcaption class="imageCaption">Visual representation of adding control codes to view-model</figcaption></figure><h4 name="df5a" id="df5a" class="graf graf--h4 graf-after--figure">Catch 22</h4><p name="f18f" id="f18f" class="graf graf--p graf-after--h4">You may argue that presenter is not view controller, and you should keep coupling as low as possible or presenter as simple as possible in MVVM.</p><p name="9959" id="9959" class="graf graf--p graf-after--p">Here is the catch, if you make it simpler, it’s a view-model refactor with fancy name. If you make it more complicated, you risk it being view controller. If you somehow make it not simple and not complicated, the benefits it brings still may be countered by the overheads it induces.</p><h4 name="d02a" id="d02a" class="graf graf--h4 graf-after--p">Example</h4><p name="b2ed" id="b2ed" class="graf graf--p graf-after--h4">Let’s take a google top result of “iOS mvvm example” for example.</p><p name="2731" id="2731" class="graf graf--p graf-after--p"><a href="https://medium.com/@azamsharp/mvvm-in-ios-from-net-perspective-580eb7f4f129" data-href="https://medium.com/@azamsharp/mvvm-in-ios-from-net-perspective-580eb7f4f129" class="markup--anchor markup--p-anchor" target="_blank">mvvm in iOS</a></p><p name="a6eb" id="a6eb" class="graf graf--p graf-after--p">There are 3 points of note in that article.</p><ol class="postList"><li name="3bdd" id="3bdd" class="graf graf--li graf-after--p">he claims view-model should be as dumb as possible, not even networking codes should be in it.</li></ol><figure name="fda5" id="fda5" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*sdZ7bGBBBqeOa1rV9KD1Cw.png" data-width="884" data-height="590" src="https://cdn-images-1.medium.com/max/800/1*sdZ7bGBBBqeOa1rV9KD1Cw.png"></figure><p name="f2ab" id="f2ab" class="graf graf--p graf-after--figure">2. of course he got down-voted to hell making such claim.</p><p name="dc20" id="dc20" class="graf graf--p graf-after--p">As I said, even if you want to keep it simple, there are always dumb developers who would add shit to it.</p><p name="e105" id="e105" class="graf graf--p graf-after--p">Any developer worth their salt would just refactor networking out to dedicated networking library.</p><p name="b249" id="b249" class="graf graf--p graf-after--p">MVVM mindset is wrapped around having a self-contained presenter, so they would inevitably move associated control logic to it.</p><p name="e51b" id="e51b" class="graf graf--p graf-after--p">Easy-to-test? Nothing associated with view is easy to test. And there’s nothing stopping you TDD or BDD your view controller.</p><p name="6719" id="6719" class="graf graf--p graf-after--p">3. spent 1/3 article re-inventing binding</p><p name="d2ff" id="d2ff" class="graf graf--p graf-after--p">You don’t need that shit. For reactive or “binding” flavor, property-observer is sufficient for most use cases. Even the low-tech function call such as</p><pre name="4afe" id="4afe" class="graf graf--pre graf-after--p">updateView()</pre><p name="d292" id="d292" class="graf graf--p graf-after--pre">can get the job done.</p><p name="7c8c" id="7c8c" class="graf graf--p graf-after--p">So aside from over-engineering view updating, what do eager-to-learn junior iOS developers actually learn from this?</p><p name="55fe" id="55fe" class="graf graf--p graf-after--p">What are the unique insights into arch-ing an app?</p><h4 name="3d1b" id="3d1b" class="graf graf--h4 graf-after--p">Boilerplate: the MVVM implementation</h4><p name="0842" id="0842" class="graf graf--p graf-after--h4">Let’s take another look at another attempt to solve massive view controller problem with MVVM.</p><p name="1c8e" id="1c8e" class="graf graf--p graf-after--p"><a href="https://www.toptal.com/ios/swift-tutorial-introduction-to-mvvm" data-href="https://www.toptal.com/ios/swift-tutorial-introduction-to-mvvm" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">boilerplate: the code</a></p><p name="e28d" id="e28d" class="graf graf--p graf-after--p">Let me give you a low-tech, brute-force, MVC version of it:</p><pre name="3741" id="3741" class="graf graf--pre graf-after--p">class SomeVC: UIViewController {</pre><pre name="947d" id="947d" class="graf graf--pre graf-after--pre">    // declare models<br>    var awayTeam = &quot;&quot;</pre><pre name="e49c" id="e49c" class="graf graf--pre graf-after--pre">    func updateView() {<br>        <code class="markup--code markup--pre-code">awayTeamNameLabel.text = awayTeam<br>        // update rest of the UI</code> <br>    }<br>}</pre><p name="3cc9" id="3cc9" class="graf graf--p graf-after--pre">Sure you would have business logic associated with how to change model and when to update.</p><p name="a94e" id="a94e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">But why is it that you have to refactor control logic out to view model?</strong></p><p name="b38c" id="b38c" class="graf graf--p graf-after--p">It’s one way. But not the only way. You have <strong class="markup--strong markup--p-strong">protocol extension</strong> in Swift.</p><p name="287e" id="287e" class="graf graf--p graf-after--p">You can also add extension to view controller without protocol.</p><p name="5689" id="5689" class="graf graf--p graf-after--p">You can also um…what’s the technical term … <em class="markup--em markup--p-em">write nicely</em>? e.g.; put relevant code together, add code markers, comments … etc.</p><p name="f328" id="f328" class="graf graf--p graf-after--p">Also if you are cursed with knowledge like me, you would notice he uses class instead of struct for model, and you should avoid inheriting NSObject with Swift class.</p><p name="e859" id="e859" class="graf graf--p graf-after--p">Let’s just say Swift has value type for a reason. If your architecture does not make use of that, it does take full advantage of language features.</p><h4 name="d509" id="d509" class="graf graf--h4 graf-after--p">What’s worse</h4><p name="08da" id="08da" class="graf graf--p graf-after--h4">The above examples come from google top results, and possibly experienced developers. Can you imagine MVVM falls in the wrong hands?</p><p name="7132" id="7132" class="graf graf--p graf-after--p">I’ve only recently seen people write this</p><pre name="4165" id="4165" class="graf graf--pre graf-after--p">vc.vm1.vm2.vc = self.vm.getVC()</pre><p name="c50c" id="c50c" class="graf graf--p graf-after--pre">with every vm coming with its protocol/class/instance/generic/its own vm.</p><h4 name="271e" id="271e" class="graf graf--h4 graf-after--p">As the old saying goes</h4><blockquote name="76a6" id="76a6" class="graf graf--blockquote graf-after--h4">If you write shit in MVC, you write shit everywhere else</blockquote><p name="2930" id="2930" class="graf graf--p graf-after--blockquote">Learn how to do shit properly in MVC, learn refactor, before jumping to memes like MVVM.</p><p name="291c" id="291c" class="graf graf--p graf-after--p">While shit, this example also reveals another problem.</p><h4 name="3b41" id="3b41" class="graf graf--h4 graf-after--p">Catch 22–2</h4><p name="5cfe" id="5cfe" class="graf graf--p graf-after--h4">You either access view-model directly, bypassing whatever view controller retaining it, or you write boilerplate getter/setter in view controller to access view-model properties.</p><p name="4e27" id="4e27" class="graf graf--p graf-after--p">In other words, you either ignore view controller, or make it have more boilerplate.</p><p name="80e5" id="80e5" class="graf graf--p graf-after--p">Any attempt to partition view controller properties would have the same problem. There would be people telling you that this is the first step for compact view controller.</p><p name="a92c" id="a92c" class="graf graf--p graf-after--p">Nah, this is shit. That means you should not attempt to partition stored properties.</p><p name="7647" id="7647" class="graf graf--p graf-after--p">The guiding principle of Swift is that if it does not feel swift-y, chances are you are doing it wrong.</p><h4 name="3e5f" id="3e5f" class="graf graf--h4 graf-after--p">Root of the problem</h4><p name="6351" id="6351" class="graf graf--p graf-after--h4"><strong class="markup--strong markup--p-strong">MVVM does not handle control.</strong></p><p name="ef6c" id="ef6c" class="graf graf--p graf-after--p">Presenters are nice, but they are a form of refactor, with an emphasis on view and model binding.</p><p name="f799" id="f799" class="graf graf--p graf-after--p">But they also create barriers inside view controller that make interaction difficult, e.g.; you have to get through a presenter to access a property. Imagine what you have to go through to get and set properties across multiple presenters.</p><p name="12c0" id="12c0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Not only did it not handle control, it makes control more difficult.</strong></p><p name="7301" id="7301" class="graf graf--p graf-after--p">Control is what you should worry about. Not how you update a view.</p><figure name="40cd" id="40cd" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*cGVql382gep8o4lVNa5dHA.jpeg" data-width="225" data-height="225" src="https://cdn-images-1.medium.com/max/800/1*cGVql382gep8o4lVNa5dHA.jpeg"><figcaption class="imageCaption">Yoda code-reviewing a MVVM developer</figcaption></figure><p name="86cd" id="86cd" class="graf graf--p graf-after--figure">So either you make it simple, and handle control in usual MVC sense, or you invent crazy shit for MVVM to make sense. Following is an example.</p><h4 name="b593" id="b593" class="graf graf--h4 graf-after--p">View Model without View or Model</h4><p name="9c63" id="9c63" class="graf graf--p graf-after--h4">This is on par with “custom view without view, but view controller controlled by NSObject”. Insane level shit. You have to see it to believe it.</p><p name="9152" id="9152" class="graf graf--p graf-after--p">There’s this guy thinking, hey, why bother creating model in a model class.</p><p name="3c6d" id="3c6d" class="graf graf--p graf-after--p">Let view-model store <strong class="markup--strong markup--p-strong">only</strong> <strong class="markup--strong markup--p-strong">escaping closures</strong> that captures view controller.</p><p name="ca01" id="ca01" class="graf graf--p graf-after--p">Since you have view controller reference, you can do whatever shit you do in view controller while in view-model. Next you hook up UI event to view-model and call these closures as action. Voila, you now have slim view controller because these presenters share the work-load.</p><p name="fa00" id="fa00" class="graf graf--p graf-after--p">Behold. You now have view-models that contain nothing but control.</p><p name="4417" id="4417" class="graf graf--p graf-after--p">Some call this MVVM. I call it shit refactor.</p><figure name="48d9" id="48d9" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*IjDJPNaKrZalRoMl9B6hWg.png" data-width="1020" data-height="576" src="https://cdn-images-1.medium.com/max/800/1*IjDJPNaKrZalRoMl9B6hWg.png"><figcaption class="imageCaption">It takes creativity to write shit refactor</figcaption></figure><p name="f9fc" id="f9fc" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Stored properties are state. Escaping closures are side effect.</strong></p><p name="fc37" id="fc37" class="graf graf--p graf-after--p">If you have stored properties whose sole purpose is to store escaping closures, you are in for a wild ride.</p><p name="6568" id="6568" class="graf graf--p graf-after--p">Massive view controller is a somewhat misleading term.</p><p name="84d4" id="84d4" class="graf graf--p graf-after--p">It’s not how many lines of codes in your view controller. You can have many view-model like this:</p><pre name="732a" id="732a" class="graf graf--pre graf-after--p">var title: String {</pre><pre name="a3d7" id="a3d7" class="graf graf--pre graf-after--pre">    didSet {titleLabel.text = title}<br>}</pre><p name="7ac1" id="7ac1" class="graf graf--p graf-after--pre">And I wouldn’t think of it as massive. Because I know it’s side-effect free.</p><p name="79b7" id="79b7" class="graf graf--p graf-after--p">But if you have a line like this</p><pre name="9040" id="9040" class="graf graf--pre graf-after--p">vm1.onSuccess {[weak self] in self?.vm2.m2 = 0; self?.isCompleted = true}</pre><p name="dcb9" id="dcb9" class="graf graf--p graf-after--pre">I’ll be f-ing concerned. Wtf is going on???</p><p name="90f0" id="90f0" class="graf graf--p graf-after--p">If you write side-effects in MVC, there’s nothing preventing you from writing side-effects in MVVM. In fact you will write more.</p><h4 name="6bed" id="6bed" class="graf graf--h4 graf-after--p">Search your feelings</h4><p name="af0e" id="af0e" class="graf graf--p graf-after--h4">You know it to be true.</p><p name="f478" id="f478" class="graf graf--p graf-after--p">You probably also searched “VIPER” as an improvement over MVVM.</p><p name="0109" id="0109" class="graf graf--p graf-after--p">As in “View-Interactor-Presenter-Entity-Router”. See? you need to handle control.</p><p name="bcc6" id="bcc6" class="graf graf--p graf-after--p">But unfortunately, VIPER is also shit. Because it’s a boilerplate mess.</p><p name="364b" id="364b" class="graf graf--p graf-after--p">Why it is so shit needs a separate article.</p><p name="a40c" id="a40c" class="graf graf--p graf-after--p">But VIPER is our last hope?</p><figure name="6b7b" id="6b7b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*q_VAQmbWUuRji0_XkAfWhA.jpeg" data-width="217" data-height="232" src="https://cdn-images-1.medium.com/max/800/1*q_VAQmbWUuRji0_XkAfWhA.jpeg"></figure><h4 name="70e2" id="70e2" class="graf graf--h4 graf-after--figure">Redux</h4><p name="0621" id="0621" class="graf graf--p graf-after--h4">Redux is all about state-management.</p><p name="6d40" id="6d40" class="graf graf--p graf-after--p">While I think it’s a step in right direction, I have reservations about ReSwift implementation.</p><p name="ffc2" id="ffc2" class="graf graf--p graf-after--p">I’ve written a much simpler framework that works beautifully with SwiftUI.</p><p name="5329" id="5329" class="graf graf--p graf-after--p graf--trailing">May share it in another article.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/f9e8c155b0d"><time class="dt-published" datetime="2019-09-01T14:20:58.269Z">September 1, 2019</time></a>.</p><p><a href="https://medium.com/@swift2931/you-dont-need-mvvm-f9e8c155b0d" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>