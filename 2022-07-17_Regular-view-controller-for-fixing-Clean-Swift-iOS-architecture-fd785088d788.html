<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Regular view controller for fixing Clean Swift iOS architecture</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Regular view controller for fixing Clean Swift iOS architecture</h1>
</header>
<section data-field="subtitle" class="p-summary">
Leading the Swift revolution
</section>
<section data-field="body" class="e-content">
<section name="74c1" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="8a03" id="8a03" class="graf graf--h3 graf--leading graf--title">Regular view controller for fixing Clean Swift iOS architecture</h3><p name="1091" id="1091" class="graf graf--p graf-after--h3">Leading the Swift revolution</p><figure name="f0ea" id="f0ea" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*9qFMk7QFbJky6hxDvrMzvQ.jpeg" data-width="1000" data-height="626" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*9qFMk7QFbJky6hxDvrMzvQ.jpeg"><figcaption class="imageCaption">You did it, Mary. You electrified the entire automotive industry.</figcaption></figure><h4 name="41e5" id="41e5" class="graf graf--h4 graf-after--figure">What is regular view controller?</h4><p name="2f80" id="2f80" class="graf graf--p graf-after--h4">Writing view controller with some refactor skill and an emphasis on Swift language features.</p><p name="d6f1" id="d6f1" class="graf graf--p graf-after--p">It is called “regular” to be distinguished from the “massive” view controller that every design pattern tries to fix.</p><h4 name="bbe5" id="bbe5" class="graf graf--h4 graf-after--p">Why regular view controller?</h4><p name="db4a" id="db4a" class="graf graf--p graf-after--h4">Every design pattern assumes you write dumb shit massive view controller.</p><p name="0146" id="0146" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Being better than a dumb shit massive view controller doesn’t mean a design pattern implementation is good. The value of a design pattern implementation comes from comparing against a well-refactored SDK code.</strong></p><p name="7932" id="7932" class="graf graf--p graf-after--p">Say I have a regular view controller. Do I compare it against some dumb shit MVVM? Or do I compare it with the pinnacle of clean architecture (advertised) in iOS?</p><p name="527c" id="527c" class="graf graf--p graf-after--p">Let’s tackle this.</p><h4 name="5aec" id="5aec" class="graf graf--h4 graf-after--p">The line up</h4><p name="6ca1" id="6ca1" class="graf graf--p graf-after--h4">What are the features of Swift?</p><p name="9180" id="9180" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">POP, property observer, value type.</strong></p><p name="0ebe" id="0ebe" class="graf graf--p graf-after--p">What is the main problem I’m trying to solve?</p><pre name="d619" id="d619" class="graf graf--pre graf-after--p">// model update<br>title = &quot;clean&quot;</pre><pre name="47b2" id="47b2" class="graf graf--pre graf-after--pre">// view update<br>view.title = &quot;clean&quot;</pre><p name="98f9" id="98f9" class="graf graf--p graf-after--pre">I want the model to be a single source of truth so I don’t have to update two places every time. So view need to be reactive to model changes.</p><p name="b940" id="b940" class="graf graf--p graf-after--p">This calls for <strong class="markup--strong markup--p-strong">property observer</strong>.</p><pre name="80de" id="80de" class="graf graf--pre graf-after--p">var title = &quot;&quot; { didSet {view.title = self.title} }</pre><p name="33d2" id="33d2" class="graf graf--p graf-after--pre">This can be generalized so that view is a function of model. E.g.;</p><pre name="4f92" id="4f92" class="graf graf--pre graf-after--p">var model = Model() { didSet {updateUI()} }</pre><p name="3edb" id="3edb" class="graf graf--p graf-after--pre">Now should this model be reference type or value type?</p><p name="9193" id="9193" class="graf graf--p graf-after--p">I don’t need nor want hidden side effects inside model, so <strong class="markup--strong markup--p-strong">value type</strong>.</p><p name="2fa2" id="2fa2" class="graf graf--p graf-after--p">Because of this design, the model is best maintained inside view controller. And it should! Since this model is used for view update, and value type forces state changes (i.e.; view controls)to occur outside of model. This is exactly what a view controller should do.</p><p name="5382" id="5382" class="graf graf--p graf-after--p">Now I make it so that one can only change model via functions in protocol, which is where <strong class="markup--strong markup--p-strong">POP </strong>comes in. Namely, composition over inheritances and composition by default implementation.</p><p name="657e" id="657e" class="graf graf--p graf-after--p">If the bulk of implementation is in the form of protocol extension, then it can be easily refactored out to another file if necessary given that each protocol and its extensions are <strong class="markup--strong markup--p-strong">self-contained</strong>. That is, everything you need to implement a protocol is declared inside the protocol. This is in contrast to concrete object implementation followed by extracting out functions as protocol approach. <strong class="markup--strong markup--p-strong">Protocol comes first</strong>. Then protocol extensions. And they are self-contained to be portable and easy-to-plug-in. These are building blocks or <strong class="markup--strong markup--p-strong">mix-ins</strong>. This is outside the scope of usual OOP. We are entering POP territory. Note that I haven’t mentioned any reference type object outside of view controller, and I have used all 3 language features listed.</p><h4 name="a94c" id="a94c" class="graf graf--h4 graf-after--p">Comparison</h4><p name="d0b9" id="d0b9" class="graf graf--p graf-after--h4">Now we are ready to stack up against the cleanest of all clean architectures: <a href="https://clean-swift.com/clean-swift-ios-architecture/" data-href="https://clean-swift.com/clean-swift-ios-architecture/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Clean Swift</a>.</p><p name="fa64" id="fa64" class="graf graf--p graf-after--p">Let’s focus on the infamous VIP uni-directional path.</p><figure name="74fe" id="74fe" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*aeuwAxGTL6QUYyDzU-ie4Q.png" data-width="729" data-height="533" src="https://cdn-images-1.medium.com/max/800/1*aeuwAxGTL6QUYyDzU-ie4Q.png"><figcaption class="imageCaption">Interactor</figcaption></figure><figure name="2a90" id="2a90" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*E8S5uNpUtPCMqFMh_MNAUQ.png" data-width="718" data-height="455" src="https://cdn-images-1.medium.com/max/800/1*E8S5uNpUtPCMqFMh_MNAUQ.png"><figcaption class="imageCaption">Presenter</figcaption></figure><p name="e15b" id="e15b" class="graf graf--p graf-after--figure">versus</p><pre name="7b61" id="7b61" class="graf graf--pre graf-after--p">protocol OrderProcessing {<br>    var order: Resource{get}<br>    var json: JSON {get set}<br>}<br>extension OrderProcessing {<br>    func doSomething() {<br>        order.get().onSuccess {json in self.json = json}<br>    }<br>}</pre><pre name="bbb2" id="bbb2" class="graf graf--pre graf-after--pre">// view controller conforming OrderProcessing<br>var json = JSON() { didSet {updateUI()} }<br>var order: Resource{<br>    // return a resource where you can get/post ...etc<br>}</pre><p name="3898" id="3898" class="graf graf--p graf-after--pre">My flow would be View controller -&gt; Interactor (as protocol extension) -&gt; Presenter (property observer + computed properties if needed).</p><p name="bc7d" id="bc7d" class="graf graf--p graf-after--p">Wait, did I just refactor the cleanest of all clean architectures?</p><p name="93b7" id="93b7" class="graf graf--p graf-after--p">Why is it that I can have the same flow without the boilerplate mess? From a meager and regular MVC no less.</p><p name="92ca" id="92ca" class="graf graf--p graf-after--p">Simple. There’s no mention of value type and property observer in Clean Swift, and protocol is an after-thought. Design pattern is a result of language features and refactor. Not the other way around.</p><p name="f303" id="f303" class="graf graf--p graf-after--p">You may argue, clearly this is not scalable. The real mystery is… why do you think Clean Swift is scalable in the first place? Because it said so?</p><p name="f80e" id="f80e" class="graf graf--p graf-after--p">Clean Swift didn’t prove shit. By simple inspection I’d argue it will be a boilerplate mess in every situation. Let’s look at a few examples.</p><h4 name="1af2" id="1af2" class="graf graf--h4 graf-after--p">Fixing the problems</h4><figure name="00ee" id="00ee" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*ared5-TKGDieRpfUx3jclA.jpeg" data-width="500" data-height="567" src="https://cdn-images-1.medium.com/max/800/1*ared5-TKGDieRpfUx3jclA.jpeg"></figure><ol class="postList"><li name="6291" id="6291" class="graf graf--li graf-after--figure">Strict type system doesn’t always help you</li></ol><figure name="1e63" id="1e63" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*1kyuOiqc3RLqp5z2RBtC8w.png" data-width="414" data-height="144" src="https://cdn-images-1.medium.com/max/800/1*1kyuOiqc3RLqp5z2RBtC8w.png"></figure><p name="6d20" id="6d20" class="graf graf--p graf-after--figure">That’s what? 5 types already in 8 lines.</p><p name="b2ed" id="b2ed" class="graf graf--p graf-after--p">Are they reusable? Say I’m working on a different page. I’ll at least re-create 4 of them since they are dependent on <code class="markup--code markup--p-code">CreateOrder</code>. You are just asking to be crushed by the strict type system at this point, let alone scalable.</p><p name="1822" id="1822" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">And wtf is that force cast???????</em></p><p name="a79d" id="a79d" class="graf graf--p graf-after--p">You are telling me this “clean architecture” and its community never for 1 second in the past 5 or so years think this is a major code smell???</p><p name="f65b" id="f65b" class="graf graf--p graf-after--p">First you should never force cast except IBOutlets.</p><p name="6643" id="6643" class="graf graf--p graf-after--p">Second you are implying they can’t be determined in initialization time. Why?Are you going to parameterize this view controller to swap out interactor or worker? Another common pitfall. It’s far simpler to have independent view controllers than one modular / swappable controller with implicit / hidden associations. It’s often very hard to have a clear cut module and if you find one, it can be turned into protocol extension. In general things are easier when you can determine everything in initialization. Force casts are rare exceptions, not standard operation, and certainly not clean. It also raises the problem of over-generalization. Most of the time, you use 1 view controller in 1 page. You are never going to swap out worker or interactor.</p><p name="e227" id="e227" class="graf graf--p graf-after--p">On the other hand, how many objects do you create to pass something from your left hand to right hand?</p><p name="1710" id="1710" class="graf graf--p graf-after--p">Request, response, output, view model? Don’t you think it’s kind of overkill and have room for simplification? It takes at least 4 objects to pass data inside a view controller, and Clean Swift has the audacity to criticize massive view controller?</p><p name="563e" id="563e" class="graf graf--p graf-after--p">The fix is obvious. Interactor doesn’t help interact shit. It’s a placeholder for functions. Drop the useless <code class="markup--code markup--p-code">CreateOrderInteractorOutput</code> , replace it with <code class="markup--code markup--p-code">OrderProcessing</code> that emphasizes on behavior, i.e.; what it is supposed to do. If every view controller has to have an interactor, then it doesn’t need to have an interactor. Focus on what that is unique and special, refactor out common stuff. Devs (<em class="markup--em markup--p-em">some</em>)are smart and can infer shit, use that to your advantage.</p><p name="4eda" id="4eda" class="graf graf--p graf-after--p">The funny thing is that, I’ve seen many people blindly copy-pasting the Clean shit that they even copied the force-cast part. Next time you see an article saying Clean Swift is the <em class="markup--em markup--p-em">BESTEST EVAR!!! </em>Check if they use force-cast.</p><p name="dc39" id="dc39" class="graf graf--p graf-after--p">2. Classifying problems is not solving problems</p><p name="4c84" id="4c84" class="graf graf--p graf-after--p">What is business logic? If I have a <code class="markup--code markup--p-code">get</code> request to retrieve a JSON to update view, does that count as business logic or view logic? Do I put it in interactor or view controller?</p><p name="a7d9" id="a7d9" class="graf graf--p graf-after--p">What goes into interactors? business logic, which are logic besides view logic.</p><p name="e955" id="e955" class="graf graf--p graf-after--p">OK. Got it. Wait… what?</p><p name="4863" id="4863" class="graf graf--p graf-after--p">Say I have 10 business logic functions in my massive view controller. If I now go into VIP architecture, how many business logic functions will I have in interactor? Still 10. Plus huge overheads that I didn’t need before.</p><p name="b0dd" id="b0dd" class="graf graf--p graf-after--p">This “re-grouping and re-tagging” doesn’t even need objects in the first place. You can do the same thing with protocol extensions.</p><p name="edd1" id="edd1" class="graf graf--p graf-after--p">In the end, Clean Swift doesn’t solve shit. It defines some shit, very ambiguously. Then it relies on you to figure out the ambiguous part, the overhead part, and the regrouping part which together are just a very shity refactor which should be very obvious if you didn’t ignore all the signs of boilerplate!</p><p name="df9d" id="df9d" class="graf graf--p graf-after--p">3. Presenter should be trivial to the point you don’t even need it</p><p name="d3b2" id="d3b2" class="graf graf--p graf-after--p">Consider a typical view update.</p><p name="e77f" id="e77f" class="graf graf--p graf-after--p">a. collect data</p><p name="50cc" id="50cc" class="graf graf--p graf-after--p">b. update</p><p name="51de" id="51de" class="graf graf--p graf-after--p">Now update is just <code class="markup--code markup--p-code">model = newModel</code> , if you attach a property observer.</p><p name="0788" id="0788" class="graf graf--p graf-after--p">What does collect data do? You <em class="markup--em markup--p-em">compute </em>some view properties. Actions with side effects are done prior to view updates. You are not supposed to produce side effects at this stage.</p><p name="e151" id="e151" class="graf graf--p graf-after--p">That means everything you need should come from a <em class="markup--em markup--p-em">computed property</em>.</p><p name="b381" id="b381" class="graf graf--p graf-after--p">If everything is computed property, you don’t need storage, i.e.; you don’t need reference type objects. And computed properties can fit nicely as <em class="markup--em markup--p-em">protocol extensions</em>.</p><p name="172d" id="172d" class="graf graf--p graf-after--p">Here enters yet another unique Swift feature not previously mentioned. <strong class="markup--strong markup--p-strong">Computed property</strong>.</p><p name="bd22" id="bd22" class="graf graf--p graf-after--p">So presenter can be removed entirely. This <strong class="markup--strong markup--p-strong">simplifies </strong>design. Computed properties are your presenter and they should be pure functions. Group them under protocol if necessary.</p><p name="8591" id="8591" class="graf graf--p graf-after--p">For example:</p><figure name="3e92" id="3e92" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ytZKYtDgLRYbUt-pA8P6Eg.png" data-width="712" data-height="408" src="https://cdn-images-1.medium.com/max/800/1*ytZKYtDgLRYbUt-pA8P6Eg.png"></figure><p name="4033" id="4033" class="graf graf--p graf-after--figure">Do you really need all that crap for a date update?</p><pre name="a071" id="a071" class="graf graf--pre graf-after--p">var orderDate: String {</pre><pre name="6449" id="6449" class="graf graf--pre graf-after--pre">    // let dateFormatter = ... <br>    // let date = json[&quot;date&quot;]...<br>    // return dateFormatter.stringFromDate(date)<br>}</pre><pre name="5284" id="5284" class="graf graf--pre graf-after--pre">// in updateUI() called by property observer<br>view.date = orderDate</pre><h4 name="03d3" id="03d3" class="graf graf--h4 graf-after--pre">Recap</h4><p name="3fa1" id="3fa1" class="graf graf--p graf-after--h4">Let’s summarize what we’ve learned thus far.</p><p name="b244" id="b244" class="graf graf--p graf-after--p">I have this regular view controller with a refactor emphasis on Swift feaures, namely <strong class="markup--strong markup--p-strong">POP, property observer, value type, computed properties</strong>.</p><p name="c7d6" id="c7d6" class="graf graf--p graf-after--p">Clean Swift has a design pattern that <strong class="markup--strong markup--p-strong">didn’t mention any of that</strong>. You might mistake it for Java if not careful.</p><p name="ffa2" id="ffa2" class="graf graf--p graf-after--p">This regular view controller has the same VIP flow with much lower overheads. The types that are used in the example: <code class="markup--code markup--p-code">OrderProcessing</code> , <code class="markup--code markup--p-code">Resource</code> , <code class="markup--code markup--p-code">JSON</code> . The first one is a self-contained protocol with extensions that can be used as mixed-ins with default implementation. The remaining ones are general types used in every networking request. Presenter is simplified using computed properties.</p><p name="ee3b" id="ee3b" class="graf graf--p graf-after--p">Clean Swift has a VIP flow with HUGE overheads, needs to create multiple reference type objects with reference assignments that cannot be determined in initialization. Data passing is cumbersome even inside the same view controller. This is worsened by the strict type system so it has to create many one-off types just to pass data. Interactors relies on ambiguous “business logic” definition and does nothing but a placeholder. You also have to rename objects to “worker”. Things are not simplified, but regrouped. The codes you write increase in total, just in separate places, which increase the number of files you have to manage.</p><p name="078d" id="078d" class="graf graf--p graf-after--p">Finally let’s compare what Clean Swift thinks what you have learned.</p><figure name="214d" id="214d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*vwsOOlh_HAekFzFYmqALFw.png" data-width="668" data-height="230" src="https://cdn-images-1.medium.com/max/800/1*vwsOOlh_HAekFzFYmqALFw.png"></figure><ol class="postList"><li name="38f3" id="38f3" class="graf graf--li graf-after--figure">I just refactored Clean Swift with techniques. Architectures are built on language features and techniques. Clean Swift showed none.</li><li name="8655" id="8655" class="graf graf--li graf-after--li">MVC is not only a suitable architecture, it is better than Clean Swift.</li><li name="012d" id="012d" class="graf graf--li graf-after--li">Massive view controller problem is real, but that’s not what you should be competing against. Winning over something that is defined to be bad is not a win. You need to win over a half-decent refactored MVC that at least tries to use Swift features.</li></ol><h4 name="5049" id="5049" class="graf graf--h4 graf-after--li">You did it Mary</h4><blockquote name="f117" id="f117" class="graf graf--blockquote graf-after--h4"><em class="markup--em markup--blockquote-em">You changed the whole story, Mary, wherever — [applause] — wherever you are. There you are. You did, Mary. You electrified the entire automobile industry. I’m serious. You led — and it matters — in drastically improving the climate by reducing hundreds of millions of barrels of oil that will not be used when we’re all electric.</em></blockquote><p name="63ef" id="63ef" class="graf graf--p graf-after--blockquote">This quote is what Biden said to CEO of GM not a while ago. Biden congratulated GM for leading the electric revolution when it was actually Tesla leading. GM was the first, but now Tesla is the best.</p><p name="df1e" id="df1e" class="graf graf--p graf-after--p">To put it in context.</p><p name="4209" id="4209" class="graf graf--p graf-after--p">CEO of GM, Mary Barra, is Clean Swift.</p><p name="8180" id="8180" class="graf graf--p graf-after--p">Every pumper of Clean Swift, thinking it was the <em class="markup--em markup--p-em">BESTEST EVAR</em>!!! is Biden.</p><p name="59c4" id="59c4" class="graf graf--p graf-after--p">Regular MVC, if you are any good with Swift and refactor skill, is TESLA.</p><p name="c752" id="c752" class="graf graf--p graf-after--p">If you are a pumper of Clean Swift and somehow read this far, I want you to know</p><p name="87bf" id="87bf" class="graf graf--p graf-after--p graf--trailing"><strong class="markup--strong markup--p-strong">YOU LED, AND IT MATTERS.</strong></p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/fd785088d788"><time class="dt-published" datetime="2022-07-17T11:25:31.329Z">July 17, 2022</time></a>.</p><p><a href="https://medium.com/@swift2931/regular-view-controller-for-fixing-clean-swift-ios-architecture-fd785088d788" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>