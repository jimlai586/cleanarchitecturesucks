<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>The clean marketing architecture</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">The clean marketing architecture</h1>
</header>
<section data-field="subtitle" class="p-summary">
It has never been about refactor
</section>
<section data-field="body" class="e-content">
<section name="0050" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="b8c1" id="b8c1" class="graf graf--h3 graf--leading graf--title">The clean marketing architecture</h3><p name="ffba" id="ffba" class="graf graf--p graf-after--h3">It has never been about refactor</p><figure name="33cb" id="33cb" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*I0tum9rtk88XeoVyPqDg-A.png" data-width="989" data-height="676" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*I0tum9rtk88XeoVyPqDg-A.png"><figcaption class="imageCaption">How Apple does fetch in an official sample app</figcaption></figure><h4 name="291c" id="291c" class="graf graf--h4 graf-after--figure">Clean does not mean refactored, or even correct</h4><p name="9910" id="9910" class="graf graf--p graf-after--h4">It means clickbait / buzzword, and some ritual you can join as part of the community; It becomes a social identity.</p><p name="ec70" id="ec70" class="graf graf--p graf-after--p">Like <em class="markup--em markup--p-em">Introducing MVVM into your SwiftUI project</em>.</p><p name="98c2" id="98c2" class="graf graf--p graf-after--p">This is another snippet pulled from the same official same app</p><figure name="e735" id="e735" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Uh9vnC5W29LoPTs0zHoDwQ.png" data-width="565" data-height="422" src="https://cdn-images-1.medium.com/max/800/1*Uh9vnC5W29LoPTs0zHoDwQ.png"></figure><p name="e953" id="e953" class="graf graf--p graf-after--figure">Where is view model? Why do you need view model? Why do you need a tutorial telling you to build something you don’t need? There are even tutorials telling you to build <code class="markup--code markup--p-code">ViewModelProtocol</code> before you can build view model.</p><p name="905f" id="905f" class="graf graf--p graf-after--p">Note that it uses the name <code class="markup--code markup--p-code">MemeCreator</code> , not <code class="markup--code markup--p-code">MemeCreatorView</code> . It doesn’t need to be interpreted as a view. It can be interpreted as a model, even a controller in some sense. Isn’t this what I’ve been saying? <strong class="markup--strong markup--p-strong">This is the model side of a model-view binding</strong>. You cannot access view directly because <code class="markup--code markup--p-code">var body</code> is a computed property; and you cannot mutate model directly because it’s a immutable value type. Dual protection.</p><p name="88e9" id="88e9" class="graf graf--p graf-after--p">Note the usage of @State, they are properties that don’t need to be shared. So what’s the point of moving them to a @ObservableObject, which is not value type and can be shared?</p><p name="b8c2" id="b8c2" class="graf graf--p graf-after--p">Note the <em class="markup--em markup--p-em">composition</em> of protocols <code class="markup--code markup--p-code">View</code> and <code class="markup--code markup--p-code">Sendable</code> . Why do you need <code class="markup--code markup--p-code">ViewModelProtocol</code> for generics? Think of composition in terms of vector space: <strong class="markup--strong markup--p-strong">v</strong> = a<strong class="markup--strong markup--p-strong">x</strong> + b<strong class="markup--strong markup--p-strong">y. </strong>You design protocols so that they are <em class="markup--em markup--p-em">orthogonal, i.e.; independent and self-contained. </em>Then you build your app from a basis in vector space. Most of the time you work in value type, which cannot be mutated or inherited. Composition is key to refactoring your codes.</p><p name="acb1" id="acb1" class="graf graf--p graf-after--p">Do you also notice that I’ve got all that from working on a code snippet? I’ll show you what happens to those who think they are too good to study official tutorials.</p><h4 name="c2c4" id="c2c4" class="graf graf--h4 graf-after--p">Ultra ultimate clean architecture with Combine based on dependency injection plus Redux-like state management that fixes SwiftUI</h4><p name="4c37" id="4c37" class="graf graf--p graf-after--h4">I pulled this snippet from a <a href="https://github.com/nalexn/clean-architecture-swiftui/blob/7452e19b170823247b38a1dde05e193d6170b4c4/CountriesSwiftUI/Interactors/ImagesInteractor.swift" data-href="https://github.com/nalexn/clean-architecture-swiftui/blob/7452e19b170823247b38a1dde05e193d6170b4c4/CountriesSwiftUI/Interactors/ImagesInteractor.swift" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Clean Architecture for SwiftUI + Combine github</a>.</p><figure name="bd86" id="bd86" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ZFzrR_D6znlaz4Mb42vchw.png" data-width="596" data-height="621" src="https://cdn-images-1.medium.com/max/800/1*ZFzrR_D6znlaz4Mb42vchw.png"></figure><p name="44d8" id="44d8" class="graf graf--p graf-after--figure">Compare this “fetch” with the <code class="markup--code markup--p-code">PandaCollectionFetcher</code>shown above in Apple sample app.</p><p name="c685" id="c685" class="graf graf--p graf-after--p">This is a perfect opportunity to check your skills. This is what code review is all about. I highly suggest you think about it before reading on. (besides the usage of async/await, which is new)</p><p name="0b73" id="0b73" class="graf graf--p graf-after--p">Ready?</p><ol class="postList"><li name="cdff" id="cdff" class="graf graf--li graf-after--p">load function can be refactored</li></ol><p name="f386" id="f386" class="graf graf--p graf-after--li">You’d argue “but Panda doesn’t refactor it either!”. Hint: one is beginner level tutorial, one is the cleanest architecture proposed by multiple veteran contributors with a combine of decade+ experiences.</p><p name="380d" id="380d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">It isn’t about refactor then, is it?</strong></p><p name="382b" id="382b" class="graf graf--p graf-after--p">2. <code class="markup--code markup--p-code">RealImagesInteractor: ImagesInteractor</code></p><p name="cdb1" id="cdb1" class="graf graf--p graf-after--p">If you bother to refactor it, you can do it in a function call <code class="markup--code markup--p-code">getImage(url:)</code> which can be easily reused as part of a <code class="markup--code markup--p-code">webservice</code>. <em class="markup--em markup--p-em">Function over object</em>.</p><p name="040e" id="040e" class="graf graf--p graf-after--p">Not everything has to be an object. Do you need a type <code class="markup--code markup--p-code">Adder</code> that conforms to <code class="markup--code markup--p-code">Addition</code>when all you want is <code class="markup--code markup--p-code">a+b</code> ? <em class="markup--em markup--p-em">Do not over</em>-<em class="markup--em markup--p-em">generalize</em>.</p><p name="a1af" id="a1af" class="graf graf--p graf-after--p">3. <code class="markup--code markup--p-code">struct RealImagesInteractor</code></p><figure name="245f" id="245f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Pu4-KoPO4SdlrF2J2Qr9Dg.jpeg" data-width="211" data-height="239" src="https://cdn-images-1.medium.com/max/800/1*Pu4-KoPO4SdlrF2J2Qr9Dg.jpeg"><figcaption class="imageCaption">My disappointment is immeasurable</figcaption></figure><p name="58f2" id="58f2" class="graf graf--p graf-after--figure">Interactor by definition is stateful. A fetch is stateful.</p><p name="cc3b" id="cc3b" class="graf graf--p graf-after--p">When you have mutable state, you use reference type. What happens if you don’t? Value type becomes a redundant wrapper.</p><p name="3157" id="3157" class="graf graf--p graf-after--p">In this case, the code passes a <code class="markup--code markup--p-code">webRepository</code> into interactor so it can call <code class="markup--code markup--p-code">webRepository.load(imageURL:)</code> .</p><p name="1e04" id="1e04" class="graf graf--p graf-after--p">…</p><p name="47c1" id="47c1" class="graf graf--p graf-after--p">Then wtf didn’t you just directly call <code class="markup--code markup--p-code">webRepository.load(imageURL:)</code> without a f-ing useless wrapper! This wrapper has to conform to some <code class="markup--code markup--p-code">ImageInteractor</code> shit when it’s <code class="markup--code markup--p-code">webRepository</code> that does all the heavy-lifting. You can easily extend <code class="markup--code markup--p-code">webRepository</code> to take in an extra parameter.</p><p name="9cf9" id="9cf9" class="graf graf--p graf-after--p">Let me remind you how a low-tech, beginner fetch is done in official sample.</p><p name="26ca" id="26ca" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">class PandaCollectionFetcher: ObservableObject</code></p><p name="2c1d" id="2c1d" class="graf graf--p graf-after--p">A reference type!!!</p><p name="1698" id="1698" class="graf graf--p graf-after--p">Putting reference type inside a value type is code smell. You can induce any kind of side effect via reference type. But you pass it around like an immutable value type which should not induce side effects.</p><p name="dd8f" id="dd8f" class="graf graf--p graf-after--p">MVVM doesn’t need to consider this because there wasn’t value type back then, or in Java.</p><p name="8224" id="8224" class="graf graf--p graf-after--p">By this single line, you can tell</p><p name="ce67" id="ce67" class="graf graf--p graf-after--p">a. these guys don’t even know that Interactor is about state management, yet they create all these fancy names and protocols that will eventually serve no purpose</p><p name="a84d" id="a84d" class="graf graf--p graf-after--p">b. lack of understanding of basic networking</p><p name="967c" id="967c" class="graf graf--p graf-after--p">c. lack of refactor experiences and emphasis</p><p name="fd0e" id="fd0e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">It isn’t about refactor then, is it?</strong></p><h4 name="fbed" id="fbed" class="graf graf--h4 graf-after--p">The marketing architecture</h4><p name="38af" id="38af" class="graf graf--p graf-after--h4">You are not thinking the big picture.</p><p name="dd84" id="dd84" class="graf graf--p graf-after--p">The big picture is NOT to write highly refactored code in production.</p><p name="f09d" id="f09d" class="graf graf--p graf-after--p">The big picture is to sell tutorials and earn ad revenues from youtube so you don’t have to write dumb shit code anymore.</p><p name="0ed1" id="0ed1" class="graf graf--p graf-after--p">We need to look at this from a business perspective.</p><ol class="postList"><li name="2dc5" id="2dc5" class="graf graf--li graf-after--p">Telling people to study official tutorial is bad for business.</li></ol><p name="4427" id="4427" class="graf graf--p graf-after--li">2. You need something iconic, routine that can be reproduced times and times again so people can feel they are participating in concrete production activities.</p><p name="4fc7" id="4fc7" class="graf graf--p graf-after--p">3. You want to throw in buzzwords, and create problems in SDK that need fixing as appetizer. This gives participant a sense of purpose. That they are using techniques to solve problems. It also takes away their focus when they are busy figuring out all the redundant protocols and generics they have to write.</p><p name="306d" id="306d" class="graf graf--p graf-after--p">4. If you were a lazy developer but wants to retire on ads revenue, what are your options? Are there well-known “architectures” that require people to write more codes, preferably brute-force code that need repeating for every view?</p><p name="3969" id="3969" class="graf graf--p graf-after--p">Of course there are. That is the industry. That is what you google for. And they know what keywords you google.</p><p name="2db3" id="2db3" class="graf graf--p graf-after--p">For example, you heard about MVVM. You google swiftUI MVVM. Then there is “clean architecture + Combine + Redux that fixes SwiftUI”.</p><p name="e216" id="e216" class="graf graf--p graf-after--p">You are thinking “oh shit, that is a lot to learn, I need to subscribe to some author/youtuber”. That’s how they got you.</p><p name="cbe3" id="cbe3" class="graf graf--p graf-after--p">You may be thinking, that you can then search for tutorials without MVVM.</p><p name="4c8b" id="4c8b" class="graf graf--p graf-after--p">Bang! They got you again! There are already videos on youtube that teach you how to write SwiftUI without MVVM.</p><p name="e7df" id="e7df" class="graf graf--p graf-after--p">It’s in fact very clever if you think about it.</p><p name="7b95" id="7b95" class="graf graf--p graf-after--p">First they sold you tutorials on MVVM. And when you finally had enough because it doesn’t seem to go anywhere but boilerplate after half a decade, they smell this and sell you tutorials on “why you don’t actually need MVVM”. Then they sold you how to write without MVVM. Fool you once, twice, thrice…</p><p name="1d59" id="1d59" class="graf graf--p graf-after--p">The same procedure can be applied to Clean Architecture, VIPER, VIP… basically all variants of MVVM. The one thing they have in common beside view model, is that they don’t want you to refactor.</p><p name="7282" id="7282" class="graf graf--p graf-after--p">Refactor is to make a piece of code reusable. Or if you are SDK, automatic.</p><p name="2406" id="2406" class="graf graf--p graf-after--p">If you have to create a view model for every view, why isn’t it refactored?</p><p name="acc1" id="acc1" class="graf graf--p graf-after--p">See how SwiftUI refactors it. You still have binding, but doesn’t require additional overheads.</p><p name="75f4" id="75f4" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Because it isn’t about refactor, is it?</strong></p><p name="3239" id="3239" class="graf graf--p graf-after--p">I mainly discuss MVVM variants here, but note that SwiftUI essentially makes it automatic. So it will be increasingly difficult to maintain this mirage when tides are turning.</p><p name="1015" id="1015" class="graf graf--p graf-after--p">As you can see, people are already applying marketing architecture to Redux-based SwiftUI.</p><p name="03f2" id="03f2" class="graf graf--p graf-after--p">As a wrap, I’m going to do a quick code review of the Redux aspects from the same author in above github. You can use it as an exercise to check your understanding of SwiftUI.</p><h4 name="ba37" id="ba37" class="graf graf--h4 graf-after--p">Why you quit using @ObservableObject for wrong reasons</h4><p name="0141" id="0141" class="graf graf--p graf-after--h4">This is the article. <a href="https://nalexn.github.io/swiftui-observableobject/" data-href="https://nalexn.github.io/swiftui-observableobject/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Why I quit using the ObservableObject</a>.</p><p name="84d2" id="84d2" class="graf graf--p graf-after--p">I’ll sketch his arguments first. Paraphrasing, so take it with a grain of salt.</p><p name="6b12" id="6b12" class="graf graf--p graf-after--p">First he said “single source of truth” is a buzzword. What’s next? Dependency injection is a buzzword too?</p><figure name="f52c" id="f52c" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*5XICtXGC6ztArsHzfLu3Kg.jpeg" data-width="805" data-height="500" src="https://cdn-images-1.medium.com/max/800/1*5XICtXGC6ztArsHzfLu3Kg.jpeg"></figure><p name="a4ca" id="a4ca" class="graf graf--p graf-after--figure">He then claimed SwiftUI has performance issues, which becomes a problem when you use Redux AppState which is a app-wide state management.</p><p name="45d2" id="45d2" class="graf graf--p graf-after--p">Since AppState is global, it must contain states irrelevant to some view. When a view updates itself due to irrelevant state changes, it causes performance issues. This is reasonable, because a view shouldn’t update when its state does not change.</p><p name="5741" id="5741" class="graf graf--p graf-after--p">So to solve this problem, he needs a “filter” on publisher to filter out only target state changes. If you are familiar with SwiftUI, this means you should use Combine for full-fledged publishers instead of @ObservableObject, which is a specialized publisher as a shortcut.</p><p name="8131" id="8131" class="graf graf--p graf-after--p">He went on ranting about how @ObservableObject is awkward to be customized (because it is not designed to be a generalized publisher), so he quit using it after various attempts.</p><p name="28ef" id="28ef" class="graf graf--p graf-after--p">He blamed it on SwiftUI, saying @ObservableObject is dog shit (obviously I’m paraphrasing), unfit for Redux. This is obviously dog shit, in my opinion.</p><p name="32d8" id="32d8" class="graf graf--p graf-after--p">If you are not going to use @ObservableObject, you don’t have @EnvironmentObject, which leaves you only @Environment. So you need to define environment keys and such.</p><p name="55ce" id="55ce" class="graf graf--p graf-after--p">Then you use full-fledged publisher with proper filtering, i.e.; <code class="markup--code markup--p-code">RemoveDuplicates</code> , which of course requires repetition for every view.</p><p name="a6d6" id="a6d6" class="graf graf--p graf-after--p">Finally, with filter, you can subscribe to only target states to avoid unnecessary view updates induced by global AppState.</p><p name="b862" id="b862" class="graf graf--p graf-after--p">Now the challenge for you. Can you one shot his arguments? As in shutdown, nullify, negate, counter his arguments with one simple refactor. No pressure, this guy is only the face of SwiftUI clean architecture.</p><p name="d85e" id="d85e" class="graf graf--p graf-after--p">I’ll share mine.</p><p name="9fbf" id="9fbf" class="graf graf--p graf-after--p">Then don’t use global AppState. Only observe states you need using @ObservableObject or better yet, @StateObject. Since irrelevant states don’t affect you, why subscribing to them then filtering them out?</p><p name="be2f" id="be2f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Then you realize you’ve come full circle back to vanilla SwiftUI SDK. This is what happens when you think you are too good to study official tutorial.</strong></p><p name="ac12" id="ac12" class="graf graf--p graf-after--p">To be fair, this article is written in late 2019. It’s not fair to judge it using years of experience, but then again, he never felt the need to take it down or correct it. The github is last updated just months ago. His article about how MVVM is the new standard in SwiftUI is still a top search result.</p><p name="f9cc" id="f9cc" class="graf graf--p graf-after--p">That’s what I’m talking about.</p><p name="823d" id="823d" class="graf graf--p graf-after--p">It has never been about refactor. Clean never means correct, or well designed.</p><p name="0f6f" id="0f6f" class="graf graf--p graf-after--p graf--trailing"><strong class="markup--strong markup--p-strong">Clean is a marketing architecture.</strong></p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/1f24fe60549c"><time class="dt-published" datetime="2022-09-06T11:00:52.170Z">September 6, 2022</time></a>.</p><p><a href="https://medium.com/@swift2931/the-clean-marketing-architecture-1f24fe60549c" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>