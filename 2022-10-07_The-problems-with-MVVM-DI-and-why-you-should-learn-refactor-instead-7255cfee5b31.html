<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>The problems with MVVM DI and why you should learn refactor instead</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">The problems with MVVM DI and why you should learn refactor instead</h1>
</header>
<section data-field="subtitle" class="p-summary">
The first step of a MVVM idiomatic solution: create a problem
</section>
<section data-field="body" class="e-content">
<section name="95f7" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="3f50" id="3f50" class="graf graf--h3 graf--leading graf--title">The problems with MVVM DI and why you should learn refactor instead</h3><figure name="956e" id="956e" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*tozI-Yu5gbi9EqJJgvVvbQ.jpeg" data-width="500" data-height="714" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*tozI-Yu5gbi9EqJJgvVvbQ.jpeg"></figure><h4 name="32b0" id="32b0" class="graf graf--h4 graf-after--figure">The first step of a MVVM idiomatic solution: create a problem</h4><p name="9022" id="9022" class="graf graf--p graf-after--h4">Saw this article on highlight:</p><p name="e4e2" id="e4e2" class="graf graf--p graf-after--p"><a href="https://medium.com/@fatihcyln/the-problems-with-singletons-and-why-you-should-use-di-instead-5a0fa0a5baed" data-href="https://medium.com/@fatihcyln/the-problems-with-singletons-and-why-you-should-use-di-instead-5a0fa0a5baed" class="markup--anchor markup--p-anchor" target="_blank">The Problems with Singletons and Why You Should Use DI Instead</a></p><p name="a7da" id="a7da" class="graf graf--p graf-after--p">in which it outlines symptoms of a disease known as MVVM that has been plaguing and hindering the progress of Swift for years.</p><p name="0487" id="0487" class="graf graf--p graf-after--p">Let’s see the problem he creates:</p><figure name="3e28" id="3e28" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*KpKAbMtb3WkT-5AmyxxXtg.png" data-width="577" data-height="240" src="https://cdn-images-1.medium.com/max/800/1*KpKAbMtb3WkT-5AmyxxXtg.png"></figure><ol class="postList"><li name="e9ca" id="e9ca" class="graf graf--li graf-after--figure">No arguements there. Globals are dangerous, yes. Use it under strict scrutiny and code review.</li><li name="0a1e" id="0a1e" class="graf graf--li graf-after--li">Why not??? It is just an object you create. And initializer is not the only place you can pass parameters. e.g.; function parameters.</li><li name="b674" id="b674" class="graf graf--li graf-after--li">You can design it to be configurable at runtime.</li></ol><p name="b43d" id="b43d" class="graf graf--p graf-after--li">So to solve the “problem” of having a singleton “fetch service”, his solution is to</p><blockquote name="7606" id="7606" class="graf graf--blockquote graf-after--p">You just need to <strong class="markup--strong markup--blockquote-strong">inject your dependency to all the views</strong>, view models which need that dependency. That’s all, <strong class="markup--strong markup--blockquote-strong">it’s not complicated</strong>.</blockquote><figure name="d9d1" id="d9d1" class="graf graf--figure graf-after--blockquote"><img class="graf-image" data-image-id="1*9BcOs3XScNz3nzYFO77OAg.gif" data-width="260" data-height="141" src="https://cdn-images-1.medium.com/max/800/1*9BcOs3XScNz3nzYFO77OAg.gif"><figcaption class="imageCaption">You use singleton to avoid injecting it to every view? Nah, just inject it to every view.</figcaption></figure><p name="5b0f" id="5b0f" class="graf graf--p graf-after--figure">Once again I’m stunned by the sheer genius displayed by MVVM devs.</p><p name="c0ab" id="c0ab" class="graf graf--p graf-after--p">They know you’ll ask wtf do you inject anything to views, that’s where view model comes in.</p><figure name="ee5f" id="ee5f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*P9qZOkR5p8DMUozrDDcdNw.jpeg" data-width="559" data-height="447" src="https://cdn-images-1.medium.com/max/800/1*P9qZOkR5p8DMUozrDDcdNw.jpeg"></figure><p name="8ec6" id="8ec6" class="graf graf--p graf-after--figure">We totally are not injecting anything directly to view. We inject it <em class="markup--em markup--p-em">indirectly</em>. This provides <em class="markup--em markup--p-em">separation of concerns</em> and <em class="markup--em markup--p-em">testablitiy</em>.</p><p name="7072" id="7072" class="graf graf--p graf-after--p">Ladies and gentlemen, may I present you<strong class="markup--strong markup--p-strong"> the idiomatic MVVM solution</strong>. Or as I call it: <strong class="markup--strong markup--p-strong">injection hell</strong>.</p><p name="c9dc" id="c9dc" class="graf graf--p graf-after--p">You know this will be abused to an absurd degree just from these arguments.</p><p name="513a" id="513a" class="graf graf--p graf-after--p">E.g.; inject url to fetch, inject fetch to view controller, which injects fetch to view model, which is then injected to view; now do it for every view; then do it using type-erased protocols; then do everything all over again for mocking.</p><p name="db6f" id="db6f" class="graf graf--p graf-after--p">You know who will advertise this as an absolute win?</p><figure name="29f2" id="29f2" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*NmdRP7bEE6inC8K6ybJ2fw.jpeg" data-width="639" data-height="390" src="https://cdn-images-1.medium.com/max/800/1*NmdRP7bEE6inC8K6ybJ2fw.jpeg"></figure><h4 name="643f" id="643f" class="graf graf--h4 graf-after--figure">The real problem</h4><figure name="9ba5" id="9ba5" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*fNKxE7vPnxPSv0EOY23Q1A.png" data-width="732" data-height="589" src="https://cdn-images-1.medium.com/max/800/1*fNKxE7vPnxPSv0EOY23Q1A.png"><figcaption class="imageCaption">A brute force endpoint fetch</figcaption></figure><p name="2193" id="2193" class="graf graf--p graf-after--figure">Identify the design problems.</p><p name="8f7c" id="8f7c" class="graf graf--p graf-after--p">Fetch function is <strong class="markup--strong markup--p-strong">dependent on </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">Post</strong></code> , a specifict model type used to update specific view.</p><p name="1bf1" id="1bf1" class="graf graf--p graf-after--p">The property <code class="markup--code markup--p-code">url</code> makes this “service‘ a fetch for specific endpoint instead of networking service which manages all endpoints.</p><p name="8db9" id="8db9" class="graf graf--p graf-after--p">This is not a network service, this is a fetch wrapped as a service that only works for a specific model type <code class="markup--code markup--p-code">Post</code> . Instead of function parameters like <code class="markup--code markup--p-code">api.fetch(url)</code> , he needs a type and an initializer for parameter <code class="markup--code markup--p-code">url</code> .</p><p name="132e" id="132e" class="graf graf--p graf-after--p">Say we have another view that uses another model <code class="markup--code markup--p-code">DogShitMVVM</code> . What do you need to do?</p><ol class="postList"><li name="3dd6" id="3dd6" class="graf graf--li graf-after--p">Create <code class="markup--code markup--li-code">AnotherRealDataService</code> , with function <code class="markup--code markup--li-code">downloadDogShitMVVM(... Result&lt;DogShitMVVM&gt;...)</code> , with fetch codes copy-pasted. (<strong class="markup--strong markup--li-strong">fetch refactor failed</strong>)</li><li name="9f50" id="9f50" class="graf graf--li graf-after--li">Create a protocol that requires implementation of<code class="markup--code markup--li-code">downloadDogShitMVVM</code> . There’s no default implementation so one has to copy paste fetch code when conforming to it. (POP failed, fetch refactor failed)</li><li name="1124" id="1124" class="graf graf--li graf-after--li">Create a view model, create binding, use third party <code class="markup--code markup--li-code">ObservableObject</code> .</li><li name="36b8" id="36b8" class="graf graf--li graf-after--li">Injection hell. You need to inject all the way from f-ing <code class="markup--code markup--li-code">SceneDelegate</code> !</li></ol><figure name="c116" id="c116" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*iV9bwYC8n0gOUFSJzby0_A.jpeg" data-width="578" data-height="431" src="https://cdn-images-1.medium.com/max/800/1*iV9bwYC8n0gOUFSJzby0_A.jpeg"><figcaption class="imageCaption">A live view of MVVM development</figcaption></figure><p name="55d2" id="55d2" class="graf graf--p graf-after--figure">Would you describe this process as massively tedious that is not scalable in even the small apps?</p><p name="30a2" id="30a2" class="graf graf--p graf-after--p">OK, maybe you don’t have the expertise to use singletons. Design a network service that you can use as local instances. E.g.;</p><pre name="0ecc" id="0ecc" class="graf graf--pre graf-after--p">class ViewModel {</pre><pre name="fa47" id="fa47" class="graf graf--pre graf-after--pre">    let api = NetworkService()</pre><pre name="bd89" id="bd89" class="graf graf--pre graf-after--pre">    // api.fetch(url)...<br>}</pre><p name="8b84" id="8b84" class="graf graf--p graf-after--pre">Why f-ing inject it all the way from China???</p><p name="4ce5" id="4ce5" class="graf graf--p graf-after--p">It’s not <code class="markup--code markup--p-code">SceneDelegate</code> ‘s job to create an object that will be used by a property(vm) of its property(vc) which requres <code class="markup--code markup--p-code">url</code> that has nothing to do with <code class="markup--code markup--p-code">SceneDelegate</code> .</p><p name="288d" id="288d" class="graf graf--p graf-after--p">You know what happens to those that write massive view controller?</p><p name="0205" id="0205" class="graf graf--p graf-after--p">They all become MVVM devs. Because why not? You don’t refactor for shit, can disrespect SDK all you want, and sell tutorial on how to create boilerplate, useless designs.</p><p name="ef70" id="ef70" class="graf graf--p graf-after--p">Speaking of useless designs, let’s look at an example.</p><h4 name="93f8" id="93f8" class="graf graf--h4 graf-after--p">POP != DI</h4><figure name="88c6" id="88c6" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*xyjNLvJ4CX5cbaj36DzdFw.png" data-width="721" data-height="118" src="https://cdn-images-1.medium.com/max/800/1*xyjNLvJ4CX5cbaj36DzdFw.png"></figure><p name="1281" id="1281" class="graf graf--p graf-after--figure">What are the use cases for you to conform to this protocol?</p><p name="f50b" id="f50b" class="graf graf--p graf-after--p">Mocking. OK. And…?</p><p name="faa9" id="faa9" class="graf graf--p graf-after--p">You don’t create a new type conforming to it for an url change, do you?</p><p name="a41a" id="a41a" class="graf graf--p graf-after--p">Or are you expecting 20 different protocol objects at runtime? What if 10 of which use the exact same fetch code? Copy-paste 10 times?</p><p name="2260" id="2260" class="graf graf--p graf-after--p">Can other view models use this? No, because its dependency to <code class="markup--code markup--p-code">Post</code> .</p><p name="2c95" id="2c95" class="graf graf--p graf-after--p">The most common use case, is 1 protocol object, determined in compile time.</p><p name="1d79" id="1d79" class="graf graf--p graf-after--p">The second most common use case, is 1 protocol object, with 2 or 3 different urls that you can take care of using a function parameter.</p><p name="c067" id="c067" class="graf graf--p graf-after--p">These two should cover 99% of use cases. So from my perspective, he is using the most general design for the most improbable use case and apply it as <em class="markup--em markup--p-em">routine </em>boilerplate for <em class="markup--em markup--p-em">every </em>use case. This describes MVVM.</p><p name="79e2" id="79e2" class="graf graf--p graf-after--p">POP does not mean use type-erased protocol objects everywhere. That is over-generalization. POP requires thinking in <em class="markup--em markup--p-em">protocol composition</em>, which doesn’t care how you satisfy the property requirements, only that you satisfy them. So the focus shifts to <em class="markup--em markup--p-em">functions</em>. Protocol composition can be seen as function composition. There’s no emphasis of function in MVVM which is all about moving properties outside. Property requirements from protocol composition needs you to have all properties in one place. This observation tells you that MVVM works in the <strong class="markup--strong markup--p-strong">opposite </strong>direction of POP.</p><p name="a2ef" id="a2ef" class="graf graf--p graf-after--p">To be more specific, POP wants composition,</p><pre name="a3bc" id="a3bc" class="graf graf--pre graf-after--p">class Service: A, B, C {...}</pre><p name="16f6" id="16f6" class="graf graf--p graf-after--pre">where DI wants this</p><pre name="a60a" id="a60a" class="graf graf--pre graf-after--p">init(a: A, b: B, c: C) </pre><p name="2cb1" id="2cb1" class="graf graf--p graf-after--pre">So MVVM + DI becomes this</p><pre name="db44" id="db44" class="graf graf--pre graf-after--p">class ViewModelA {<br>    init(a: A)<br>}<br>// can&#39;t have B, C because their properties are not here</pre><p name="4937" id="4937" class="graf graf--p graf-after--pre">So you have the worst of both worlds. Hard to do composition, easy to do over-generalization.</p><p name="0d3a" id="0d3a" class="graf graf--p graf-after--p">If there’s one take away from this article, take away this:</p><p name="e8ed" id="e8ed" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Do the opposite of what MVVM tells you, and you will be right.</strong></p><p name="e56e" id="e56e" class="graf graf--p graf-after--p">Generalization != better. Being type specific gives you huge advantages in Swift which has a very strict type system, and help you avoid many runtime errors.</p><p name="faa2" id="faa2" class="graf graf--p graf-after--p">There’s only 1 type of developer that try to generalize everything. Let me say it again.</p><p name="6ffc" id="6ffc" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Do the opposite of what MVVM tells you, and you will be right.</strong></p><p name="481d" id="481d" class="graf graf--p graf-after--p">DI has its use. But that doesn’t mean you inject everything in every use case.</p><p name="c4a4" id="c4a4" class="graf graf--p graf-after--p">For some reason, it becomes a law in MVVM communities that you do DI for mocking. Applying the principle of</p><p name="d100" id="d100" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Do the opposite of what MVVM tells you, and you will be right.</strong></p><p name="ef74" id="ef74" class="graf graf--p graf-after--p">We know the right approach must be doing mocking without DI.</p><p name="59a4" id="59a4" class="graf graf--p graf-after--p">Let’s examine it.</p><h4 name="e183" id="e183" class="graf graf--h4 graf-after--p">Step 2 of a MVVM idiomatic solution: brute force disguised in abstract principles</h4><figure name="a75e" id="a75e" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*pkUDnnai0kfPnJvUtgzl6Q.png" data-width="720" data-height="278" src="https://cdn-images-1.medium.com/max/800/1*pkUDnnai0kfPnJvUtgzl6Q.png"><figcaption class="imageCaption">You can infer “protocol” from its placement so the word “Protocol” is redundant in naming btw.</figcaption></figure><p name="2647" id="2647" class="graf graf--p graf-after--figure">First question: what is it that you are testing?</p><p name="3294" id="3294" class="graf graf--p graf-after--p">In this case he made <code class="markup--code markup--p-code">mockPosts</code> , which is injected from GOD KNOWS WHERE. I’M SICK AND TIRED OF INJECTING EVERYTHING. HAVE SOME FKING DEFAULTS GOD DAMN IT. (not to mention your initializer will explode from all sources of injection, making it scale extremely poorly)</p><p name="db17" id="db17" class="graf graf--p graf-after--p">Since <code class="markup--code markup--p-code">[Post]</code> is used to update view. What is it that you are testing? Test if the view is correctly updated? But this ain’t UI test. Test if the model is correctly updated? How? Test if <code class="markup--code markup--p-code">[Post]</code> == <code class="markup--code markup--p-code">[Post]</code> ? The thing that you purposefully generated is really the thing you purposefully generated?</p><p name="e77a" id="e77a" class="graf graf--p graf-after--p">Even if you have computed properties derived from <code class="markup--code markup--p-code">[Post]</code> , they don’t know anything about networking. You can test it from within view model itself.</p><p name="ed00" id="ed00" class="graf graf--p graf-after--p">And technically speaking, since you swap out <code class="markup--code markup--p-code">RealDataService</code> for <code class="markup--code markup--p-code">MockDataService</code> , you are not testing any path from <code class="markup--code markup--p-code">RealDataService</code> , which is production code. Preferably you want to test mocking and networking path in one go.</p><p name="d2fd" id="d2fd" class="graf graf--p graf-after--p">Second question: Can you mock it without DI?</p><p name="6832" id="6832" class="graf graf--p graf-after--p">Of course you can.</p><pre name="d43b" id="d43b" class="graf graf--pre graf-after--p">vm.model = mockPosts</pre><p name="c856" id="c856" class="graf graf--p graf-after--pre">Isn’t this kind of the major benefit that MVVM advertises? For some reason MVVM devs hurt their own case by introducing a complex DI system with insane overheads to do the thing they should be able to do in thier sleep.</p><p name="f51a" id="f51a" class="graf graf--p graf-after--p">Or you can setup network service to return mocked data when in testing.</p><pre name="1f8a" id="1f8a" class="graf graf--pre graf-after--p">let api = NetworkService(mocking: true)<br>// api.getPosts.mockData = ...  </pre><p name="efb8" id="efb8" class="graf graf--p graf-after--pre">Notice how I design to make the process lightweight and configurable. Not brute force creating the same shit over and over again.</p><p name="f300" id="f300" class="graf graf--p graf-after--p">Now it’s the time to highlight this immortal statement.</p><figure name="24d0" id="24d0" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*zXS3GDsfmy8uJssnLBQu1w.png" data-width="501" data-height="76" src="https://cdn-images-1.medium.com/max/800/1*zXS3GDsfmy8uJssnLBQu1w.png"></figure><p name="43fc" id="43fc" class="graf graf--p graf-after--figure">No. Unless an injection hell starting from China and having to duplicate production code for every injection for every view for inefficient mocking is somehow scalable for big apps.</p><p name="c6e0" id="c6e0" class="graf graf--p graf-after--p">Manually creating something for every view is the dumbest shit you can do in big apps. You want shared service, least amount of bootstrap / setup / injection, most lightweight mocking so you don’t have to write the same shit for every view in big apps. You dont write 50 assignments for 50 views; you use for loop. Brute force solution can be disgused as view model because view model itself is a brute force solution. You want SDK support for automatic binding.</p><figure name="0c7c" id="0c7c" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*UqZN9amK8lirdgYDb2UdUA.png" data-width="708" data-height="676" src="https://cdn-images-1.medium.com/max/800/1*UqZN9amK8lirdgYDb2UdUA.png"></figure><p name="3a1b" id="3a1b" class="graf graf--p graf-after--figure">65% of MVVM devs don’t have concept of binding.</p><p name="4c53" id="4c53" class="graf graf--p graf-after--p">So this guy is top 35% already. Look at <code class="markup--code markup--p-code">addBindders()</code> .</p><p name="1235" id="1235" class="graf graf--p graf-after--p">He uses a custom <code class="markup--code markup--p-code">ObservableObject</code> to support a observable-like callback.</p><p name="0d72" id="0d72" class="graf graf--p graf-after--p">Let me ask you, what’s the difference between this and</p><pre name="bb13" id="bb13" class="graf graf--pre graf-after--p">var posts = [Posts]() { didSet {self.tableView.reloadData() }}</pre><pre name="0ef1" id="0ef1" class="graf graf--pre graf-after--pre">// api.fetch(url) which updates posts in callback</pre><p name="f1b0" id="f1b0" class="graf graf--p graf-after--pre">Without middle man. Do you need RxSwift + MVVM to pull this off? No.</p><p name="05e7" id="05e7" class="graf graf--p graf-after--p">Is this MVVM? Depending on your definition of view model. If it is a model used to update view, then yes.</p><p name="61aa" id="61aa" class="graf graf--p graf-after--p">You can pull this off when your model is in the view controller. This simplifies your design greatly. When your properties are in one place, you can do POP with <em class="markup--em markup--p-em">default implementations which refactor out functions not models</em>. You don’t do DI for 1% of the use cases.</p><p name="f2e7" id="f2e7" class="graf graf--p graf-after--p">MVVM + DI = refacout out models, more generalization</p><p name="1a88" id="1a88" class="graf graf--p graf-after--p">POP = refactor out functions as extension, less generalization (because it’s a lot more difficult to pull off init and associatedType in protocol extension)</p><p name="af66" id="af66" class="graf graf--p graf-after--p">It makes sense, because you always start with the simplest solution for most use cases. That’s why you start with protocol extension, if it doesn’t work, work towards a more complex design.</p><p name="3700" id="3700" class="graf graf--p graf-after--p">There’s no concept of property observer, value type, protocol extension in MVVM. That makes MVVM (typical implementation) outdated in Swift, let alone SwiftUI.</p><p name="4074" id="4074" class="graf graf--p graf-after--p">Do you know how easy it is to destroy something like <a href="https://clean-swift.com/" data-href="https://clean-swift.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">clean swift</a> using these language features? Look at how clean swift builds its callback chain without observer. Tedious boilerplate mess dog shit. Details <a href="https://swift2931.medium.com/regular-view-controller-for-fixing-clean-swift-ios-architecture-fd785088d788" data-href="https://swift2931.medium.com/regular-view-controller-for-fixing-clean-swift-ios-architecture-fd785088d788" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">here</a>.</p><h4 name="ff8e" id="ff8e" class="graf graf--h4 graf-after--p">Step 3: ??? Step4: Profit.</h4><p name="12de" id="12de" class="graf graf--p graf-after--h4">I was there the day when the strength of MVVM failed.</p><figure name="b93f" id="b93f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*2uGkIF2psSILWkiYe3-Qog.jpeg" data-width="1164" data-height="480" src="https://cdn-images-1.medium.com/max/800/1*2uGkIF2psSILWkiYe3-Qog.jpeg"></figure><p name="09df" id="09df" class="graf graf--p graf-after--figure">The MVVM community is failing. The art of refactor is all but spent, its pride and dignity forgotten. It is because of idiotic MVVM pumpers the anti pattern survives.</p><figure name="e5f8" id="e5f8" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*URRqYaK6_p1Mb1IS9qwpcg.png" data-width="728" data-height="214" src="https://cdn-images-1.medium.com/max/800/1*URRqYaK6_p1Mb1IS9qwpcg.png"></figure><p name="4b45" id="4b45" class="graf graf--p graf-after--figure">Do you notice the <code class="markup--code markup--p-code">getPosts()</code> call in initializer?</p><p name="c919" id="c919" class="graf graf--p graf-after--p">An async function with major side effects <code class="markup--code markup--p-code">tableView.reloadData()</code> in initializer. Now a caller has to worry about implicit race conditions during init. If you use this on <code class="markup--code markup--p-code">tableViewCell</code> , you risk sending unecessary fetchs on qucik scrolling.</p><p name="45a9" id="45a9" class="graf graf--p graf-after--p">Remove DI, what does it do? Calling <code class="markup--code markup--p-code">getPosts()</code> wtihout you knowing? A storage of model instance that you have to do external binding from outside of view model anyway?</p><p name="d7d0" id="d7d0" class="graf graf--p graf-after--p">Where’s value type (two level of reference type wrappers, view model and obserbable object), property observer, and protocol extension?</p><p name="ba66" id="ba66" class="graf graf--p graf-after--p graf--trailing">The example here is a very common MVVM practice. You can see the same shit in every MVVM tutorials on youtube. If this were “textbook” MVVM, then MVVM is anti pattern.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/7255cfee5b31"><time class="dt-published" datetime="2022-10-07T10:40:26.296Z">October 7, 2022</time></a>.</p><p><a href="https://medium.com/@swift2931/the-problems-with-mvvm-di-and-why-you-should-learn-refactor-instead-7255cfee5b31" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>