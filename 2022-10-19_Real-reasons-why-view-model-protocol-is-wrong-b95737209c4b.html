<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Real reasons why view model protocol is wrong</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Real reasons why view model protocol is wrong</h1>
</header>
<section data-field="subtitle" class="p-summary">
Where is protocol extension?
</section>
<section data-field="body" class="e-content">
<section name="e775" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="e0c3" id="e0c3" class="graf graf--h3 graf--leading graf--title">Real reasons why view model protocol is wrong</h3><p name="8ecd" id="8ecd" class="graf graf--p graf-after--h3">Where is protocol extension?</p><figure name="347f" id="347f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*CQv8qvN0HEzjWoOUIIQ_8g.png" data-width="545" data-height="313" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*CQv8qvN0HEzjWoOUIIQ_8g.png"><figcaption class="imageCaption">From House M.D.</figcaption></figure><blockquote name="612e" id="612e" class="graf graf--blockquote graf-after--figure">SwiftUI, <strong class="markup--strong markup--blockquote-strong">MVVM, and Protocol-Oriented-Programming</strong> are a perfect match… when <strong class="markup--strong markup--blockquote-strong">done correctly</strong>.</blockquote><h4 name="1250" id="1250" class="graf graf--h4 graf-after--blockquote">He did not do it correctly</h4><p name="97a7" id="97a7" class="graf graf--p graf-after--h4">This is the top result when I searched “view model protocol is wrong”.</p><p name="18f3" id="18f3" class="graf graf--p graf-after--p"><a href="https://betterprogramming.pub/swiftui-view-models-are-not-protocols-8c415c0325b1" data-href="https://betterprogramming.pub/swiftui-view-models-are-not-protocols-8c415c0325b1" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Using View Model Protocols in SwiftUI? You’re Doing it Wrong.</a></p><p name="ed11" id="ed11" class="graf graf--p graf-after--p">In which he painted a rosy picture where MVVM is so awesome that it can have unit-test-like mcoking in preview; and the problem of view model protocol is that it results in a less unit-test-like mocking. Still awesome, but not as awesome as could be.</p><p name="172a" id="172a" class="graf graf--p graf-after--p">That’s some MVVM propaganda right there.</p><p name="6d84" id="6d84" class="graf graf--p graf-after--p">Let me be clear.</p><p name="ab2d" id="ab2d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">View model protocol is an intellectual dumpster fire.</strong></p><p name="d40d" id="d40d" class="graf graf--p graf-after--p">By his definition</p><blockquote name="a341" id="a341" class="graf graf--blockquote graf-after--p">View Models should contain <em class="markup--em markup--blockquote-em">all</em> of a view’s business logic, calculations, data manipulation, and data formatting.</blockquote><p name="c7b8" id="c7b8" class="graf graf--p graf-after--blockquote">That is, view model contains everything. So a view model protocol requires everything. You cannot do <em class="markup--em markup--p-em">protocol composition</em> with that. On the contrary, it needs <em class="markup--em markup--p-em">protocol decomposition</em>.</p><p name="573b" id="573b" class="graf graf--p graf-after--p">And if all you want to do with it is mocking some data, you wouldn’t bother re-implementing everything. Is a protocol that requires everything really the best solution? And if you were to do it, why not reuse as much as possible via protocol extension?</p><p name="b26d" id="b26d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Where is protocol extension?</strong></p><p name="1196" id="1196" class="graf graf--p graf-after--p">Let’s examine his protocol design.</p><h4 name="62cc" id="62cc" class="graf graf--h4 graf-after--p">Brute force protocol</h4><p name="3ba6" id="3ba6" class="graf graf--p graf-after--h4">What’s the problem with this?</p><pre name="e9d5" id="e9d5" class="graf graf--pre graf-after--p">protocol AccountLoading {<br>    func loadAccounts() -&gt; ([Account], String)?<br>}<br>extension API: AccountLoading {}</pre><p name="8f6e" id="8f6e" class="graf graf--p graf-after--pre">A typical app has 50+ API endpoints.</p><p name="aec2" id="aec2" class="graf graf--p graf-after--p">From protocol composition point of view, I’d say keep the number of protocols to conform under 5. If it exceeds 5, you might need to consider delegation or refactor. Something that conforms to 50+ protocols that can be extended from anywhere in code might not be as easy to maintain as you think.</p><p name="0542" id="0542" class="graf graf--p graf-after--p">From overhead point of view, you need to create a type to conform to it then plug it in somewhere. So what happens when you need to mock 10 test cases of <code class="markup--code markup--p-code">loadAccounts()</code> in a rapid test? You create 10 one-off types that conform to it?</p><p name="ab75" id="ab75" class="graf graf--p graf-after--p">Create one protocol for one function, then create one type that conforms to it for <em class="markup--em markup--p-em">every entry</em> of mock data. I call this kind of usage <strong class="markup--strong markup--p-strong">brute force</strong>. In MVVM it is called <strong class="markup--strong markup--p-strong">a perfect match</strong>.</p><blockquote name="8478" id="8478" class="graf graf--blockquote graf-after--p">MVVM, and Protocol-Oriented-Programming are <strong class="markup--strong markup--blockquote-strong">a perfect match</strong>…</blockquote><p name="be37" id="be37" class="graf graf--p graf-after--blockquote">And there’s no protocol extension for that funciton. This is important because protocol composition is not just a composition of protocols. It is a composition of <strong class="markup--strong markup--p-strong">workable self-contained pieces of codes</strong>.</p><pre name="add6" id="add6" class="graf graf--pre graf-after--p">class Service: A, B, C, D, E</pre><p name="4c26" id="4c26" class="graf graf--p graf-after--pre">This compostion is worthless if you have to implement them from scratch. It is easier to just implement your shit without them.</p><p name="efd6" id="efd6" class="graf graf--p graf-after--p">You want those protocols to be functioning codes that already do the job, but can be customized to fit your need.</p><p name="1364" id="1364" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Most of the work is done in protocol extensions.</strong></p><p name="330b" id="330b" class="graf graf--p graf-after--p">This changes entirely how you design the code. That is why it is <em class="markup--em markup--p-em">protocol-oriented</em>. Think in compostion, build in extension.</p><p name="8675" id="8675" class="graf graf--p graf-after--p">Sure, not every protocol is meant for composition. You can use it in legacy OOP sense. But if someone claimed this</p><blockquote name="34ae" id="34ae" class="graf graf--blockquote graf-after--p">MVVM, and Protocol-Oriented-Programming are <strong class="markup--strong markup--blockquote-strong">a perfect match</strong>…</blockquote><p name="7604" id="7604" class="graf graf--p graf-after--blockquote">It better has some mind-blowing great design that pushes POP to its limits.</p><p name="853b" id="853b" class="graf graf--p graf-after--p">I don’t see that anywhere, at least in this example, in which he uses protocol to inject a function.</p><p name="f3f6" id="f3f6" class="graf graf--p graf-after--p">View model protocol is exactly that! Only that it uses protocol to inject the whole view model. Same thinking process. Same brute force.</p><p name="3602" id="3602" class="graf graf--p graf-after--p">Let’s try this with protocol extension.</p><h4 name="d7ce" id="d7ce" class="graf graf--h4 graf-after--p">Protocol extension is the process of refactor</h4><p name="f00b" id="f00b" class="graf graf--p graf-after--h4">Instead of</p><pre name="c2a8" id="c2a8" class="graf graf--pre graf-after--p">      let vm2 = AccountListViewModel(loader: MockTwoAccounts())<br>      AccountListView(viewModel: vm2)<br>            <br>      let vm0 = AccountListViewModel(loader: MockNoAccounts())<br>      AccountListView(viewModel: vm0)<br>            <br>      let vme = AccountListViewModel(loader: MockAccountsError())<br>      AccountListView(viewModel: vme)</pre><p name="655f" id="655f" class="graf graf--p graf-after--pre">We want</p><pre name="d862" id="d862" class="graf graf--pre graf-after--p">AccountList(mockData: data1)<br>AccountList(mockData: data2)<br>AccountList(mockData: data3)<br>// where data1,2,3 are generated mock data, not protocol objects</pre><p name="61b3" id="61b3" class="graf graf--p graf-after--pre">The benefits are clear. The emphasis is to check model-view binding in preview; We want flattest structure and fastest generation. Proving view model is useless and can be removed is an added bonus.</p><p name="dbb0" id="dbb0" class="graf graf--p graf-after--p">We can start with this:</p><pre name="bac4" id="bac4" class="graf graf--pre graf-after--p">protocol MockableLoad {<br>    associatedType DataType<br>    var mockData: DataType? {get set}</pre><pre name="fb2a" id="fb2a" class="graf graf--pre graf-after--pre">    var api: NetworkService {get set}<br>    var endpoint: String {get}</pre><pre name="01db" id="01db" class="graf graf--pre graf-after--pre">    func mokableLoad() async throws -&gt; DataType<br>}<br>extension MockableLoad {<br>    func mokableLoad() async throws -&gt; DataType {<br>       if let d = mockData {<br>            return d<br>       } else {<br>           // may need to convert from JSON to DataType<br>           // omitted for simplicity<br>           return api.load(endpoint)<br>       }<br>    }<br>}</pre><p name="a472" id="a472" class="graf graf--p graf-after--pre">This is a workable piece of code. It can actually load something via api call.</p><p name="cc00" id="cc00" class="graf graf--p graf-after--p">You can customize it via <code class="markup--code markup--p-code">endpoint</code> , <code class="markup--code markup--p-code">associatedType</code> .</p><p name="0d08" id="0d08" class="graf graf--p graf-after--p">Conforming to it:</p><pre name="af7e" id="af7e" class="graf graf--pre graf-after--p">struct AccountList: View, MockableLoad {<br>    ...<br>    @State var state: LocalState = .loading</pre><pre name="b106" id="b106" class="graf graf--pre graf-after--pre">    ...task { <br>          let data = try? await self.mockableLoad()<br>          self.state = stateMachine(data)<br>       }<br>...</pre><p name="f21c" id="f21c" class="graf graf--p graf-after--pre">You can unit test stateMachine as much as you like.</p><p name="16a0" id="16a0" class="graf graf--p graf-after--p">I hope this convinces you that it’s a viable solution. This is by no means a general or best solution. This is to show you that there’s a world outside MVVM where you can still have state machine, model-view binding, protocol extension… etc; as compared to injecting everything, creating protocols for everything, creating view models for everything, then creating view model protocols for everything.</p><p name="6ba7" id="6ba7" class="graf graf--p graf-after--p">Note that since <code class="markup--code markup--p-code">api: NetworkService</code> is already required by a protocol, you might as well share it with other networking related protocols. This opens a door to protocol composition. Since the major function <code class="markup--code markup--p-code">mockableLoad()</code> is refactored outside of <code class="markup--code markup--p-code">AccountList</code> as default implementation, your <code class="markup--code markup--p-code">AccountList</code> is cleaner.</p><p name="50c1" id="50c1" class="graf graf--p graf-after--p">There are only two sources of default implementation of member functions that I know of in Swift. Inheritance and protocol extension. If you work with value types like I did above, protocol extension is your only refactor tool.</p><p name="bf56" id="bf56" class="graf graf--p graf-after--p">There’s no mention of inheritance or protocol extension in his example. Only protocol injection is shown. How do you expect devs trained from that school of MVVM to have expertise in refactor?</p><p name="8af1" id="8af1" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">View model protocol is a symptom. MVVM is the disease.</strong></p><p name="8075" id="8075" class="graf graf--p graf-after--p">As a wrap, let’s debunk some of his MVVM mistakes.</p><h4 name="ac93" id="ac93" class="graf graf--h4 graf-after--p">I can play this game too</h4><figure name="e190" id="e190" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*RcFIzCBSfdHEGB9moWGgbQ.png" data-width="836" data-height="511" src="https://cdn-images-1.medium.com/max/800/1*RcFIzCBSfdHEGB9moWGgbQ.png"><figcaption class="imageCaption">Oh, colorful diagrams?</figcaption></figure><p name="3899" id="3899" class="graf graf--p graf-after--figure">Quotes:</p><blockquote name="9648" id="9648" class="graf graf--blockquote graf-after--p">Prior to that, developers tended to <strong class="markup--strong markup--blockquote-strong">dump all of that logic</strong> <strong class="markup--strong markup--blockquote-strong">and the user event handling and even a good deal of the API request </strong>code into the one and only view controller responsible for a given screen.<strong class="markup--strong markup--blockquote-strong"> Splitting the responsibilities between the view controller and the view model</strong>, at the very least, <strong class="markup--strong markup--blockquote-strong">reduced the size of each by half.</strong></blockquote><p name="6276" id="6276" class="graf graf--p graf-after--blockquote">Then he says</p><blockquote name="7655" id="7655" class="graf graf--blockquote graf-after--p">In MVVM the view or view controller wants to be as dumb as possible.</blockquote><p name="99d9" id="99d9" class="graf graf--p graf-after--blockquote">So 50%, 50% split at least; 0%, 100% split at best.</p><p name="fbcc" id="fbcc" class="graf graf--p graf-after--p">Is he saying that developers should dump all of that logic and the user event handling and even a good deal of the API request code into the one and only <strong class="markup--strong markup--p-strong">view model</strong>? Because that’s the only place left!</p><p name="a86f" id="a86f" class="graf graf--p graf-after--p">I love how developers base their design over colorful diagrams on Internet. Does he ever go into details about the design of vanilla SwiftUI?</p><p name="1145" id="1145" class="graf graf--p graf-after--p">For example, he says</p><blockquote name="9848" id="9848" class="graf graf--blockquote graf-after--p">The behavior of this view is driven completely by the view model.</blockquote><blockquote name="8ae5" id="8ae5" class="graf graf--blockquote graf-after--blockquote">This is one of the most important concepts to get right when doing MVVM,</blockquote><p name="8d59" id="8d59" class="graf graf--p graf-after--blockquote">If you look at vanilla SwiftUI, namely the big <strong class="markup--strong markup--p-strong">@State</strong> keywords.</p><p name="02bc" id="02bc" class="graf graf--p graf-after--p">Does it ever impress upon you that, maybe the behavior of a view is driven completely by those <strong class="markup--strong markup--p-strong">states</strong>? Otherwise it’s an <strong class="markup--strong markup--p-strong">IMMUTABLE VALUE TYPE</strong>?</p><p name="dd24" id="dd24" class="graf graf--p graf-after--p">No? Does it ever occur to you that maybe after a decade, we’ve learned something besides MVVM? Like reactive or functional programming.</p><p name="1ee6" id="1ee6" class="graf graf--p graf-after--p">No? Funny he also mentioned</p><blockquote name="a1b6" id="a1b6" class="graf graf--blockquote graf-after--p">The view controller, in other words, simply exists to pass things from point A to point B. Period.</blockquote><p name="1a9d" id="1a9d" class="graf graf--p graf-after--blockquote">Do you ever wonder, then why does it exist in the first place?</p><p name="7dbd" id="7dbd" class="graf graf--p graf-after--p">If you pass something from A to view controller, which passes it to B, then why don’t you just pass it to B?</p><p name="32bc" id="32bc" class="graf graf--p graf-after--p">From refactor point of view, it shouldn’t exist. You think SDK developers at Apple who got paid shit load of money have never heard of MVVM? Doesn’t know anything about refactor?</p><p name="2e76" id="2e76" class="graf graf--p graf-after--p">If you go into all these details, you will know why you don’t do design pattern for the sake of doing design pattern.</p><p name="8b52" id="8b52" class="graf graf--p graf-after--p">We are on uncharted territory. I’d even argue that there’s no view object in SwiftUI. Everything value type is model object used for different purpose. When it conforms to view, it can be used to render view. In UIKit, you have <code class="markup--code markup--p-code">UILabel</code> which has a property <code class="markup--code markup--p-code">text</code> . If all you do is <code class="markup--code markup--p-code">label.text = model.text</code> , as you’d do in binding, then it needs refactor.</p><p name="49fb" id="49fb" class="graf graf--p graf-after--p">Imagine now there’s no <code class="markup--code markup--p-code">label</code> , can you render view just from <code class="markup--code markup--p-code">model</code> ? SwiftUI is telling you that it can! You don’t even have <code class="markup--code markup--p-code">view</code> in your colorful diagram anymore! Uncharted territory!</p><p name="89a4" id="89a4" class="graf graf--p graf-after--p">There’s no view, there’s no view controller, and guess what? There’s no view model.</p><p name="90a1" id="90a1" class="graf graf--p graf-after--p graf--trailing">There is value type, there is reference type; there is local state, there is shared state. Then there’s some stuff from reactive or functional programming. This is the new (half a decade now…) world now.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/b95737209c4b"><time class="dt-published" datetime="2022-10-19T10:13:33.133Z">October 19, 2022</time></a>.</p><p><a href="https://medium.com/@swift2931/real-reasons-why-view-model-protocol-is-wrong-b95737209c4b" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>