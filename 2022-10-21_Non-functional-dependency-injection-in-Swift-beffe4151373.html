<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Non-functional dependency injection in Swift</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Non-functional dependency injection in Swift</h1>
</header>
<section data-field="subtitle" class="p-summary">
This is simply NOT how POP works
</section>
<section data-field="body" class="e-content">
<section name="bb2b" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="96f6" id="96f6" class="graf graf--h3 graf--leading graf--title">Non-functional dependency injection in Swift</h3><p name="aa32" id="aa32" class="graf graf--p graf-after--h3">This is simply NOT how POP works</p><figure name="3c88" id="3c88" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*jlfrc6oIfecURxsAla5gVw.jpeg" data-width="1280" data-height="720" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*jlfrc6oIfecURxsAla5gVw.jpeg"><figcaption class="imageCaption">Me watching “better programming”</figcaption></figure><blockquote name="5fd6" id="5fd6" class="graf graf--blockquote graf-after--figure">None of this is new, <strong class="markup--strong markup--blockquote-strong">it’s simply how Protocol-Oriented-Programming works</strong>.</blockquote><h4 name="12fa" id="12fa" class="graf graf--h4 graf-after--blockquote">It is SO NOT how POP works</h4><p name="9fcb" id="9fcb" class="graf graf--p graf-after--h4">Just saw this: <a href="https://betterprogramming.pub/factory-and-functional-dependency-injection-2d0a38042d05" data-href="https://betterprogramming.pub/factory-and-functional-dependency-injection-2d0a38042d05" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Functional Dependency Injection in Swift</a></p><p name="15f5" id="15f5" class="graf graf--p graf-after--p">POP does not require you to write a dumb shit protocol and a dumb shit object for <em class="markup--em markup--p-em">every </em>mock data. And what happens when you are not mocking, but doing something like <em class="markup--em markup--p-em">actual design work</em>?</p><p name="d442" id="d442" class="graf graf--p graf-after--p">Do you inject everything in your design so you can mock it more easily? At the cost of generalizing your design more than it has to? Which is more important? Production code design or mocking?</p><p name="5b45" id="5b45" class="graf graf--p graf-after--p">For MVVM devs, they think they can kill two birds with one stone; because they completely ignore the risk of over-generalization. I have another article for that. <a href="https://swift2931.medium.com/the-problems-with-mvvm-di-and-why-you-should-learn-refactor-instead-7255cfee5b31" data-href="https://swift2931.medium.com/the-problems-with-mvvm-di-and-why-you-should-learn-refactor-instead-7255cfee5b31" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">The problems with MVVM DI and why you should learn refactor instead.</a> I wonder where they get this idea POP = DI … maybe some influencer with 10K+ followers?</p><p name="9541" id="9541" class="graf graf--p graf-after--p">I have yet another article <a href="https://swift2931.medium.com/real-reasons-why-view-model-protocol-is-wrong-b95737209c4b" data-href="https://swift2931.medium.com/real-reasons-why-view-model-protocol-is-wrong-b95737209c4b" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Real reasons why view model protocol is wrong</a> in which I argue that this dude got POP wrong, mocking wrong, SwiftUI wrong, which just so happens to be around the same time he publishes this article.</p><p name="6b83" id="6b83" class="graf graf--p graf-after--p">So I won’t cover his usual mistakes in details here. I’m here to rant and meme some shit about his “mocking” approach, before he deletes my constructive criticism and blocks me.</p><h4 name="326e" id="326e" class="graf graf--h4 graf-after--p">If it talks like brute force, walks like brute force…</h4><figure name="f08b" id="f08b" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*AmbkUmk6_eH3NQ03iDWA9Q.jpeg" data-width="500" data-height="532" src="https://cdn-images-1.medium.com/max/800/1*AmbkUmk6_eH3NQ03iDWA9Q.jpeg"></figure><p name="07aa" id="07aa" class="graf graf--p graf-after--figure">That is so f-ing NOT how POP works. That is how lazy brute force works. There’s something called VARIABLE.</p><p name="9ee2" id="9ee2" class="graf graf--p graf-after--p">You assign mock data to some VARIABLE.</p><p name="cff6" id="cff6" class="graf graf--p graf-after--p">e.g.; <code class="markup--code markup--p-code">service.data = 100</code> , <code class="markup--code markup--p-code">service.data = 200</code></p><p name="26f9" id="26f9" class="graf graf--p graf-after--p">then you run some function that use that data and check expected results.</p><p name="a8a6" id="a8a6" class="graf graf--p graf-after--p">This is the masterful approach of MVVM DI complete with POP-TDD mocking:</p><ol class="postList"><li name="d31e" id="d31e" class="graf graf--li graf-after--p">Create a function that returns data <code class="markup--code markup--li-code">func load() -&gt; Int</code></li><li name="00db" id="00db" class="graf graf--li graf-after--li">Make a protocol about this function.</li></ol><pre name="9732" id="9732" class="graf graf--pre graf-after--li">protocol Mock {<br>    func load() -&gt; Int<br>}</pre><p name="f4b7" id="f4b7" class="graf graf--p graf-after--pre">3. Create an type that conforms to it.</p><p name="feac" id="feac" class="graf graf--p graf-after--p">4. Create an object of that type with implementation of</p><pre name="4751" id="4751" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">func load() -&gt; Int { return 100 }</code></pre><p name="f4be" id="f4be" class="graf graf--p graf-after--pre">5. Inject it to your design, which needs to be designed for injection in the fist place whether it is actually needed or not.</p><p name="eb83" id="eb83" class="graf graf--p graf-after--p">6. Now repeat step 1–5 it for <code class="markup--code markup--p-code">200</code></p><p name="5e1b" id="5e1b" class="graf graf--p graf-after--p">If at this point you are not thinking, “huh, this looks sketchy, maybe there’s a better way…”, you might be qualified to be a <em class="markup--em markup--p-em">better programming</em> contributor in iOS MVVM POP section.</p><p name="76c4" id="76c4" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">It is simply how POP works</em>, right?</p><figure name="2117" id="2117" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*8onzIkMTOaNMAY7b9dtqRg.gif" data-width="270" data-height="150" src="https://cdn-images-1.medium.com/max/800/1*8onzIkMTOaNMAY7b9dtqRg.gif"></figure><p name="0922" id="0922" class="graf graf--p graf-after--figure">Of course it is not how POP works. It’s not even how mocking works!</p><h4 name="289b" id="289b" class="graf graf--h4 graf-after--p">What is it are you testing?</h4><p name="a68a" id="a68a" class="graf graf--p graf-after--h4">Obviously this “design pattern” is worthless now. There’s no salvaging from lazy brute force with retroactive design changes to inject everything in production code. ON TOP OF USELESS VIEW MODEL INJECTION.</p><p name="078e" id="078e" class="graf graf--p graf-after--p">But wait, there’s more…</p><p name="8ad3" id="8ad3" class="graf graf--p graf-after--p">This is his test example</p><pre name="2a5d" id="2a5d" class="graf graf--pre graf-after--p">func testOpenFuctionality() throws {<br>    let mock = URLOpenningMock()<br>    Container.urlOpening.register { mock }<br>    let viewModel = MyViewModel()<br>    viewModel.open(site: &quot;<a href="https://google.com/" data-href="https://google.com/" class="markup--anchor markup--pre-anchor" rel="noopener ugc nofollow noopener" target="_blank">https://google.com</a>&quot;)<br>    XCTAssert(mock.openedURL != nil)<br>}</pre><p name="1d38" id="1d38" class="graf graf--p graf-after--pre">And this is the mock he injected:</p><pre name="69ec" id="69ec" class="graf graf--pre graf-after--p">class URLOpenningMock: URLOpening {<br>    var openedURL: URL?<br>    func openURL(_ url: URL) -&gt; Bool {<br>        openedURL = url<br>        return false<br>    }<br>}</pre><p name="5d44" id="5d44" class="graf graf--p graf-after--pre">to mock <code class="markup--code markup--p-code">UIApplication.shared.openURL</code> .</p><p name="1b41" id="1b41" class="graf graf--p graf-after--p">But what is it is he testing? The function <code class="markup--code markup--p-code">openURL</code> ?</p><p name="ebef" id="ebef" class="graf graf--p graf-after--p">First testing SDK function <code class="markup--code markup--p-code">UIApplication.shared.openURL</code>is not your job.</p><p name="7b1d" id="7b1d" class="graf graf--p graf-after--p">Second, he swapped it out! So he is testing the function he just mocked!</p><p name="216e" id="216e" class="graf graf--p graf-after--p">Test to see if the function you purposefully created is really the function you purposefully created? Of course <code class="markup--code markup--p-code">openedURL</code> wont be <code class="markup--code markup--p-code">nil</code> because the function parameter <code class="markup--code markup--p-code">_ url: URL</code> is not optional type! WTF are you testing!</p><p name="a3d7" id="a3d7" class="graf graf--p graf-after--p">It doesn’t look like he is testing the callback or side effects from calling <code class="markup--code markup--p-code">UIApplication.shared.openURL</code> either.</p><p name="52ad" id="52ad" class="graf graf--p graf-after--p">I might be wrong, but I don’t see what this test is supposed to accomplish. The only way <code class="markup--code markup--p-code">openedURL</code> can be nil is that his “Factory” library failed. But that is testing his library, not testing the thing you want to actually test!</p><p name="2930" id="2930" class="graf graf--p graf-after--p">If I’m not wrong, that is some epic fail.</p><h4 name="72e3" id="72e3" class="graf graf--h4 graf-after--p">Non-functional injection</h4><blockquote name="14cf" id="14cf" class="graf graf--blockquote graf-after--h4">We went to <strong class="markup--strong markup--blockquote-strong">a lot of trouble</strong> in order to create a protocol for a service that provided a single function. Which, on consideration, could lead us to ask a couple of simple questions:</blockquote><blockquote name="9328" id="9328" class="graf graf--blockquote graf-after--blockquote">Do we really need the service container?</blockquote><blockquote name="36b5" id="36b5" class="graf graf--blockquote graf-after--blockquote">Could we just inject the <em class="markup--em markup--blockquote-em">functionality</em> where it’s needed?</blockquote><p name="0f7e" id="0f7e" class="graf graf--p graf-after--blockquote">No, the question you ought to be asking is wtf you went to <em class="markup--em markup--p-em">a lot of trouble</em> in the first place.</p><p name="f0bf" id="f0bf" class="graf graf--p graf-after--p">Then you need to ask wtf are you testing? Because it ain’t working!</p><p name="7368" id="7368" class="graf graf--p graf-after--p">He went on about needing some refactor / syntax sugar so this process won’t appear as tedious as it is.</p><p name="18db" id="18db" class="graf graf--p graf-after--p">So his genius idea is to inject function directly without protocol and mock object. No shit, but that doesn’t change the fact that you may swap out the function you actually want to test, and instead test the mock function, or even the library itself.</p><p name="0c4b" id="0c4b" class="graf graf--p graf-after--p">But wait, can function be used as VARIABLE? Yeah, closure.</p><p name="259d" id="259d" class="graf graf--p graf-after--p">Since your design is dog shit at this point, with everything being injected, the logical course of action is to use closure as variables.</p><p name="7c5e" id="7c5e" class="graf graf--p graf-after--p">E.g.; <code class="markup--code markup--p-code">service.func1 = { return 100 }</code> , <code class="markup--code markup--p-code">service.func2 = { return 200 }</code> .</p><p name="e297" id="e297" class="graf graf--p graf-after--p">Oh, now this is too<em class="markup--em markup--p-em"> brute force</em>? @Injected is a better design?</p><p name="35ef" id="35ef" class="graf graf--p graf-after--p">Let’s examine his library then.</p><h4 name="1324" id="1324" class="graf graf--h4 graf-after--p">Global-abusing factory</h4><p name="788b" id="788b" class="graf graf--p graf-after--h4">His example @Injected usage</p><pre name="8c96" id="8c96" class="graf graf--pre graf-after--p">class MyViewModel: View {<br>    @Injected(Container.openURL) private var openURL<br>    func open(site: String) {<br>        _ = openURL(URL(string: site)!)<br>    }<br>}</pre><p name="fe2b" id="fe2b" class="graf graf--p graf-after--pre">First, force unwrap with <code class="markup--code markup--p-code">URL(string: site)!</code> is dangerous. You don’t know where that <code class="markup--code markup--p-code">string</code> comes from. I assume it’s validated somewhere prior.</p><p name="78ab" id="78ab" class="graf graf--p graf-after--p">You should tell straight away that he puts function closure in singleton. <code class="markup--code markup--p-code">Container.opernURL</code> . Not only did he use closure, he used singleton too!</p><p name="28c3" id="28c3" class="graf graf--p graf-after--p">Doesn’t matter how fancy he used generics in implementing his Factory library, because it doesn’t change the fact that it is essentially just asking you to put function closures in a singleton. You think I couldn’t do that myself?</p><pre name="9f82" id="9f82" class="graf graf--pre graf-after--p">private var openURL = Container.openURL</pre><p name="843c" id="843c" class="graf graf--p graf-after--pre">Do I need some f-ing f<em class="markup--em markup--p-em">unctional dependency injection</em>?</p><p name="1e72" id="1e72" class="graf graf--p graf-after--p">But somehow this is<em class="markup--em markup--p-em"> not brute force</em>? Oh I guess you are right. This is <strong class="markup--strong markup--p-strong">retarded brute force</strong>. Because you are now abusing singleton too.</p><p name="4a35" id="4a35" class="graf graf--p graf-after--p">Any-F-ING-body can change it at runtime anywhere in code. Your design should not have runtime properties when the design doesn’t need it. You don’t use it because it’s more convenient for you to … preview? You shoot your design in the foot by retroactively changing it for some mocking?</p><p name="1c73" id="1c73" class="graf graf--p graf-after--p">Get your priority straight. Good design first if there’s a trade off.</p><p name="b121" id="b121" class="graf graf--p graf-after--p">Another example is his network mocking.</p><pre name="ec0b" id="ec0b" class="graf graf--pre graf-after--p">typealias AccountProviding = () async throws -&gt; [Account]extension Container {<br>    static let accountProvider = Factory&lt;AccountProviding&gt; {<br>        { try await Network.get(path: &quot;/accounts&quot;) }<br>    }<br>}</pre><p name="0dd3" id="0dd3" class="graf graf--p graf-after--pre">Again, what is it that he is testing? You use function closure so this production code will be<em class="markup--em markup--p-em"> swapped out</em>. So the one thing you are not testing is <code class="markup--code markup--p-code">Network.get(...)</code> .</p><p name="b3c0" id="b3c0" class="graf graf--p graf-after--p">If the mock data is <code class="markup--code markup--p-code">&quot;/accounts&quot;</code> , use <strong class="markup--strong markup--p-strong">VARIABLE</strong>.</p><p name="e4f6" id="e4f6" class="graf graf--p graf-after--p">E.g.; <code class="markup--code markup--p-code">network.get(path1)</code> , <code class="markup--code markup--p-code">network.get(path2)</code> , then check your shit.</p><p name="b358" id="b358" class="graf graf--p graf-after--p">You don’t need no F-ing SINGLETON for that!</p><p name="a629" id="a629" class="graf graf--p graf-after--p">Not to mention <code class="markup--code markup--p-code">Network</code> should be something you can unit test however you want because it’s a reference type, and test individually independent of view or preview.</p><p name="86ff" id="86ff" class="graf graf--p graf-after--p">His another problem is his insistency to use preview like a unit test. Those two run on completely different contexts. You can add whatever mock data / utilities in unit test target, without polluting production code.</p><p name="942f" id="942f" class="graf graf--p graf-after--p">By using preview as a unit test, not only did he have to use singleton which degrades his design, he had to introduce mock data to production codes. You use preview to check if your view is correct with respect to view states; whether they are correct view states isn’t exactly the focus. There’s unit test for that.</p><p name="259c" id="259c" class="graf graf--p graf-after--p">The idea of SwiftUI is that view is determined by view states. Whatever side effects that alter view states will trigger view updates. <strong class="markup--strong markup--p-strong">The purpose of mocking in preview is to mock view states</strong>. Not mock all kinds of input. You should focus on identifying view states first. But you can’t since you will be too busy creating boilerplates like view model, singleton, mock data, mock protocols, mock objects… etc.</p><p name="f2bf" id="f2bf" class="graf graf--p graf-after--p">That is not to say you can’t have mock data for preview. But use it in a measured, highly refactored, and efficient way. Not brute force going through singleton properties.</p><h4 name="e118" id="e118" class="graf graf--h4 graf-after--p">rant.onFinished() { … in }</h4><p name="3113" id="3113" class="graf graf--p graf-after--h4">His conclusion is that</p><blockquote name="4444" id="4444" class="graf graf--blockquote graf-after--p">I think the <strong class="markup--strong markup--blockquote-strong">biggest win</strong> with this technique lies not with standard application functionality, but <strong class="markup--strong markup--blockquote-strong">with the ease </strong>in which we can now <em class="markup--em markup--blockquote-em">test</em> that functionality.</blockquote><p name="728a" id="728a" class="graf graf--p graf-after--blockquote">About that….</p><figure name="7328" id="7328" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*s-q71JGB98KDwax5vX06yw.png" data-width="680" data-height="450" src="https://cdn-images-1.medium.com/max/800/1*s-q71JGB98KDwax5vX06yw.png"></figure><blockquote name="4012" id="4012" class="graf graf--blockquote graf-after--figure">You’ve seen how we can <strong class="markup--strong markup--blockquote-strong">simply </strong>provide our <strong class="markup--strong markup--blockquote-strong">view model</strong> with a <strong class="markup--strong markup--blockquote-strong">new function </strong>that returns the edge case or error we need, <strong class="markup--strong markup--blockquote-strong">without a defined protocol</strong> and <strong class="markup--strong markup--blockquote-strong">without the need to create a new stub or mock service</strong> that conforms to that protocol.</blockquote><p name="b8a4" id="b8a4" class="graf graf--p graf-after--blockquote">He is almost there. Almost figuring out what refactor is.</p><blockquote name="5633" id="5633" class="graf graf--blockquote graf-after--p">But for simple services and dependencies, functional injection might be just the ticket.</blockquote><p name="34ea" id="34ea" class="graf graf--p graf-after--blockquote">What he actually meant is to use variable closures in singleton(s) filled with mock data while shooting your design in the foot.</p><blockquote name="b583" id="b583" class="graf graf--blockquote graf-after--p">So what do you think? Going to try this in your code?</blockquote><p name="da98" id="da98" class="graf graf--p graf-after--blockquote">For the love of God. <strong class="markup--strong markup--p-strong">Do not try this in your code.</strong></p><p name="1967" id="1967" class="graf graf--p graf-after--p">I’m writing this so people can avoid this retardation-trap. I can’t save everyone, but I’ll take solace even if just one person is saved from this horror.</p><p name="9ff1" id="9ff1" class="graf graf--p graf-after--p graf--trailing">I don’t claim to be an expert in TDD mocking in SwiftUI. But do I use anything more than basic programming sense? Make your own judgement to determine if I’m right.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/beffe4151373"><time class="dt-published" datetime="2022-10-21T05:55:22.386Z">October 21, 2022</time></a>.</p><p><a href="https://medium.com/@swift2931/non-functional-dependency-injection-in-swift-beffe4151373" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>