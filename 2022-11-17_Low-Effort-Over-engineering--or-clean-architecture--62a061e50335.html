<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Low Effort Over-engineering, or clean architecture?</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Low Effort Over-engineering, or clean architecture?</h1>
</header>
<section data-field="subtitle" class="p-summary">
Criteria to identify a LEO
</section>
<section data-field="body" class="e-content">
<section name="8dfa" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="5ff1" id="5ff1" class="graf graf--h3 graf--leading graf--title">Low Effort Over-engineering, or clean architecture?</h3><p name="7a01" id="7a01" class="graf graf--p graf-after--h3">Criteria to identify a LEO</p><blockquote name="02cb" id="02cb" class="graf graf--pullquote graf-after--p">Any architecture who must say, “I am clean”, is no true clean. — Tywin Lannister</blockquote><figure name="8d87" id="8d87" class="graf graf--figure graf-after--pullquote"><img class="graf-image" data-image-id="1*6aAHqYhH1p1Tdsclw6ItZA.png" data-width="697" data-height="589" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*6aAHqYhH1p1Tdsclw6ItZA.png"><figcaption class="imageCaption">From Game of Thrones</figcaption></figure><h4 name="a394" id="a394" class="graf graf--h4 graf-after--figure">Liskov Substitution Principle</h4><blockquote name="afc7" id="afc7" class="graf graf--blockquote graf-after--h4">99% of the things you want to do with inheritance can be done with composition so you should always <strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">favor</em> <em class="markup--em markup--blockquote-em">composition over inheritance</em></strong>.</blockquote><p name="e327" id="e327" class="graf graf--p graf-after--blockquote">This quote is from <a href="https://betterprogramming.pub/the-real-clean-architecture-in-android-part-1-s-o-l-i-d-6a661b103451" data-href="https://betterprogramming.pub/the-real-clean-architecture-in-android-part-1-s-o-l-i-d-6a661b103451" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">The “Real” Clean Architecture in Android: S.O.L.I.D.</a></p><p name="a097" id="a097" class="graf graf--p graf-after--p">If even our Android friends know the significance of composition, you would expect iOS devs to have mastered it; since Swift is the first POP language, and we have unique value type which cannot be inherited at all.</p><p name="ecff" id="ecff" class="graf graf--p graf-after--p">Protocol composition should be 99% of the things you do instead of inheritance… right?</p><p name="32f7" id="32f7" class="graf graf--p graf-after--p">This is <a href="https://paulallies.medium.com/clean-architecture-ios-app-100539550110" data-href="https://paulallies.medium.com/clean-architecture-ios-app-100539550110" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">the top search result for “clean architecture ios”</a> that I see right now.</p><p name="e3f5" id="e3f5" class="graf graf--p graf-after--p">There’s 0 mention of composition. 0 protocol extension. 0 comparison to basic SDK. Hell, it even has 0 inheritance. 0 argument why it is clean. It is clean because it says it is.</p><p name="d33b" id="d33b" class="graf graf--p graf-after--p">Funny thing is, our Android friend didn’t say how this 99% composition over inheritance is done. His only example is… inheritance.</p><p name="e630" id="e630" class="graf graf--p graf-after--p">Then he got 1.4K upvote with a fan boy like this:</p><figure name="da63" id="da63" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*WdBQOBsRlLv4R8nl9JmMfA.png" data-width="352" data-height="66" src="https://cdn-images-1.medium.com/max/800/1*WdBQOBsRlLv4R8nl9JmMfA.png"></figure><p name="5f2b" id="5f2b" class="graf graf--p graf-after--figure">This fan boy can confirm that it is correct even without any composition example. So the people who claimed to have figured it out don’t present any example, and the people who should have figured it out with plenty examples don’t seem to know this principle, yet claimed to be clean anyway.</p><p name="cdd2" id="cdd2" class="graf graf--p graf-after--p">How do you know your “clean” architecture is really clean? Best way of course is to compare it with basic SDK and make arguments. I challenge you to find any tutorial that does this comparison.</p><p name="5fa2" id="5fa2" class="graf graf--p graf-after--p">LEO criteria #1: where’s composition?</p><p name="d58b" id="d58b" class="graf graf--p graf-after--p">LEO criteria #2: where’s comparison?</p><h4 name="c323" id="c323" class="graf graf--h4 graf-after--p">ISP + DIP = Over-generalizaton</h4><blockquote name="3a4b" id="3a4b" class="graf graf--blockquote graf-after--h4">ISP: Abstractions should be as small as possible</blockquote><blockquote name="c7fa" id="c7fa" class="graf graf--blockquote graf-after--blockquote">DIP: Collaborators should be abstractions</blockquote><p name="3170" id="3170" class="graf graf--p graf-after--blockquote">Again, quoting from our Android friend.</p><p name="d5d6" id="d5d6" class="graf graf--p graf-after--p">In practice this becomes:</p><ol class="postList"><li name="b729" id="b729" class="graf graf--li graf-after--p">Abstract everything</li><li name="50b9" id="50b9" class="graf graf--li graf-after--li">One protocol for one function</li></ol><p name="5bc4" id="5bc4" class="graf graf--p graf-after--li">As he showed in his example:</p><figure name="8205" id="8205" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*PAIGAlA8dGWUX-SKK9C_Qw.png" data-width="711" data-height="340" src="https://cdn-images-1.medium.com/max/800/1*PAIGAlA8dGWUX-SKK9C_Qw.png"></figure><p name="7907" id="7907" class="graf graf--p graf-after--figure">This will absolutely NOT scale. This will absolutely create boilerplate.</p><p name="e5c3" id="e5c3" class="graf graf--p graf-after--p">I love how people keep referencing some book about clean architecture.</p><p name="4a0c" id="4a0c" class="graf graf--p graf-after--p">Does that book tell you how NOT to write boilerplate?</p><p name="3f20" id="3f20" class="graf graf--p graf-after--p">Does that book tell you how to refactor in language-specific examples?</p><p name="4cfe" id="4cfe" class="graf graf--p graf-after--p">Does that book tell you code-as-document is nice to have, but don’t sacrifice refactor quality just to look clean?</p><p name="5b61" id="5b61" class="graf graf--p graf-after--p">If answers are all no. I want you to shove the book up your ass, for that book is worthless.</p><p name="343c" id="343c" class="graf graf--p graf-after--p">If answers are all yes. I want you to shove the book up your ass, for that you clearly failed at implementation.</p><p name="496f" id="496f" class="graf graf--p graf-after--p">If you happen to be iOS dev who is “good” at POP , the lack of protocol extension should trigger you. The poorly designed protocol should anger you. (if you need to ask why then you are not good at POP)</p><p name="e0e9" id="e0e9" class="graf graf--p graf-after--p">This is over- FING- generalization.</p><p name="bb38" id="bb38" class="graf graf--p graf-after--p">LEO criteria #3: abstract things that don’t need abstraction, abstraction as small as possible because some principle or some book.</p><p name="84ef" id="84ef" class="graf graf--p graf-after--p">Assuming protocol composition, you would have</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="3fde" id="3fde" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Service</span>: <span class="hljs-title class_">LoginInteractor</span>, <span class="hljs-title class_">LogoutInteractor</span> {<span class="hljs-operator">...</span>}<br /><span class="hljs-comment">// can&#x27;t have CreateAccountInteractor because same function signature</span></span></pre><p name="b63c" id="b63c" class="graf graf--p graf-after--pre">Then you have to implement requirement from scratch. These protocols tell you jackshit. Why do you design something that has 0 reusability?</p><p name="bc17" id="bc17" class="graf graf--p graf-after--p">Take <code class="markup--code markup--p-code">UIViewController</code> for example. People like to shit on it. Calling it massive. Yet it gives you <em class="markup--em markup--p-em">default implementation</em> via inheritance. <code class="markup--code markup--p-code">viewDidLoad()</code> may do nothing, but it doesn’t require mandadory implementation either. And given that it is SDK, everything is well documented and once you are familiar with it, you know what you should do every time.</p><p name="3eff" id="3eff" class="graf graf--p graf-after--p">Your custom protocol, on the other hand, does not enjoy these luxuries. Wtf am I supposed to implement in<code class="markup--code markup--p-code">execute()?</code> <em class="markup--em markup--p-em">Execute login</em>, of course…</p><p name="e010" id="e010" class="graf graf--p graf-after--p">That is f-ing low effort. Of course I know I need a login from spec. So I’ll do my shit with login, then abstract it out to conform to your protocol knowing you’ll call it as a protocol object in abstraction. That is not <em class="markup--em markup--p-em">protocol-oriented</em>. That is <em class="markup--em markup--p-em">protocol-later</em>. We each implement our version of login with nothing being reused; when login is often a process that can be reused with minor changes.</p><p name="62c2" id="62c2" class="graf graf--p graf-after--p">Basic refactor. Are you telling me <em class="markup--em markup--p-em">clean </em>architecture fails at basic refactor?</p><p name="55e2" id="55e2" class="graf graf--p graf-after--p">LEO criteria #4: does it drop inheritance becasue Swift is supposed to be POP but it does not have protocol extension, resulting almost 0 reusability?</p><p name="c46d" id="c46d" class="graf graf--p graf-after--p">This is why design pattern should be the <em class="markup--em markup--p-em">result </em>of refactor. Not the other way around.</p><p name="7268" id="7268" class="graf graf--p graf-after--p">When you design a refactor, you need to consider <em class="markup--em markup--p-em">context</em>: caller, callee, SDK, task at hand, language feature, runtime envrionment … etc. When you do clean architecture on paper in a vaccum based on abstract principles from some book written over a decade ago that think in a different language, you don’t have <em class="markup--em markup--p-em">context</em>. So you will write useless boilerplate. Then you will say it is not useless boilerplate because it makes you look like hello world level 1 instead of lead developer, then you will find some excuses like “it will be useful in large projects” without any shred of evidence or comparison.</p><figure name="0dc9" id="0dc9" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*zYunTLW-LUQMZvxTpqb_JQ.png" data-width="502" data-height="268" src="https://cdn-images-1.medium.com/max/800/1*zYunTLW-LUQMZvxTpqb_JQ.png"></figure><p name="6cc1" id="6cc1" class="graf graf--p graf-after--figure">Speaking of which, there are other vanity factors at play.</p><h4 name="6cd2" id="6cd2" class="graf graf--h4 graf-after--p">Clean makes you write dumb shit</h4><p name="59e9" id="59e9" class="graf graf--p graf-after--h4">Because you are under pressure to write something <em class="markup--em markup--p-em">clean</em>.</p><p name="51d6" id="51d6" class="graf graf--p graf-after--p">Say you want to do <code class="markup--code markup--p-code">a+b</code> .</p><p name="8fcc" id="8fcc" class="graf graf--p graf-after--p">I want you to write <em class="markup--em markup--p-em">clean </em><code class="markup--code markup--p-code">a+b.</code></p><p name="48b5" id="48b5" class="graf graf--p graf-after--p">Then you might produce:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="1154" id="1154" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">AdditionInteractorProtocol</span> { <span class="hljs-keyword">func</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">b</span>: <span class="hljs-type">Int</span>) }<br /><br /><span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewModel</span> { <span class="hljs-keyword">init</span>(<span class="hljs-params">adder</span>: <span class="hljs-type">AdditionInteractorProtocol</span>) {<span class="hljs-operator">...</span>} }</span></pre><p name="32c7" id="32c7" class="graf graf--p graf-after--pre">Everything except default implementation <code class="markup--code markup--p-code">a + b.</code></p><p name="358f" id="358f" class="graf graf--p graf-after--p">Clean f-ing architecture. Oh sorry, I mean LEO.</p><p name="34df" id="34df" class="graf graf--p graf-after--p">LEO criteria #5: those who write <code class="markup--code markup--p-code">protocol SomethingSomethingProtocol.</code></p><p name="2ec1" id="2ec1" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">Protocol</code> can be easily inferred. These are 7 characters you can replace with more useful description.</p><p name="d8bd" id="d8bd" class="graf graf--p graf-after--p">Funny thing is, not every MVVM writes dumb shit. But every dumb shit will use MVVM. I don’t have scientific proof, just my observation.</p><p name="c98e" id="c98e" class="graf graf--p graf-after--p">Nothing in clean architecture says MVVM; and even MVVM will say there are alternatives besides MVVM. But the go-to design pattern to make your code look good is to have a view model, even when it is supposed to be <em class="markup--em markup--p-em">clean </em>architecture on its own rights.</p><p name="36a5" id="36a5" class="graf graf--p graf-after--p">So they will plug-in a view model like it’s a natural scientific-proven fact. What is the SRP (single responsibility) of a view model, might I ask? It can change whenever any one of <em class="markup--em markup--p-em">dependency inversions</em> changes. And what happened to binding? How does that fit into clean architecture?</p><p name="b06e" id="b06e" class="graf graf--p graf-after--p">Oh, and <em class="markup--em markup--p-em">dependency inversions </em>are not <strong class="markup--strong markup--p-strong">protocol compositions</strong>.</p><p name="bab7" id="bab7" class="graf graf--p graf-after--p">LEO criteria#6: there’s MVVM. Because MVVM itself is a LEO unless you can solve binding. It is low effort because everyone and their mother will create a view model under any circumstances; it is over-engineering because it will abuse DI, avoid inheritance, ignore protocol composition.</p><p name="4ebd" id="4ebd" class="graf graf--p graf-after--p">Now you probably need some examples since I make <em class="markup--em markup--p-em">clean </em>architecture look like a LEO.</p><h4 name="360d" id="360d" class="graf graf--h4 graf-after--p">LEO criteria#7</h4><figure name="abf7" id="abf7" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*qLh6_cRWnPnYdEF9dmad9g.png" data-width="652" data-height="666" src="https://cdn-images-1.medium.com/max/800/1*qLh6_cRWnPnYdEF9dmad9g.png"></figure><p name="88d4" id="88d4" class="graf graf--p graf-after--figure">I&#39;ll tell you what I’m going to do to refactor this.</p><p name="a31b" id="a31b" class="graf graf--p graf-after--p">Assuming SwiftUI, remove all view models.</p><p name="2889" id="2889" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">ContactRepositoryImpl</code> is such a Java shit I’ll remove it. Use default implementation via protocol extension.</p><p name="16dd" id="16dd" class="graf graf--p graf-after--p">UseCases are such dumb shit. Nothing in clean architecture says you need a type for everything. Keeping protocol so small as to one function is idiotic. You will just create so many one-off one function protocol types that make everything including readability (swift local reasoning) more difficult.</p><p name="0ba8" id="0ba8" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">CreateContactUseCaseProtocol</code> is such a bloated, redundant naming. You can infer use cases from folder name, protocol from declaration or placement, contact is repeated multiple times after explicit folder name.</p><p name="5a2e" id="5a2e" class="graf graf--p graf-after--p">LEO criteria#7: write redundant / repetitive shit, and think it is <em class="markup--em markup--p-em">clean</em>.</p><p name="45b6" id="45b6" class="graf graf--p graf-after--p">I won’t f-ing waste time creating these shit. Check this out instead:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="d22e" id="d22e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">ContactList</span> {<br />    <span class="hljs-comment">// properties requirement</span><br />}<br /><span class="hljs-keyword">extension</span> <span class="hljs-title class_">ContactList</span> {<br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">create</span>(<span class="hljs-operator">...</span>) {<span class="hljs-operator">...</span>}<br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">update</span>(<span class="hljs-operator">...</span>) {<span class="hljs-operator">...</span>}<br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">delete</span>(<span class="hljs-operator">...</span>) {<span class="hljs-operator">...</span>}<br />    <span class="hljs-operator">...</span> <br />} <span class="hljs-comment">// with default implementation right here!!!</span></span></pre><p name="c7ee" id="c7ee" class="graf graf--p graf-after--pre">One protocol. One file. Local reasoning. Default implementation. Statndard POP. Grouping relevant operations together.</p><p name="898a" id="898a" class="graf graf--p graf-after--p">Do I bother with dependency inversion? Won’t need it most of the time. This dude has so many dependencies that he requires third party library swinject for runtime <em class="markup--em markup--p-em">dependency resolve</em>. <em class="markup--em markup--p-em">Clean </em>architecture? By relying on swinject that abuses singleton? <em class="markup--em markup--p-em">Clean </em>architecture? You don’t even know your type at runtime in such basic example.</p><p name="f379" id="f379" class="graf graf--p graf-after--p">What about test?</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="0912" id="0912" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><br /><span class="hljs-keyword">class</span> <span class="hljs-title class_">MockContactList</span>: <span class="hljs-title class_">ContactList</span> {<br />    <span class="hljs-keyword">var</span> data <span class="hljs-operator">=</span> [<span class="hljs-type">Contact</span>](<span class="hljs-operator">...</span>) <span class="hljs-comment">// mock data</span><br />    <span class="hljs-operator">...</span><br />    <span class="hljs-comment">// override some function if needed</span><br />}<br /><br /><span class="hljs-keyword">func</span> <span class="hljs-title function_">testCreateContact</span>() {<br />    <span class="hljs-keyword">let</span> mock <span class="hljs-operator">=</span> <span class="hljs-type">MockContactList</span>()<br />    mock.data <span class="hljs-operator">=</span> <span class="hljs-operator">...</span> <br />    mock.create(<span class="hljs-operator">...</span>)<br />    <span class="hljs-comment">// assertions </span><br />}<br />    </span></pre><p name="68ff" id="68ff" class="graf graf--p graf-after--pre">One protocol. One file. Local reasoning. Default implementation.</p><p name="bb4b" id="bb4b" class="graf graf--p graf-after--p">Flat structure, no injection (preferably).</p><p name="459f" id="459f" class="graf graf--p graf-after--p">This is… just basic.</p><p name="90d6" id="90d6" class="graf graf--p graf-after--p">Is the purpose of clean architecture to make things more complex? By abusing unnecessary abstractions?</p><p name="ff9e" id="ff9e" class="graf graf--p graf-after--p">Oh btw, I still have bindings despite of removing all view models. Because the model you use in in @ObservableObject can be moved into <code class="markup--code markup--p-code">struct Model: View {...}</code> without changes. You have binding from @State. So whatever benefits you think you have, I have too without even bothering to create an external observable.</p><p name="b93a" id="b93a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">LEO criteria#8: does it make things simpler?</strong></p><p name="bda6" id="bda6" class="graf graf--p graf-after--p">To wrap up, I’ll comment on some of the notable points from various sources.</p><h4 name="cf7b" id="cf7b" class="graf graf--h4 graf--startsWithDoubleQuote graf-after--p">“A Lion Doesn’t Concern Himself With The Opinions Of The Sheep”</h4><p name="094a" id="094a" class="graf graf--p graf-after--h4">First from our Android friend:</p><p name="ad33" id="ad33" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">After all, which class do you think is more likely to break the SRP?<br>A class with a single method or a class with 100 methods?</em></p><p name="d932" id="d932" class="graf graf--p graf-after--p">This is over-simplification. That single method can be polymorphism or closure. SRP itself is … vague. There are many ways to argue whether it belongs to one <em class="markup--em markup--p-em">actor </em>or not<em class="markup--em markup--p-em">,</em> which is another vague definition.</p><p name="0bd8" id="0bd8" class="graf graf--p graf-after--p">If you are spliting protocols to many smaller ones just for the number to be smaller, that is not really a refactor reason. It <em class="markup--em markup--p-em">looks </em>cleaner. Remember #5 and vanity?</p><blockquote name="8f4d" id="8f4d" class="graf graf--blockquote graf-after--p">Don’t force users of a component to depend on things they don’t need.</blockquote><p name="d168" id="d168" class="graf graf--p graf-after--blockquote">Same reasoning. Don’t add abstractions you don’t need. Generalization loses you information. The hardest part of a design often is not generalization; is how to avoid generalization, and let Swift type system carry you.</p><p name="cb63" id="cb63" class="graf graf--p graf-after--p">Next up, <a href="https://bpoplauschi.github.io/2021/09/21/Clean-Architecture-on-iOS.html" data-href="https://bpoplauschi.github.io/2021/09/21/Clean-Architecture-on-iOS.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Clean Architecture on iOS</a>.</p><p name="e1a5" id="e1a5" class="graf graf--p graf-after--p">It highlights <em class="markup--em markup--p-em">composition over inheritance, </em>but only showed very basics. DIP on the other hand has a more practical example. You might get the impression that clean architecture is leaning heavily towards DIP from this. But in practice, as mentioned before, if you are not doing inheritance, all you do is protocol extension. Take network service, which is the most commonly used, for example. Never need to inject one, because there’s never a reason to swap out for another one. Endpoints can be designed to accept parameters. Like I said, the hard part is to avoid generalization so Swift type system can better help you knowing the exact type.</p><p name="b7aa" id="b7aa" class="graf graf--p graf-after--p">Protocol design, while having some extension, is not very useful, and too fine-grained. Same problem we’ve seen in Android example.</p><figure name="9c3c" id="9c3c" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*0vJsP1o-O0H2oOLGSz2jWQ.png" data-width="492" data-height="404" src="https://cdn-images-1.medium.com/max/800/1*0vJsP1o-O0H2oOLGSz2jWQ.png"><figcaption class="imageCaption">It becomes just a wrapper</figcaption></figure><p name="fdb8" id="fdb8" class="graf graf--p graf-after--figure">Note that he didn’t mention MVVM until the last bit. I want to hightlight the observation that articles that ignore MVVM tend to make fewer dumb mistakes.</p><p name="6ce7" id="6ce7" class="graf graf--p graf-after--p">Finally, let’s look at a GO example, which is used for backend.</p><p name="cc8e" id="cc8e" class="graf graf--p graf-after--p"><a href="https://medium.com/gdg-vit/clean-architecture-the-right-way-d83b81ecac6" data-href="https://medium.com/gdg-vit/clean-architecture-the-right-way-d83b81ecac6" class="markup--anchor markup--p-anchor" target="_blank">Clean Architecture, the right way</a>.</p><p name="1c64" id="1c64" class="graf graf--p graf-after--p">I won’t go into GO details, since I don’t ever write GO. I only want to show two things:</p><figure name="f62f" id="f62f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*wVTfrFOoWp-AvU56GTGhug.png" data-width="422" data-height="615" src="https://cdn-images-1.medium.com/max/800/1*wVTfrFOoWp-AvU56GTGhug.png"></figure><p name="d8b3" id="d8b3" class="graf graf--p graf-after--figure">This looks clean, even if the title doesn’t say clean-architecture-examlple. Backend probably doesn’t need to worry about UI, so it simplifies things. No obvious redundancy or repetition.</p><p name="18bc" id="18bc" class="graf graf--p graf-after--p">Then it defines a Service interface and inject it to various places. This could work because it is basically just DI. Even if you don’t know anything about clean architecture, you’d do this anyway as a basic refactor. Note that its Service interface contains several functions:</p><figure name="e9d1" id="e9d1" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*OyW13B9jVznMndUv_mItdA.png" data-width="618" data-height="349" src="https://cdn-images-1.medium.com/max/800/1*OyW13B9jVznMndUv_mItdA.png"></figure><p name="0f5d" id="0f5d" class="graf graf--p graf-after--figure">As far as protocol design goes, this makes most sense in all the examples we’ve seen. Of course you would group relevant functions together as a unit. This is the foundation of POP. I don’t think he bothers worrying about composition or inheritance as far as I can tell. That’s probably why it’s simple but effective. It does injection, and does it right.</p><h4 name="b815" id="b815" class="graf graf--h4 graf-after--p">The lord of POP</h4><p name="6c09" id="6c09" class="graf graf--p graf-after--h4">Back to iOS. How come devs working with a POP language design worse protocols than… GO?</p><p name="fff7" id="fff7" class="graf graf--p graf-after--p">We should be lords of POP. Yet the top result is a LEO. I didn’t bother checking those blocked by paywall, so my sample is limited. But it’d be funny to pay month subscription to see devs at better programming writing even dumber shit.</p><p name="e2fd" id="e2fd" class="graf graf--p graf-after--p graf--trailing">Anyway, I hope this can help you identify LEO and learn something about what makes a <em class="markup--em markup--p-em">clean </em>architecture clean.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/62a061e50335"><time class="dt-published" datetime="2022-11-17T18:53:38.456Z">November 17, 2022</time></a>.</p><p><a href="https://medium.com/@swift2931/low-effort-over-engineering-or-clean-architecture-62a061e50335" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>