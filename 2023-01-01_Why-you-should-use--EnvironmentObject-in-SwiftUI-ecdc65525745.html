<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Why you should use @EnvironmentObject in SwiftUI</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Why you should use @EnvironmentObject in SwiftUI</h1>
</header>
<section data-field="subtitle" class="p-summary">
Shortcomings of dependency injection mechanism
</section>
<section data-field="body" class="e-content">
<section name="e322" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="4e40" id="4e40" class="graf graf--h3 graf--leading graf--title">Why you should use @EnvironmentObject in SwiftUI</h3><p name="622b" id="622b" class="graf graf--p graf-after--h3">Shortcomings of dependency injection mechanism</p><figure name="4fd7" id="4fd7" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Yiy3WabLW8rSN8Sk6DPVDQ.png" data-width="837" data-height="651" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*Yiy3WabLW8rSN8Sk6DPVDQ.png"><figcaption class="imageCaption">ChatGPT sharing its wisdom</figcaption></figure><h4 name="b31c" id="b31c" class="graf graf--h4 graf-after--figure">Chad GPT</h4><p name="e3bb" id="e3bb" class="graf graf--p graf-after--h4">So I was playing with ChatGPT, to see if devs are going to lose their jobs in the near future.</p><p name="a391" id="a391" class="graf graf--p graf-after--p">Well, turns out it is very likely!</p><p name="b402" id="b402" class="graf graf--p graf-after--p">For example, it can generate standard MVVM template in seconds. You need to throw hard-ball questions like “can you do model-view binding without @Observable in SwiftUI?” And it seemed to be able to deduce outcome in a logical fashion and determine if you are bullshiting.</p><p name="73d5" id="73d5" class="graf graf--p graf-after--p">In case you are wondering, I ended up convincing it that <code class="markup--code markup--p-code">struct Model: View</code> is a legit model-view binding, and it apologized for its mistakes.</p><p name="ac16" id="ac16" class="graf graf--p graf-after--p">I don’t know if this kind of “learning” can stick around, or some idiot MVVM dev will “correct” its mistake again. But very impressive overall.</p><p name="bdb3" id="bdb3" class="graf graf--p graf-after--p">The funny thing is that AI seemed to understand the abuse of dependency injection better than <em class="markup--em markup--p-em">better programming. </em>As shown in the picture above.</p><h4 name="d131" id="d131" class="graf graf--h4 graf-after--p">Worse programming</h4><p name="a641" id="a641" class="graf graf--p graf-after--h4">There are 3 articles I found on <em class="markup--em markup--p-em">better programming</em>.</p><p name="2aaa" id="2aaa" class="graf graf--p graf-after--p"><a href="https://betterprogramming.pub/swift-why-you-should-avoid-using-default-implementations-in-protocols-eeffddbed46d" data-href="https://betterprogramming.pub/swift-why-you-should-avoid-using-default-implementations-in-protocols-eeffddbed46d" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Swift: Why You Should Avoid Using Default Implementations in Protocols</a></p><p name="94fc" id="94fc" class="graf graf--p graf-after--p"><a href="https://betterprogramming.pub/why-you-shouldnt-use-environmentobject-in-swiftui-a527d5c2bd" data-href="https://betterprogramming.pub/why-you-shouldnt-use-environmentobject-in-swiftui-a527d5c2bd" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Why You Shouldn’t Use @EnvironmentObject in SwiftUI</a></p><p name="0428" id="0428" class="graf graf--p graf-after--p"><a href="https://medium.com/better-programming/ios-clean-architecture-using-swiftui-combine-and-dependency-injection-for-dummies-2e44600f952b" data-href="https://medium.com/better-programming/ios-clean-architecture-using-swiftui-combine-and-dependency-injection-for-dummies-2e44600f952b" class="markup--anchor markup--p-anchor" target="_blank">iOS: Clean Architecture using SwiftUI, Combine, and Dependency Injection</a></p><p name="e991" id="e991" class="graf graf--p graf-after--p">If you only look at face value, this is telling you that:</p><ol class="postList"><li name="d1e5" id="d1e5" class="graf graf--li graf-after--p">Don’t use protocol extension which makes protocol in Swift special</li><li name="884c" id="884c" class="graf graf--li graf-after--li">Don’t use @EnvironmentObject which provides a locally shared storage to avoid<strong class="markup--strong markup--li-strong"> large number of constructor parameters or factory methods. </strong>(as suggested by ChatGPT)</li></ol><p name="93bd" id="93bd" class="graf graf--p graf-after--li">3. Over-reliance on dependency injection while spamming factory methods (SINGLETON!!!) and sell it as<em class="markup--em markup--p-em"> clean architecture</em>.</p><p name="bf71" id="bf71" class="graf graf--p graf-after--p">It may seem like you are fighting SDK every step of the way, if you follow these guides on <em class="markup--em markup--p-em">better programming</em>.</p><p name="23a0" id="23a0" class="graf graf--p graf-after--p">But hey, one of the authors work for META. It may be possible that I’m just not skilled enough to understand the grand design. So what I’m going to do here is to learn from the META guy. And share this journey of self-discovery, appreciation, progression, and enlightment with random people online.</p><p name="dbcc" id="dbcc" class="graf graf--p graf-after--p">Oh, don’t waste your monthly free quotas on any of these. Use it on trending sex articles. I only list them here for reference.</p><h4 name="2a99" id="2a99" class="graf graf--h4 graf-after--p">Dependency injection can also be used to bypass design problems or to avoid thinking about the architecture of an application — ChatGPT</h4><p name="3c3f" id="3c3f" class="graf graf--p graf-after--h4">What’s the architecutre of this application in particular?</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="28ee" id="28ee" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-meta">@EnvironmentObject</span> <span class="hljs-keyword">var</span> generator: <span class="hljs-type">PIDecimalGenerator</span></span></pre><p name="2303" id="2303" class="graf graf--p graf-after--pre">This obviously is hard-coded to a specific generator type <code class="markup--code markup--p-code">PIDecimalGenerator</code> . What if you want to support different generator types?</p><p name="39dc" id="39dc" class="graf graf--p graf-after--p">DI tells you to create an interface. So the first assumption he made is that it has to be a protocol <code class="markup--code markup--p-code">protocol NumberGenerator {…}</code>. As we will see later, you don’t necessarily need protocol.</p><p name="c91d" id="c91d" class="graf graf--p graf-after--p">If you want to write it as</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="eae0" id="eae0" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-meta">@EnvironmentObject</span> <span class="hljs-keyword">var</span> generator: <span class="hljs-type">NumberGenerator</span></span></pre><p name="c13c" id="c13c" class="graf graf--p graf-after--pre">Then <code class="markup--code markup--p-code">NumberGenerator</code>has to conform to @ObservableObject as well. But @ObservableObject is a protocol that can only be used as constraint not concrete type.</p><p name="eaa7" id="eaa7" class="graf graf--p graf-after--p">The problem here is that you don’t casually make a protocol conform to @ObservableObject. The architecture of SwiftUI is that you conform to it when you have something view-related to publish.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="a575" id="a575" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PIDecimalGenerator</span>: <span class="hljs-title class_">ObservableObject</span> {<br />    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> piArray: [<span class="hljs-type">Character</span>]<br />    <br />    <span class="hljs-keyword">init</span>() {<br />        <span class="hljs-keyword">let</span> pi <span class="hljs-operator">=</span> <span class="hljs-type">Double</span>.pi<br />        <span class="hljs-keyword">let</span> piDecimal <span class="hljs-operator">=</span> <span class="hljs-type">String</span>(pi).map { <span class="hljs-variable">$0</span> }<br />        <span class="hljs-keyword">self</span>.piArray <span class="hljs-operator">=</span> <span class="hljs-type">Array</span>(piDecimal.dropFirst(<span class="hljs-number">2</span>)) <span class="hljs-comment">// this drops the `3.` to only keep the decimal digits</span><br />    }<br />    <br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getElement</span>(<span class="hljs-params">at</span> <span class="hljs-params">position</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>? {<br />        <span class="hljs-keyword">guard</span> position <span class="hljs-operator">&lt;</span> piArray.count <span class="hljs-keyword">else</span> {<br />            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br />        }<br />        <span class="hljs-keyword">return</span> <span class="hljs-type">Int</span>(<span class="hljs-type">String</span>(piArray[position]))<br />    }<br />}</span></pre><p name="cb32" id="cb32" class="graf graf--p graf-after--pre">What is the view-related something to publish here?</p><p name="0fa5" id="0fa5" class="graf graf--p graf-after--p">You don’t conform to @ObservedObject jsut so it can compile. The compiler is warning you that you are not prepared to define the associated type required to publish something.</p><p name="9531" id="9531" class="graf graf--p graf-after--p">But you are not going to publish anything. So why bother?</p><p name="fb77" id="fb77" class="graf graf--p graf-after--p">If we don’t look at this in the dim light of DI, but look at the overall architecture, what exactly are we trying to achieve?</p><p name="10e5" id="10e5" class="graf graf--p graf-after--p">We want a locally shared object, that may trigger view updates, but can also store data or library objects that will be used in view re-render when a view update is triggered.</p><p name="9df2" id="9df2" class="graf graf--p graf-after--p">Which means, we can create a publisher that also provides storage, instead of creating a storage that has to pretend to be a publisher. E.g.;</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="403c" id="403c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SharedState</span>: <span class="hljs-title class_">ObservableObject</span> {<br />  <span class="hljs-keyword">var</span> generator: <span class="hljs-type">NumberGenerator</span><br />  <span class="hljs-comment">// ... some other stuff that may publish</span><br />  <span class="hljs-comment">// var service: NetworkService</span><br />}<br /><br /></span></pre><p name="0578" id="0578" class="graf graf--p graf-after--pre">You may split it to multiple smaller observables if refactor is needed. View model, on the other hand, is f-ked. Because they can only put everything in an observable called view model. This is <em class="markup--em markup--p-em">better programming</em>. Don’t think. Consume the product and be excited for the next product.</p><p name="5287" id="5287" class="graf graf--p graf-after--p">He did NOT consider this.</p><p name="5922" id="5922" class="graf graf--p graf-after--p">He went for the “pretend storage is a publisher” approach. In which case <code class="markup--code markup--p-code">NumberGenerator</code> has to be a class. To override member function he needs inheritance. He then encountered a problem where</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="java" name="9c28" id="9c28" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">// parent view</span><br /><span class="hljs-type">let</span> <span class="hljs-variable">generator</span> <span class="hljs-operator">=</span> PIDecimalGenerator()<br />contentView.environmentObject(generator)<br /><br /><span class="hljs-comment">// child view</span><br /><span class="hljs-meta">@EnvironmentObject</span> <span class="hljs-keyword">var</span> generator: NumberGenerator<br /><span class="hljs-comment">// runtime error, can&#x27;t find a NumberGenerator</span><br /><br /></span></pre><p name="a236" id="a236" class="graf graf--p graf-after--pre">Why runtime error?</p><p name="d961" id="d961" class="graf graf--p graf-after--p">I’d argue that @EnvironmentObject is basically a dictionary where you use type as key. You register a <code class="markup--code markup--p-code">PIDecimalGenerator</code> , but ask for a <code class="markup--code markup--p-code">NumberGenerator</code> , which cannot be found.</p><p name="d073" id="d073" class="graf graf--p graf-after--p">If you involve inheritance, e.g.; <code class="markup--code markup--p-code">PIDecimalGenerator</code> and <code class="markup--code markup--p-code">ConstantGenerator</code> are subclasses of <code class="markup--code markup--p-code">NumberGenerator</code> . What if you register both subclasses as keys into dictionary? Then a key <code class="markup--code markup--p-code">NumberGenerator</code> should return both <code class="markup--code markup--p-code">PIDecimalGenerator</code> and <code class="markup--code markup--p-code">ConstantGenerator</code> instances or none at all?</p><p name="d434" id="d434" class="graf graf--p graf-after--p">Who says a dictionary has to satisfy Liskov Substitution Principle? Which is his major complaint about the feature. The problem is that you either can’t get the right object using type as key, or you can get multiple with inheritance. You need something more robust as key like @Environment.</p><p name="41a6" id="41a6" class="graf graf--p graf-after--p">His conclusion:</p><blockquote name="4111" id="4111" class="graf graf--blockquote graf-after--p">We discovered that this technology breaks the Liskov Substitution Principle and denies the late binding. Notwithstanding, we discussed how to leverage inheritance or type erasure to work around this issue.</blockquote><p name="594f" id="594f" class="graf graf--p graf-after--blockquote">I wouldn’t call this breaking the Liskov Substitution Principle. I would call this not learning SDK. You can see his two examples to “work around” this issue for some laugh. Compare to what I just did:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="c17e" id="c17e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SharedState</span>: <span class="hljs-title class_">ObservableObject</span> {<br />  <span class="hljs-keyword">var</span> generator: <span class="hljs-type">NumberGenerator</span><br />  <span class="hljs-comment">// ... some other stuff that may publish</span><br />  <span class="hljs-comment">// var service: NetworkService</span><br />}</span></pre><p name="3c5f" id="3c5f" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">NumberGenerator</code> can be a concrete protocol type. You can have as much Liskov Substitution Principle as you want. The extra cost of <code class="markup--code markup--p-code">SharedState</code> is negligible since you’d most likely need one for network service anyway.</p><p name="42da" id="42da" class="graf graf--p graf-after--p">Again, we don’t look in the dim light of DI. We think about the architecture of an application. Now to make things more interesting, let me try two examples to “work around” this DI issue.</p><h4 name="17bb" id="17bb" class="graf graf--h4 graf-after--p">So you don’t want it hard-coded</h4><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="42a7" id="42a7" class="graf graf--pre graf-after--h4 graf--preV2"><span class="pre--content"><span class="hljs-meta">@EnvironmentObject</span> <span class="hljs-keyword">var</span> generator: <span class="hljs-type">PIDecimalGenerator</span></span></pre><p name="a0d9" id="a0d9" class="graf graf--p graf-after--pre">As previously mentioned, DI tells you to create an interface.</p><p name="cfeb" id="cfeb" class="graf graf--p graf-after--p">First that interface doesn’t have to be protocol. For example we can use closure. In this case we want a function signature like this:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="d4ca" id="d4ca" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">func</span> <span class="hljs-title function_">getElement</span>(<span class="hljs-params">at</span> <span class="hljs-params">position</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>?</span></pre><p name="26d6" id="26d6" class="graf graf--p graf-after--pre">For a <code class="markup--code markup--p-code">ConstantGenerator</code> which returns a constant no matter what, we can create a function that returns a closure:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="kotlin" name="6333" id="6333" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">func getConstantGenerator(_ constant: <span class="hljs-built_in">Int</span>) -&gt; (<span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span>? {<br />  { _ <span class="hljs-keyword">in</span> <span class="hljs-keyword">return</span> constant }<br />}</span></pre><p name="2f4c" id="2f4c" class="graf graf--p graf-after--pre">A little trick from functional programming, which is not covered in your DI textbook.</p><p name="0b90" id="0b90" class="graf graf--p graf-after--p">What is the interface? Function signature.</p><p name="83f0" id="83f0" class="graf graf--p graf-after--p">Note that I don’t even need object. This is of course not a general solution, but an example to show you that the old paradigm of object-protocol-inject may not be absolute.</p><p name="0ebe" id="0ebe" class="graf graf--p graf-after--p">Another point of view is to examine how “runtime” are we talking about?</p><p name="8089" id="8089" class="graf graf--p graf-after--p">Since in Swift you can’t declare a type in runtime; all types must be declared in compile time. Hence you know in compile time how many types that conform to <code class="markup--code markup--p-code">NumberGenerator</code> . Why is this important?</p><p name="a504" id="a504" class="graf graf--p graf-after--p">It means that you can convert an injection problem to a <em class="markup--em markup--p-em">selection </em>problem. E.g.;</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="8eeb" id="8eeb" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Generator</span> {<br />  <span class="hljs-keyword">case</span> constant(<span class="hljs-type">Int</span>)<br />  <span class="hljs-keyword">case</span> pi<br />  <span class="hljs-comment">// ...</span><br />}<br /><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Generator</span> {<br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">getElement</span>(<span class="hljs-params">at</span> <span class="hljs-params">position</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>? {<span class="hljs-operator">...</span>}<br />}<br /><span class="hljs-keyword">var</span> generator: <span class="hljs-type">Generator</span></span></pre><p name="e9d5" id="e9d5" class="graf graf--p graf-after--pre">It’s not hard-coded because I used an ancient technique called <em class="markup--em markup--p-em">variable</em>.</p><p name="c956" id="c956" class="graf graf--p graf-after--p">Yes you may need to configure it during runtime at the last minute, but you can pass those parameters too. E.g.; wrap it in the associated value of enum. Instead of passing reference type protocol objects, you pass value type objects as parameter, therefore eliminating inheritance and every headache associated with it altogether.</p><p name="ce11" id="ce11" class="graf graf--p graf-after--p">Do you think DI textbook ever teach you about Swift? About value type?</p><p name="9a6d" id="9a6d" class="graf graf--p graf-after--p">Instead of “late-binding”, we do most of the work in compile time, because we <strong class="markup--strong markup--p-strong">can </strong>do most of the work in compile time.</p><h4 name="fa5f" id="fa5f" class="graf graf--h4 graf-after--p">What about testing?</h4><p name="a397" id="a397" class="graf graf--p graf-after--h4">I’m not a TDD titan, and I don’t have much experience in SwiftUI testing.</p><p name="f262" id="f262" class="graf graf--p graf-after--p">But before giving up immediately, let’s try another ancient technique called <strong class="markup--strong markup--p-strong">“refactor out functions”</strong> first.</p><p name="2ce4" id="2ce4" class="graf graf--p graf-after--p">Using his example:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="37b3" id="37b3" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ContentViewTests</span>: <span class="hljs-title class_">XCTestCase</span> {<br /><br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">testGetDecimal</span>() <span class="hljs-keyword">throws</span> {<br />        <span class="hljs-keyword">let</span> sut <span class="hljs-operator">=</span> <span class="hljs-type">ContentView</span>()<br />                <br />        <span class="hljs-keyword">let</span> value <span class="hljs-operator">=</span> sut.getDecimal(at: <span class="hljs-number">0</span>)<br />        <br />        <span class="hljs-type">XCTAssertEqual</span>(value, <span class="hljs-string">&quot;1&quot;</span>)<br />    }<br /><br />}</span></pre><p name="31ae" id="31ae" class="graf graf--p graf-after--pre">How do we test <code class="markup--code markup--p-code">getDecimal</code> , as in</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="77e1" id="77e1" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ContentView</span>: <span class="hljs-title class_">View</span> {<br />    <br />    <span class="hljs-meta">@State</span> <span class="hljs-keyword">var</span> decimals: <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br />    <span class="hljs-meta">@EnvironmentObject</span> <span class="hljs-keyword">var</span> generator: <span class="hljs-type">PIDecimalGenerator</span><br />    <br />    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {<span class="hljs-operator">...</span>}<br />    <br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">increaseDecimals</span>() {<br />        <span class="hljs-keyword">self</span>.decimals <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br />    }<br />    <br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getDecimal</span>(<span class="hljs-params">at</span> <span class="hljs-params">position</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">String</span> {<br />        <span class="hljs-keyword">let</span> newValue <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span>.generator.getElement(at: position)<br />        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-subst">\(newValue <span class="hljs-operator">??</span> <span class="hljs-operator">-</span><span class="hljs-number">1</span>)</span>&quot;</span><br />    }<br />}</span></pre><p name="4b76" id="4b76" class="graf graf--p graf-after--pre">You can’t use inheritance and if you move model out to a class object, then what’s the point of having value type <code class="markup--code markup--p-code">struct ContentView</code>?</p><p name="eabc" id="eabc" class="graf graf--p graf-after--p">That is, we need to refactor out function without moving model.</p><p name="d96b" id="d96b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Protocol extension as default implementation</strong>. Using a quote from <em class="markup--em markup--p-em">Loki</em>, a disney+ show.</p><blockquote name="318f" id="318f" class="graf graf--blockquote graf-after--p"><strong class="markup--strong markup--blockquote-strong">Better programming: </strong>I don’t believe you. You’re lying. It’s not true.</blockquote><blockquote name="1b1b" id="1b1b" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong">Mobius : </strong>It is true. That’s the proper flow of SwiftUI and it happens again and again and again because it’s supposed to, because it has to.</blockquote><figure name="6b0c" id="6b0c" class="graf graf--figure graf-after--blockquote"><img class="graf-image" data-image-id="1*sXP7NmEbHbIb6Vwty9yBDA.jpeg" data-width="625" data-height="500" src="https://cdn-images-1.medium.com/max/800/1*sXP7NmEbHbIb6Vwty9yBDA.jpeg"></figure><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="c10e" id="c10e" class="graf graf--pre graf-after--figure graf--preV2"><span class="pre--content"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">GeneratorHandler</span> {<br />  <span class="hljs-keyword">var</span> generator: <span class="hljs-type">NumberGenerator</span> {<span class="hljs-keyword">get</span>}<br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">getDecimal</span>(<span class="hljs-params">at</span> <span class="hljs-params">position</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">String</span><br />}<br /><br /><span class="hljs-keyword">extension</span> <span class="hljs-title class_">GeneratorHandler</span> {<br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">getDecimal</span>(<span class="hljs-params">at</span> <span class="hljs-params">position</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">String</span> {<br />    <span class="hljs-keyword">let</span> newValue <span class="hljs-operator">=</span> generator.getElement(at: position)<br />    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-subst">\(newValue <span class="hljs-operator">??</span> <span class="hljs-operator">-</span><span class="hljs-number">1</span>)</span>&quot;</span><br />  }<br />}   </span></pre><p name="d45f" id="d45f" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">ContentView</code> conformance:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="597e" id="597e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ContentView</span>: <span class="hljs-title class_">View</span>, <span class="hljs-title class_">GeneratorHandler</span> {<br />  <span class="hljs-keyword">var</span> generator: <span class="hljs-type">NumberGenerator</span> {<br />    <span class="hljs-keyword">self</span>.env.generator<br />  }<br />  <span class="hljs-meta">@EnvironmentObject</span> <span class="hljs-keyword">var</span> env: <span class="hljs-type">SharedState</span><br />   <span class="hljs-comment">// call getDecimal somewhere...</span><br />}</span></pre><p name="30a2" id="30a2" class="graf graf--p graf-after--pre">I omit</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="8006" id="8006" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">func</span> <span class="hljs-title function_">increaseDecimals</span>() {<br />   <span class="hljs-keyword">self</span>.decimals <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br />}</span></pre><p name="dfdf" id="dfdf" class="graf graf--p graf-after--pre">because <code class="markup--code markup--p-code">decimals</code> is a @State property, which requires <code class="markup--code markup--p-code">mutating</code> keyword in protocol extension. In other words, <code class="markup--code markup--p-code">mutating</code> means <em class="markup--em markup--p-em">state changes</em>. You can use this to build a Redux-like architecture if you can separate out state changes. I’m omitting it here for simplicity.</p><p name="2682" id="2682" class="graf graf--p graf-after--p">Since @EnvironmentObject is abstracted out, there should be no problem testing this protocol. Is this efficient? It depends on how good you are with POP, and how good you can design test-ready protocols.</p><p name="33eb" id="33eb" class="graf graf--p graf-after--p">On the other hand, does any of the reference articles mention this? You know what? does any of the Internet mention this? Does Swift mention this? Yes!!! They told you it’s the first POP language from day1!</p><p name="99cc" id="99cc" class="graf graf--p graf-after--p">Why is that 5 years later, all I see is DI dumb shit that doesn’t know how to use variables.</p><p name="4f86" id="4f86" class="graf graf--p graf-after--p">Anyway, not saying this is the best solution, and it depends on some POP experiences. But to say it is impossible? Have to rely on third-party library or move everything to a reference type? I don’t think so.</p><p name="6224" id="6224" class="graf graf--p graf-after--p">Not to mention, this particular caveat is due to you can’t give @EnvironmentObject an inital value. Otherwise you can easily mock it without going through the view hierarchy. But you can give @State or @StateObject initial value. What is the excuse then?</p><blockquote name="f01b" id="f01b" class="graf graf--blockquote graf-after--p">Sadly, there is no way to test the view using a vanilla SwiftUI approach. At least, <strong class="markup--strong markup--blockquote-strong">I couldn’t find an easy way to do that</strong>.</blockquote><p name="2dc1" id="2dc1" class="graf graf--p graf-after--blockquote">…Really? I hope I at least present a plausible argument. And you can determine yourself.</p><p name="2ad4" id="2ad4" class="graf graf--p graf-after--p">Let’s wrap up.</p><h4 name="7d54" id="7d54" class="graf graf--h4 graf-after--p">Tumor suppression</h4><p name="6adc" id="6adc" class="graf graf--p graf-after--h4">Think of DI as abnormal growth of cells.</p><p name="b43d" id="b43d" class="graf graf--p graf-after--p">@EnvironmentObject as the p53 tumor suppression protein.</p><p name="1964" id="1964" class="graf graf--p graf-after--p">In above example @EnvironmentObject stopped Meta guy’s attempt to do DI, i.e.; abnormal growth of initializers. Compare how many initializers he wrote and how many I wrote.</p><p name="30a5" id="30a5" class="graf graf--p graf-after--p">Does @EnvironmentObject cause difficulty in testing? Yes. Can it be overcome? I think so. If you are not a TDD titan, that doesn’t even concern you. The hard part of testing is not test coverage, it is how effective your test really is. People write dummy tests all the time. Do you sacrifice a language feature that significantly simplifies your overall code design for some test coverage? That may be otherwise covered by preview or QA?</p><p name="3a92" id="3a92" class="graf graf--p graf-after--p">Or to do DI for the sake of doing DI?</p><p name="a635" id="a635" class="graf graf--p graf-after--p">The referenced <em class="markup--em markup--p-em">Clean Architecture using DI </em>shows you what will happen when removing p53 tumor suppression protein: CANCER, a.k.a <strong class="markup--strong markup--p-strong">SINGLETON SPAMMING.</strong></p><blockquote name="c58d" id="c58d" class="graf graf--blockquote graf-after--p">If not used carefully, dependency injection can create dependencies between components that are diffucult to understand or maintain.</blockquote><blockquote name="0d3f" id="0d3f" class="graf graf--blockquote graf-after--blockquote">— ChatGPT</blockquote><p name="cad3" id="cad3" class="graf graf--p graf-after--blockquote">You may argue that is not abusing singleton. Interesting, <strong class="markup--strong markup--p-strong">because that’s what EVERYONE WHO ABUSES SINGLETON would say</strong>.</p><p name="8b4c" id="8b4c" class="graf graf--p graf-after--p">You store instance variables as static properties and then use them in other instances, that doesn’t bother you? Is this really the hill you want to die on?</p><p name="3201" id="3201" class="graf graf--p graf-after--p">That’s why I need to write this. Singleton spamming as clean architecture is bad enough, published on <em class="markup--em markup--p-em">better programming</em> mind you. The immediate defense against it is to use language feature like @EnvironmentObject.</p><p name="9fc1" id="9fc1" class="graf graf--p graf-after--p">Then came this META guy telling people why you shouldn’t use @EnvironmentObject. His inheritance argument is wrong and you don’t need inheritance at all. Testability is an issue, but that isn’t the only thing that presents challange in testing in SwiftUI declarative framework.</p><p name="f213" id="f213" class="graf graf--p graf-after--p">The immediate defense against it is to use protocol extension which (suprised pickachu face), some dude on the same platform told people not to use!</p><p name="35f4" id="35f4" class="graf graf--p graf-after--p">Wtf are you guys using then? SINGLETON??? That is acceptable to you?</p><p name="1cc9" id="1cc9" class="graf graf--p graf-after--p">The one about clean architecture is standard propaganda template, nothing new. The one against protocol extension could use some counter-argument, which I don’t have time for. Let’s just say if he worries about static dispatch, then use dynamic dispatch; if he worries about protocol being too large, use composition.</p><p name="f753" id="f753" class="graf graf--p graf-after--p graf--trailing">I thought I ran a parody sub here, but as it turns out, it may be <em class="markup--em markup--p-em">worse programming </em>all along<em class="markup--em markup--p-em">.</em></p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/ecdc65525745"><time class="dt-published" datetime="2023-01-01T14:44:34.584Z">January 1, 2023</time></a>.</p><p><a href="https://medium.com/@swift2931/why-you-should-use-environmentobject-in-swiftui-ecdc65525745" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>