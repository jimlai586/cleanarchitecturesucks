<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Effin Architecture</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Effin Architecture</h1>
</header>
<section data-field="subtitle" class="p-summary">
Do the opposite of what Clean Architecture told you
</section>
<section data-field="body" class="e-content">
<section name="fc47" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="e15e" id="e15e" class="graf graf--h3 graf--leading graf--title">Effin Architecture</h3><h4 name="fbaa" id="fbaa" class="graf graf--h4 graf-after--h3 graf--subtitle">Do the opposite of what Clean Architecture told you</h4><figure name="c676" id="c676" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*LHD_zWt894qXrUXVFf-6yg.jpeg" data-width="564" data-height="567" src="https://cdn-images-1.medium.com/max/800/1*LHD_zWt894qXrUXVFf-6yg.jpeg"><figcaption class="imageCaption">From the movie Pirates of the Caribbean</figcaption></figure><h4 name="91ef" id="91ef" class="graf graf--h4 graf-after--figure">This is either madness, or brilliance</h4><p name="cc7a" id="cc7a" class="graf graf--p graf-after--h4">Think of Clean Architecture as British navy.</p><p name="dc02" id="dc02" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">And we… are pirates!</strong></p><p name="6417" id="6417" class="graf graf--p graf-after--p">What I’m going to do here, is to propose a brand new architecture two decades after Clean Architecture… while waiting to see John Wick 4.</p><p name="f3db" id="f3db" class="graf graf--p graf-after--p">Based on my vast experiences reviewing MVVM and clean architecture, a typical Clean Architecture contains:</p><ol class="postList"><li name="d391" id="d391" class="graf graf--li graf-after--p">View model monkeys</li><li name="9505" id="9505" class="graf graf--li graf-after--li">Injection idiots -&gt; singleton spammers</li><li name="1bdc" id="1bdc" class="graf graf--li graf-after--li">TDD titans</li><li name="b937" id="b937" class="graf graf--li graf-after--li">Brute force boilerplate</li></ol><p name="4b02" id="4b02" class="graf graf--p graf-after--li">The only thing Clean Architecture does right is the name. It’s very hard to come up with a name as clean as… well “Clean”. After much contemplation while playing Diablo 4 beta, I decided to name it…</p><p name="4287" id="4287" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Effin Architecture, short for Efficient.</strong></p><p name="7720" id="7720" class="graf graf--p graf-after--p">Why? Becasue “clean” code makes you write dumb shit to look clean, as in “modular”, “improved testability” while in fact you are just over-generalizing, a concept I hope to introduce to the public.</p><p name="283c" id="283c" class="graf graf--p graf-after--p">Efficient architecture, on the other hand, wants you to write code as efficient as possible. No redundant shit. No bullshit excuse for “this may seem too tedious for small projects… ”. If you write boilerplate, you’ve failed, and if creating some sink object is all your efforts, you’ve failed.</p><p name="3d7b" id="3d7b" class="graf graf--p graf-after--p">Wait, but Clean Architecture is such well-established after two decades of practice, who the F are you to think you can do better? Not to mention that you are going to do it in complete opposite? You’ll never make it out of the bay!</p><p name="65ee" id="65ee" class="graf graf--p graf-after--p">Son. I’m captain Jack Sparrow. Savvy?</p><h4 name="286a" id="286a" class="graf graf--h4 graf-after--p">You are without doubt the worst pirate I’ve ever heard of</h4><p name="aa80" id="aa80" class="graf graf--p graf-after--h4">First let us commandeer a tutorial from <a href="https://www.kodeco.com/3595916-clean-architecture-tutorial-for-android-getting-started" data-href="https://www.kodeco.com/3595916-clean-architecture-tutorial-for-android-getting-started" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">raywenderlich</a>.</p><p name="46c8" id="46c8" class="graf graf--p graf-after--p">This is for Android. And we are going to use SwiftUI. Why? Because no iOS dev has ever had an original idea, and has to steal from Android. If there’s one SDK where you don’t have to write like Java, it is SwiftUI.</p><figure name="cf74" id="cf74" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*pD338BtJqPyv37CD64WQPA.png" data-width="973" data-height="715" src="https://cdn-images-1.medium.com/max/800/1*pD338BtJqPyv37CD64WQPA.png"></figure><p name="2955" id="2955" class="graf graf--p graf-after--figure">Note the bottom line. “Clean Architecture” <strong class="markup--strong markup--p-strong">maximizes </strong>the use of these principles.</p><p name="5296" id="5296" class="graf graf--p graf-after--p">I’m going to do the opposite. More specifically:</p><ol class="postList"><li name="96ca" id="96ca" class="graf graf--li graf-after--p">Single Responsibility</li></ol><p name="f7f8" id="f7f8" class="graf graf--p graf-after--li">This shit is too ambiguous. Applying too restrictly, you have too many small objects that increase overheads; applying too loosely, it becomes worthless.</p><p name="ba9b" id="ba9b" class="graf graf--p graf-after--p">2. Open-closed</p><p name="8e49" id="8e49" class="graf graf--p graf-after--p">This shit is too funny. Find me one tutorial online that builds around protocol extension. I have to write reviews asking WTF is your protocol extension? <strong class="markup--strong markup--p-strong">Maximize </strong>my ass. I’m not sure how they pull it off in Java, because ironically the word “extension” only appeared once in that tutorial.</p><p name="b9bd" id="b9bd" class="graf graf--p graf-after--p">I’m going to assume nobody really gave a shit about this; so the opposite of that is to build around it using protocol extension.</p><p name="d787" id="d787" class="graf graf--p graf-after--p">3. Liskov substitution</p><p name="3194" id="3194" class="graf graf--p graf-after--p">Don’t even bother. Don’t use inheritace.</p><p name="ebb6" id="ebb6" class="graf graf--p graf-after--p">4. Interface segregation</p><p name="4579" id="4579" class="graf graf--p graf-after--p">This is too dumb I have to quote it.</p><blockquote name="4bc1" id="4bc1" class="graf graf--blockquote graf-after--p">It’s better to have many smaller interfaces than a large one, to prevent the class from implementing the methods that it doesn’t need.</blockquote><p name="37d2" id="37d2" class="graf graf--p graf-after--blockquote">No it is <strong class="markup--strong markup--p-strong">NOT </strong>better to have many smaller interfaces. Otherwise we should all create classes with 1 member function. It is way more <em class="markup--em markup--p-em">efficient </em>to group them together and have shared resources and states. Too few is just as bad as too many. The key is to find a balance.</p><p name="3cf4" id="3cf4" class="graf graf--p graf-after--p">Preventing the class… WTF are you talking about? If you <em class="markup--em markup--p-em">need </em>to create that function, then it is needed already. Do you really need some principle to tell you not to write shit you don’t need?</p><p name="027a" id="027a" class="graf graf--p graf-after--p">I’m going to drop this dumb shit entirely.</p><p name="eb9d" id="eb9d" class="graf graf--p graf-after--p">5. Dependency inversion</p><p name="317b" id="317b" class="graf graf--p graf-after--p">This is the signature over-generalization. Do you notice how these abstract principles just casually drop a bomb on you that you <em class="markup--em markup--p-em">should </em>create abstractions non-stop from now on for no apparent reason?</p><p name="7acf" id="7acf" class="graf graf--p graf-after--p">Can I ask you to modularize <em class="markup--em markup--p-em">everything</em> and take credit of your work, meanwhile taking money off of you from the online course I sold you?</p><p name="7da6" id="7da6" class="graf graf--p graf-after--p">What makes it worse is that the DI in Clean Architecture is coupled with runtime, e.g;</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="f65f" id="f65f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">service</span>: <span class="hljs-type">NetworkService</span>)<br /><span class="hljs-comment">//...service.job()</span></span></pre><p name="5c79" id="5c79" class="graf graf--p graf-after--pre">Why does this <code class="markup--code markup--p-code">service</code> have to come from outside? That means you have to inject it during runtime.</p><p name="f5d8" id="f5d8" class="graf graf--p graf-after--p">This violates Newton’s third law. See? I can make up abstract principles too. Newton’s third law states that every action has a reaction. In this case the caller must suffer a reaction where it needs to know, choose, and create a <code class="markup--code markup--p-code">NetworkService</code> with proper arguments. What happens to encapsulation? And what if it involves many services? And that is just one invocation. You need to do the same thing for <em class="markup--em markup--p-em">every </em>invocation.</p><p name="fda8" id="fda8" class="graf graf--p graf-after--p">So why inject it in the first place?</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="7d4c" id="7d4c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">let</span> service <span class="hljs-operator">=</span> <span class="hljs-type">NetworkService</span>() <span class="hljs-comment">// local var</span><br />service.job()</span></pre><p name="76c8" id="76c8" class="graf graf--p graf-after--pre">Does this local creation violate the principle that you should depend on abstraction?</p><p name="ed6d" id="ed6d" class="graf graf--p graf-after--p">No. I don’t know the implementation of <code class="markup--code markup--p-code">job()</code> in this case. This will suffice since I don’t need to swap out service in runtime.</p><p name="c5d5" id="c5d5" class="graf graf--p graf-after--p">Don’t inject dumb shit for the sake of injecting dumb shit.</p><p name="7b9a" id="7b9a" class="graf graf--p graf-after--p">If you remove dumb shit injection, then there’s no dependency, then there’s no dependency management, then you won’t need singleton that “resolves” dependency as another library dependency. E.g.; these dumb shit</p><figure name="28d2" id="28d2" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*GUbYgKissStGtX30kY6tZA.png" data-width="1143" data-height="303" src="https://cdn-images-1.medium.com/max/800/1*GUbYgKissStGtX30kY6tZA.png"><figcaption class="imageCaption">guess where this is coming from</figcaption></figure><p name="2d30" id="2d30" class="graf graf--p graf-after--figure">The opposite of this principle is, of course, don’t f-ing bother. Use auto-gen default initializer only.</p><p name="0939" id="0939" class="graf graf--p graf-after--p">The above are the <em class="markup--em markup--p-em">corner stone</em> of Clean Architecture. <strong class="markup--strong markup--p-strong">CORNER STONE</strong>. You can tell it can only be an over-generalized dumpster fire just by examining it.</p><h4 name="cf2d" id="cf2d" class="graf graf--h4 graf-after--p">Tortuga?</h4><blockquote name="95c9" id="95c9" class="graf graf--blockquote graf-after--h4">The only rules that really matter are these: what a man can do and what a man can’t do. For instance, you can accept that Clean Architecture is full of shit or you can’t. But pirate is in your blood, boy, so you’ll have to square with that some day.</blockquote><p name="17f8" id="17f8" class="graf graf--p graf-after--blockquote">Now me, for example. I can let you write boilerplate dumb shit.</p><p name="b986" id="b986" class="graf graf--p graf-after--p">But I can’t take credit if someone figured this out first, savvy?</p><p name="a85d" id="a85d" class="graf graf--p graf-after--p">So I’m going to ask 3 enlightening questions. Then build on the answers.</p><ol class="postList"><li name="217d" id="217d" class="graf graf--li graf-after--p">Can you do this?</li></ol><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="1add" id="1add" class="graf graf--pre graf-after--li graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pirate</span>: <span class="hljs-title class_">View</span>, <span class="hljs-title class_">Codable</span> {<span class="hljs-operator">...</span>}</span></pre><p name="e97c" id="e97c" class="graf graf--p graf-after--pre">I.e.; conform to <code class="markup--code markup--p-code">View</code> and <code class="markup--code markup--p-code">Codable</code> at the same time.</p><p name="1b3e" id="1b3e" class="graf graf--p graf-after--p">It works. You cannot add properties that break <code class="markup--code markup--p-code">Codable</code> , of course. But it will work given that you know what you are doing.</p><p name="aaf9" id="aaf9" class="graf graf--p graf-after--p">This implies <code class="markup--code markup--p-code">Pirate</code> is a model, not a view. It does not have traditional view properties like background color… etc either.</p><p name="1d11" id="1d11" class="graf graf--p graf-after--p">You can accept that it can be a model or you can’t. The fact is that it changes everything if you replace view with model. It will be like you remove healer from the warrior-mage-healer trinity. Yet such mmorpg exists.</p><p name="e588" id="e588" class="graf graf--p graf-after--p">2a. Can you replace this using property observer?</p><figure name="1441" id="1441" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Mz3fzvYYPk3xo2lWKqbg4Q.png" data-width="1125" data-height="489" src="https://cdn-images-1.medium.com/max/800/1*Mz3fzvYYPk3xo2lWKqbg4Q.png"></figure><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="8837" id="8837" class="graf graf--pre graf-after--figure graf--preV2"><span class="pre--content"><span class="hljs-keyword">var</span> model: <span class="hljs-type">Pirate</span> {<br />  <span class="hljs-keyword">didSet</span> { <br />    <span class="hljs-comment">// update UI</span><br />  }<br />} </span></pre><p name="6117" id="6117" class="graf graf--p graf-after--pre">This is known as binding. I challenge you to find any MVVM tutorial that does binding this way… or just even mention binding.</p><p name="5d07" id="5d07" class="graf graf--p graf-after--p">Note how it treats view model as a model. <code class="markup--code markup--p-code">UIState</code> is a model too. Yeah, it sounds like a two man job… why not combine it? That is because “view model” will contain “business logic”.</p><p name="b4cb" id="b4cb" class="graf graf--p graf-after--p">So here is a crazy idea. Sit down and hear me out. Don’t freak out.</p><p name="2321" id="2321" class="graf graf--p graf-after--p">What if we refactor out “business logic”, then view model is just UI state?</p><p name="fe98" id="fe98" class="graf graf--p graf-after--p">You can’t. Because it would become MVC. And MVC is outlawed, because it doesn’t sell tutorial.</p><p name="f2e0" id="f2e0" class="graf graf--p graf-after--p">2b. Can you combine view model and UI state?</p><figure name="f4d3" id="f4d3" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*i5YD82nO6WitiftKXQG1XQ.png" data-width="1116" data-height="844" src="https://cdn-images-1.medium.com/max/800/1*i5YD82nO6WitiftKXQG1XQ.png"></figure><p name="d762" id="d762" class="graf graf--p graf-after--figure">In SwiftUI, this is</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="less" name="3cea" id="3cea" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-selector-tag">struct</span> <span class="hljs-selector-tag">DiceRoll</span>: <span class="hljs-selector-tag">View</span> {<br />  <span class="hljs-variable">@State</span> var <span class="hljs-attribute">first</span>: Int = <span class="hljs-number">0</span><br />  <span class="hljs-variable">@State</span> var <span class="hljs-attribute">second</span>: Int = <span class="hljs-number">0</span><br />  ...<br />  func <span class="hljs-built_in">rollDice</span>() {<br />    <span class="hljs-comment">// change state</span><br />  }<br />  var <span class="hljs-attribute">body</span>: some View {...} <span class="hljs-comment">// binding</span><br />}</span></pre><p name="5799" id="5799" class="graf graf--p graf-after--pre">I haven’t even begun to refactor out “bussiness logic”.</p><p name="0230" id="0230" class="graf graf--p graf-after--p">Note that in Java it <strong class="markup--strong markup--p-strong">inherits </strong><code class="markup--code markup--p-code">ViewModel</code> . You don’t have that for value type, which means you need another way for code reuse. So iOS MVVM has to over-generalize DI which is already an over-generalization.</p><p name="cbe6" id="cbe6" class="graf graf--p graf-after--p">The only people who don’t know how to write MVVM are the people writing it.</p><p name="f2c1" id="f2c1" class="graf graf--p graf-after--p">3. What’s wrong with this?</p><figure name="326b" id="326b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ULAF2S83pmHSVc_ralbwIA.png" data-width="1101" data-height="215" src="https://cdn-images-1.medium.com/max/800/1*ULAF2S83pmHSVc_ralbwIA.png"></figure><p name="1ee1" id="1ee1" class="graf graf--p graf-after--figure">This has two problems. Dumb shit “use case” and dumb shit “repository”, which is domain layer and data layer respectively in Android terms.</p><p name="96fc" id="96fc" class="graf graf--p graf-after--p">Clean Architecture, like MVVM, avoids the word “Control” at all costs. But Control is the most important part of any app. Otherwise your app is a static image.</p><p name="4c82" id="4c82" class="graf graf--p graf-after--p">And like MVVM, it refactors model out. Not control, or “business logic”. This gives you major disadvanges in terms of refactor.</p><p name="0a51" id="0a51" class="graf graf--p graf-after--p">Why? In simple case, <code class="markup--code markup--p-code">NewsRepository</code> is probably just a fetch to endpoint <code class="markup--code markup--p-code">\news</code> ; and <code class="markup--code markup--p-code">AuthorRepository</code> is a fetch to endpoint <code class="markup--code markup--p-code">\author</code> .</p><p name="9197" id="9197" class="graf graf--p graf-after--p">The two fetches only differ in endpoint. Which means all you need is an endpoint parameter, which means you need to inherit something to reuse code. How do you call this something? <code class="markup--code markup--p-code">CommonRepository</code> ? But they don’t have a common model type. It is the fetch you want to refactor, which is not a repository.</p><p name="558f" id="558f" class="graf graf--p graf-after--p">Which is more efficient? Create a repository for each model type? Or a <code class="markup--code markup--p-code">fetch&lt;T&gt;() -&gt; T</code> ? This is so dangerously close to brute force.</p><p name="c345" id="c345" class="graf graf--p graf-after--p">You know from the get-go that it has to refactor <code class="markup--code markup--p-code">fetch</code> . But where is it in the Clean Architecture? It will be a <code class="markup--code markup--p-code">networkService</code> passed in as a parameter in the initializer of a <code class="markup--code markup--p-code">respository</code> which is then passed in as a parameter in the initializer of a <code class="markup--code markup--p-code">useCase</code> . This <code class="markup--code markup--p-code">networkService</code> doesn’t have the code directy, it inherits from some N-level up ancestor, and itself requires parameters in initializer. I feel tired just describing it.</p><p name="e6dd" id="e6dd" class="graf graf--p graf-after--p">Not to mention, your model is always mutable and suject to side effects. You can’t even pass it around because they are not just “model”, they have hidden control. And guess what Clean Architecture told you to do? Pass it around as if they are “modular”, and you are doing DI like a pro.</p><p name="8708" id="8708" class="graf graf--p graf-after--p">Use case is a fancy name for hard-coded. Do you think you willl ever need to swap out for another <code class="markup--code markup--p-code">NewsRepository</code> ? Most likely you just need to change endpoint at runtime, which makes this a massive overkill.</p><p name="69fd" id="69fd" class="graf graf--p graf-after--p">And why not use function? E.g.; <code class="markup--code markup--p-code">func getLatestNewsWithAuthor(...)</code></p><p name="8db3" id="8db3" class="graf graf--p graf-after--p">Why must everything be an object?</p><p name="4f8e" id="4f8e" class="graf graf--p graf-after--p">Oh, and how many times you need to write “Repository”, “UseCase”, “ViewModel”?</p><p name="17f9" id="17f9" class="graf graf--p graf-after--p">A comparison:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="add7" id="add7" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">func</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">endpoint</span>: <span class="hljs-type">String</span>) <span class="hljs-keyword">async</span> -&gt; <span class="hljs-type">JSON</span> {<span class="hljs-operator">...</span>}<br /><span class="hljs-keyword">func</span> <span class="hljs-title function_">doSomething</span>&lt;<span class="hljs-type">T</span>&gt; <span class="hljs-keyword">async</span> -&gt; <span class="hljs-type">T</span> {<span class="hljs-operator">...</span>} <span class="hljs-comment">// call fetch</span></span></pre><p name="ac3d" id="ac3d" class="graf graf--p graf-after--pre">This is <strong class="markup--strong markup--p-strong">refactor by function</strong>. Do I need multiple layers, inheritance, initializers, dependency management, naming conventions… etc?</p><blockquote name="bfeb" id="bfeb" class="graf graf--pullquote graf-after--p">The only rules that really matter are these: what a man can do and what a man can’t do.</blockquote><p name="c023" id="c023" class="graf graf--p graf-after--pullquote">You can replace view with a model that conforms to <code class="markup--code markup--p-code">View</code> .</p><p name="e270" id="e270" class="graf graf--p graf-after--p">You can do binding without middle man.</p><p name="acde" id="acde" class="graf graf--p graf-after--p">You can refactor by function instead of by model.</p><p name="5129" id="5129" class="graf graf--p graf-after--p">Whether you can accept it or not, can you build on these and propose a new architecture?</p><h4 name="0587" id="0587" class="graf graf--h4 graf-after--p">Welcome to the Caribbean, love.</h4><figure name="b473" id="b473" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*Kfl6MoG3TjxdFwXP0ON1cA.png" data-width="650" data-height="398" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*Kfl6MoG3TjxdFwXP0ON1cA.png"><figcaption class="imageCaption">An image with sound</figcaption></figure><p name="3af8" id="3af8" class="graf graf--p graf-after--figure">This is the time we propose a core principle that binds what we’ve discussed so far together.</p><blockquote name="929c" id="929c" class="graf graf--pullquote graf-after--p"><strong class="markup--strong markup--pullquote-strong">POP = refactor out Control</strong></blockquote><p name="d6bc" id="d6bc" class="graf graf--p graf-after--pullquote">Let’s work on an example.</p><figure name="e64e" id="e64e" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*XpytqCTs1YwimsvaI4fdvQ.png" data-width="1121" data-height="996" src="https://cdn-images-1.medium.com/max/800/1*XpytqCTs1YwimsvaI4fdvQ.png"></figure><p name="684b" id="684b" class="graf graf--p graf-after--figure">First we need to make fun of the stupid dumb shit “benefits”.</p><p name="99bf" id="99bf" class="graf graf--p graf-after--p">Android is responsible for this irresponsible false advertisement.</p><p name="c316" id="c316" class="graf graf--p graf-after--p">Dude, all you do is put control in a sink object. Then it magically has these benefits. It does not avoid code duplication, you have to duplicate code to make it, or via additional inheritance or injection. Readability is “improved”because you repeat the word “use case”, “respository” so many times, which is a form of duplicate code already. Testability has more to do with the quality of your function than you creating smaller objects. Spliting large classes causes other problems that it ignore completely. The key is to find a balance, remember?</p><p name="b117" id="b117" class="graf graf--p graf-after--p">Some example “use cases” from the tutorial:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="kotlin" name="a21a" id="a21a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddDocument</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> documentRepository: DocumentRepository) {<br />  <span class="hljs-keyword">suspend</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">(document: <span class="hljs-type">Document</span>)</span></span> = documentRepository.addDocument(document)<br />}</span></pre><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="kotlin" name="c4b7" id="c4b7" class="graf graf--pre graf-after--pre graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GetBookmarks</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> bookmarkRepository: BookmarkRepository) {<br /><br />  <span class="hljs-keyword">suspend</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">(document: <span class="hljs-type">Document</span>)</span></span> = bookmarkRepository.getBookmarks(document)<br />}</span></pre><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="kotlin" name="ae32" id="ae32" class="graf graf--pre graf-after--pre graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GetDocuments</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> documentRepository: DocumentRepository) {<br />  <span class="hljs-keyword">suspend</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">()</span></span> = documentRepository.getDocuments()<br />}</span></pre><p name="0d51" id="0d51" class="graf graf--p graf-after--pre">I hope you can appreciate how stupid this is. He created 3 classes for 3 use cases without any refactor in mind; The class calls <code class="markup--code markup--p-code">addDocument()</code> for you from the <code class="markup--code markup--p-code">documentRepository</code> you pass in. Why not just call it directly? E.g.; <code class="markup--code markup--p-code">documentRepository.addDocument()</code> . And note how he uses <code class="markup--code markup--p-code">invoke()</code> so you can use class instances like function… Then just use function!!!</p><p name="a0df" id="a0df" class="graf graf--p graf-after--p">Now enters <strong class="markup--strong markup--p-strong">Effin Architecture</strong>. First we consider protocol. Since POP = refactor out function, we consider what functions we want to refactor. Let’s assume most common use case, i.e.; networking.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="0e53" id="0e53" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Reader</span>: <span class="hljs-title class_">class</span> {<br />  <span class="hljs-keyword">var</span> api: <span class="hljs-type">NetworkService</span> {<span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span>}<br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">addDocument</span>()<br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">getBookMarks</span>() -&gt; <span class="hljs-type">BookMark</span><br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">getDocuments</span>() -&gt; [<span class="hljs-type">Document</span>]<br />}<br /><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Reader</span> {<br />  <span class="hljs-operator">...</span> <span class="hljs-comment">// default impl.</span><br />}</span></pre><p name="f2b8" id="f2b8" class="graf graf--p graf-after--pre">Default is important because you are not <strong class="markup--strong markup--p-strong">requiring </strong>people to implement anymore; you are <strong class="markup--strong markup--p-strong">providing </strong>a<strong class="markup--strong markup--p-strong"> </strong>library with customization options.</p><p name="7a0d" id="7a0d" class="graf graf--p graf-after--p">We don’t even give a shit about the classes that conform to it anymore. Plug this protocol anywhere, and you have these functions ready to go. Refactor from the get-go.</p><p name="f6c7" id="f6c7" class="graf graf--p graf-after--p">What about UI? Make <code class="markup--code markup--p-code">BookMark</code> conform to <code class="markup--code markup--p-code">View</code> . Open-closed principle in case you didn’t notice. We are extending in a declarative fashion all the way through. At no point do we stop to write initializers. Functions are front and center, not hidden in some “respository” that you have to inherit.</p><p name="6aaf" id="6aaf" class="graf graf--p graf-after--p">But… but what about dependency? Who gives a shit. Design so your service is versitile to handle most common usage; instead of creating a new one from scratch for every simple task and do runtime swap. The best dependency is no dependency. The best code is no code. <strong class="markup--strong markup--p-strong">Efficient</strong>.</p><blockquote name="1262" id="1262" class="graf graf--blockquote graf-after--p">Clean Architecture: You didn’t beat me. You ignored the rules of dependency. In a fair fight, I’d kill you.<br>- Jack Sparrow: That’s not much incentive for me to fight fair, then, is it?</blockquote><figure name="659d" id="659d" class="graf graf--figure graf-after--blockquote"><img class="graf-image" data-image-id="1*oV_UWJHwVuQuOXh9kVllQw.png" data-width="800" data-height="600" src="https://cdn-images-1.medium.com/max/800/1*oV_UWJHwVuQuOXh9kVllQw.png"><figcaption class="imageCaption">The circle of idiots</figcaption></figure><p name="03f4" id="03f4" class="graf graf--p graf-after--figure">But this seems legit and everything? Are you Thor, god of dependency? His usage of dependency inversion is wrong. At the very least it doesn’t need to be runtime, and abstract interface doesn’t have to be protocol. Functions can be interface, which we do all the time without special mentioning.</p><p name="9af5" id="9af5" class="graf graf--p graf-after--p">Note that this abstraction, again by Newton’s third law, has a reaction. It forces you to generalize. You work with protocol object instead of real services. That means we need another principle that is the opposite of that.</p><blockquote name="bb31" id="bb31" class="graf graf--pullquote graf-after--p">Specialization over generalization</blockquote><p name="e768" id="e768" class="graf graf--p graf-after--pullquote"><strong class="markup--strong markup--p-strong">Effin Architecture</strong> does not give a shit about dependency, which frees us. We can be as specialized as want.</p><p name="79e8" id="79e8" class="graf graf--p graf-after--p">Do we access DB via some abstract gateway shit? Fk no.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="c361" id="c361" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">var</span> db <span class="hljs-operator">=</span> <span class="hljs-type">SQL</span>()<br />db.select(<span class="hljs-operator">...</span>)<br /><br /><span class="hljs-keyword">var</span> mongo <span class="hljs-operator">=</span> <span class="hljs-type">MongoDB</span>()<br />mongo.query(<span class="hljs-operator">...</span>)</span></pre><p name="d3b4" id="d3b4" class="graf graf--p graf-after--pre">How are you going to abstract this using gateway shit? And wtf do you think you need to do that? Because some tutorial drew some circles?</p><p name="f81b" id="f81b" class="graf graf--p graf-after--p">Now it’s my turn for advertisement. <strong class="markup--strong markup--p-strong">Effin Architecture</strong> provides following benefits:</p><ol class="postList"><li name="06f1" id="06f1" class="graf graf--li graf-after--p">It avoids code duplication.</li><li name="640e" id="640e" class="graf graf--li graf-after--li">It improves readibility by removing most of the redundant shit.</li><li name="6701" id="6701" class="graf graf--li graf-after--li">It improves testability.</li></ol><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="kotlin" name="531a" id="531a" class="graf graf--pre graf-after--li graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>: <span class="hljs-type">Reader</span> {<br />  <span class="hljs-comment">// default functions are what you test</span><br />  <span class="hljs-comment">// property requirements are what you mock</span><br />}</span></pre><p name="0d05" id="0d05" class="graf graf--p graf-after--pre">4. It avoids small dummy classes by allowing you to pool together relevant functions.</p><blockquote name="e503" id="e503" class="graf graf--blockquote graf-after--p">So that’s it, then? That’s the secret, grand adventure of the infamous Jack Sparrow. You spent three days lying on a beach drinking rum.</blockquote><p name="0cbe" id="0cbe" class="graf graf--p graf-after--blockquote">Yes. And Android devs are still creating repository after that three days.</p><figure name="4f0f" id="4f0f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*FWUaLD3kD3wrRcNPFnsLow.png" data-width="491" data-height="198" src="https://cdn-images-1.medium.com/max/800/1*FWUaLD3kD3wrRcNPFnsLow.png"><figcaption class="imageCaption">So it would seem?</figcaption></figure><h4 name="0aa4" id="0aa4" class="graf graf--h4 graf-after--figure">Drink up, me hearties, yo ho!</h4><blockquote name="177d" id="177d" class="graf graf--blockquote graf-after--h4">Honestly. It’s the <strong class="markup--strong markup--blockquote-strong">clean </strong>ones you want to watch out for, because you can never predict when they’re going to do something incredibly… <strong class="markup--strong markup--blockquote-strong">stupid</strong>.</blockquote><p name="71ff" id="71ff" class="graf graf--p graf-after--blockquote">Unlike Clean Architecture, which offers no comparison, we’ve been comparing with official Android architecture guide all this time. E.g.;</p><figure name="ff1d" id="ff1d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*fZA-Kv3VZpaZuJmt0xgu9w.png" data-width="1160" data-height="1014" src="https://cdn-images-1.medium.com/max/800/1*fZA-Kv3VZpaZuJmt0xgu9w.png"><figcaption class="imageCaption">Straight from Android developers official</figcaption></figure><p name="ad6e" id="ad6e" class="graf graf--p graf-after--figure">I know you have doubts about dependency. If Google devs think it’s the best practice, who am I to say otherwise?</p><p name="9e68" id="9e68" class="graf graf--p graf-after--p">Look at this example that says</p><blockquote name="395f" id="395f" class="graf graf--blockquote graf-after--p"><code class="markup--code markup--blockquote-code">Car</code> and <code class="markup--code markup--blockquote-code">Engine</code> are tightly coupled</blockquote><p name="4a42" id="4a42" class="graf graf--p graf-after--blockquote">But the question you ought to ask is, do you need to initialize <code class="markup--code markup--p-code">var engine</code> <strong class="markup--strong markup--p-strong">by design</strong>? E.g.; you want to create a car with an engine of your choice.</p><p name="5da5" id="5da5" class="graf graf--p graf-after--p">If yes, you don’t need to work backwards and detect some “tight coupling”. You initialize it by design.</p><p name="e4ae" id="e4ae" class="graf graf--p graf-after--p">If not, then what does a default value mean by design?</p><p name="25f7" id="25f7" class="graf graf--p graf-after--p">The point I want to make is that these DI discussions ignore real design considerations. They work backwards on artificial examples. In other words, doing design pattern for the sake of doing design pattern.</p><p name="9d38" id="9d38" class="graf graf--p graf-after--p">In <strong class="markup--strong markup--p-strong">Effin Architecture</strong>, we start with <strong class="markup--strong markup--p-strong">functions</strong>. We don’t start with mutable model type and the intent of using polymorphism.</p><p name="a1df" id="a1df" class="graf graf--p graf-after--p">In this case, we’d probably start with</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="73e4" id="73e4" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">func</span> <span class="hljs-title function_">evStart</span>()<br /><span class="hljs-keyword">func</span> <span class="hljs-title function_">gasStart</span>()<br /><span class="hljs-comment">// or closure if needed</span></span></pre><p name="f291" id="f291" class="graf graf--p graf-after--pre">What dependency?</p><p name="6fa6" id="6fa6" class="graf graf--p graf-after--p">Of course this DI shit is then followed by advertisement:</p><figure name="e423" id="e423" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*I487Dr_lGb8lZNPrTyrE_Q.png" data-width="591" data-height="513" src="https://cdn-images-1.medium.com/max/800/1*I487Dr_lGb8lZNPrTyrE_Q.png"></figure><p name="7c9a" id="7c9a" class="graf graf--p graf-after--figure">I don’t know why people acting like <strong class="markup--strong markup--p-strong">CONFIGURATION</strong> is no longer a thing. E.g.;</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="9a2e" id="9a2e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> {<br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">changeEngine</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">newEngine</span>: <span class="hljs-type">Engine</span>) {<span class="hljs-operator">...</span>} <br />}</span></pre><p name="3fb7" id="3fb7" class="graf graf--p graf-after--pre">WTF do you do every shit via initializer? And guess what? If you <strong class="markup--strong markup--p-strong">DESIGN IT</strong> to initialize with an engine, the same thing applies. None of these shit are due to DI. E.g.;</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="f64d" id="f64d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> {<br />  <span class="hljs-keyword">var</span> engine <span class="hljs-operator">=</span> <span class="hljs-type">Electric</span>()      <span class="hljs-comment">// default BY DESIGN</span><br />}</span></pre><p name="5f26" id="5f26" class="graf graf--p graf-after--pre">Reusability: you can pass in different implementations of <code class="markup--code markup--p-code">Engine</code> to <code class="markup--code markup--p-code">Car</code> .</p><p name="e772" id="e772" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">car.engine = Gas()</code></p><p name="639e" id="639e" class="graf graf--p graf-after--p">Easy testing of <code class="markup--code markup--p-code">Car</code> . You can pass in test doubles. <code class="markup--code markup--p-code">car.engine = mock1; car.engine = mock2</code> .</p><p name="5ef9" id="5ef9" class="graf graf--p graf-after--p">None of these use initializer, which is why we don’t give a shit about dependency and use default initializer only.</p><p name="07fb" id="07fb" class="graf graf--p graf-after--p">OK. Let’s wrap up.</p><h4 name="e808" id="e808" class="graf graf--h4 graf-after--p">Can you sail under the command of a pirate? Or can you not?</h4><p name="87aa" id="87aa" class="graf graf--p graf-after--h4">The most shocking thing of all these, is not that Google devs built a over-generalization SDK; not that Clean Architecture is built on false assumptions.</p><p name="ca39" id="ca39" class="graf graf--p graf-after--p">The most shocking thing is… I’m not the first one to discover all these.</p><p name="1dac" id="1dac" class="graf graf--p graf-after--p">I learned it from Swift SDK. Somebody in Apple knew this a decade ago, and was able to make it official SDK and first POP language. Apart from Combine dumb shit, it is basically what I’d do. But they released async-await to amend that. It is very powerful… if you know how to use it.</p><p name="85a8" id="85a8" class="graf graf--p graf-after--p">I’m writing this to be part of the history. I’m expecting people to reference <strong class="markup--strong markup--p-strong">Effin Architecture </strong>whenever they are pumping stupid shit two decades from now.</p><p name="20df" id="20df" class="graf graf--p graf-after--p">People will say, that <strong class="markup--strong markup--p-strong">Effin Architecture</strong> first proposed in some meme post. Oh btw don’t address me as <em class="markup--em markup--p-em">Uncle</em>. Call me Y<em class="markup--em markup--p-em">our Eminence</em>.</p><p name="f537" id="f537" class="graf graf--p graf-after--p">Even if it’s not me, some dude will eventually overthrown Clean Architecture, and I get to share the credit because I left proof on Internet.</p><p name="3cd0" id="3cd0" class="graf graf--p graf-after--p">Might provide more in-depth examples if I can find something to compare against. But hey, feel free to do it yourself as an exercise.</p><p name="7154" id="7154" class="graf graf--p graf-after--p">Tortuga?</p><figure name="ce64" id="ce64" class="graf graf--figure graf-after--p graf--trailing"><img class="graf-image" data-image-id="1*R-Df0F-FkAB_ZzpbIHASOQ.png" data-width="607" data-height="246" src="https://cdn-images-1.medium.com/max/800/1*R-Df0F-FkAB_ZzpbIHASOQ.png"></figure></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/85293b49c3ac"><time class="dt-published" datetime="2023-04-02T11:05:36.906Z">April 2, 2023</time></a>.</p><p><a href="https://medium.com/@swift2931/effin-architecture-85293b49c3ac" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>