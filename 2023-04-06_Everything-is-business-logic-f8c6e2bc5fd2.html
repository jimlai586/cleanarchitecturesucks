<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Everything is business logic</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Everything is business logic</h1>
</header>
<section data-field="subtitle" class="p-summary">
The nonsensical “business logic” that drives MVVM
</section>
<section data-field="body" class="e-content">
<section name="e161" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="d88b" id="d88b" class="graf graf--h3 graf--leading graf--title">Everything is business logic</h3><h4 name="8c6a" id="8c6a" class="graf graf--h4 graf-after--h3 graf--subtitle">The nonsensical “business logic” that drives MVVM</h4><figure name="f8ef" id="f8ef" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*MIwqVFy-rVWCH3BIvnrmDg.png" data-width="599" data-height="258" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*MIwqVFy-rVWCH3BIvnrmDg.png"></figure><blockquote name="524c" id="524c" class="graf graf--blockquote graf-after--figure">INDIANA: The hell you will. He’s got a two-day head start on you, which is more than he needs. Brody’s got friends in every town and village from here to the Sudan. He speaks a dozen languages, knows every local custom. He’ll blend in, disappear; you’ll never see him again. With any luck, he’s got the Grail already.</blockquote><h4 name="f00d" id="f00d" class="graf graf--h4 graf-after--blockquote">Does anyone here speak English?</h4><p name="f9c0" id="f9c0" class="graf graf--p graf-after--h4">In my <a href="https://swift2931.medium.com/effin-architecture-85293b49c3ac" data-href="https://swift2931.medium.com/effin-architecture-85293b49c3ac" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">post </a>a couple days ago, I mentioned the 4 characteristics of Clean Architecture:</p><ol class="postList"><li name="a464" id="a464" class="graf graf--li graf-after--p">View model monkey</li><li name="719f" id="719f" class="graf graf--li graf-after--li">Injection idiot</li><li name="b75a" id="b75a" class="graf graf--li graf-after--li">TDD titan</li><li name="ba18" id="ba18" class="graf graf--li graf-after--li">Brute force boilerplate</li></ol><p name="5eb5" id="5eb5" class="graf graf--p graf-after--li">Now, thanks to our friend at <em class="markup--em markup--p-em">Better Programming</em>, who kindly provides us a living example titled <a href="https://betterprogramming.pub/different-flavors-of-unidirectional-architectures-in-swift-781a01380ef6" data-href="https://betterprogramming.pub/different-flavors-of-unidirectional-architectures-in-swift-781a01380ef6" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">The Many Flavors of Unidirectional Architectures in Swift</a>.</p><p name="7ba8" id="7ba8" class="graf graf--p graf-after--p">I’m going to show you how, a senior iOS dev that is a <em class="markup--em markup--p-em">Better Programming</em> contributor, who got 7 years of head start, who knows a dozen languages, knows every design pattern, made the most basic mistakes.</p><p name="9f9f" id="9f9f" class="graf graf--p graf-after--p">In particular, I want to touch upon the myth that is <strong class="markup--strong markup--p-strong">Business Logic</strong>.</p><p name="5794" id="5794" class="graf graf--p graf-after--p">And yes, I’m on the crusade of destroying the dumb shit that is MVVM. Everything MVVM touches turned to shit.</p><h4 name="78ed" id="78ed" class="graf graf--h4 graf-after--p">The last crusade</h4><p name="2241" id="2241" class="graf graf--p graf-after--h4">It’s interesting to see how MVVM devs respond to the current trend of “you’ve been doing MVVM wrong”. So I’m gonna comment paragrap hby paragraph.</p><blockquote name="4891" id="4891" class="graf graf--blockquote graf-after--p">But first, let’s talk about some recent conversations in the iOS community regarding MVVM and whether it is a good fit for SwiftUI. <strong class="markup--strong markup--blockquote-strong">The premise is that “the View is the view model” already, so MVVM is unnecessary.</strong></blockquote><p name="5ac5" id="5ac5" class="graf graf--p graf-after--blockquote">That is not correct. You don’t have “the View” in tradition UIView sense.</p><p name="c3a9" id="c3a9" class="graf graf--p graf-after--p">Let me ask you, does your “view” have view properties like background color in SwiftUI?</p><p name="fbf7" id="fbf7" class="graf graf--p graf-after--p">No. And that is a fact. So the first thing we do in our discussion is remove “View” from the picture.</p><p name="7f38" id="7f38" class="graf graf--p graf-after--p">You have a “model” that conforms to <code class="markup--code markup--p-code">View</code> protocol .This invalidates the paradigm upon which MVVM built. In fact it invalidates <em class="markup--em markup--p-em">every</em> paradigm.</p><p name="4779" id="4779" class="graf graf--p graf-after--p">Something <strong class="markup--strong markup--p-strong">NEW </strong>has to be built.</p><p name="c661" id="c661" class="graf graf--p graf-after--p">On the other hand, what is “view model” exactly? It can contain from “business logic” to “everything”; And “business logic” is whatever you say it is. So the sentence <strong class="markup--strong markup--p-strong">“the View is the view model” </strong>means “the non-existent thing is the arbitrary thing”. You’d think programmers are experts in logic.</p><blockquote name="fe6b" id="fe6b" class="graf graf--blockquote graf-after--p">I disagree with that premise. While it’s true that SwiftUI already has built-in primitives (in the form of property wrappers) to simplify a lot of the glue code around state observation and re-rendering, <strong class="markup--strong markup--blockquote-strong">the view is just a declarative description of how the view layer looks like</strong>. A view model is so much more than that. It’s the place where the view-related business logic lives.</blockquote><p name="dc90" id="dc90" class="graf graf--p graf-after--blockquote">Let’s for the sake of argument assume that you can build around “the view” in UIView sense instead of model, like he is about to do. If you can make it work, hey, by all means.</p><p name="f682" id="f682" class="graf graf--p graf-after--p">Funny he mentioned that &quot;It’s the place where the <strong class="markup--strong markup--p-strong">view-related</strong> business logic lives&quot;. Wouldn’t it make more sense that view-related stuff live <strong class="markup--strong markup--p-strong">within </strong>the view? So you save time without moving stuff back and forth, in and out?</p><p name="f53d" id="f53d" class="graf graf--p graf-after--p">And since they are <strong class="markup--strong markup--p-strong">view-related</strong>, they are <strong class="markup--strong markup--p-strong">coupled</strong>. It doesn’t matter where you move them, you have to connect, i.e.; <em class="markup--em markup--p-em">bind </em>them one way or another. Let’s see his reasoning:</p><blockquote name="4cd1" id="4cd1" class="graf graf--blockquote graf-after--p">But let’s start with the right question. <strong class="markup--strong markup--blockquote-strong">Why would we want to move code out of the view layer?</strong> Without entering in (sometimes subjective) debates about responsibilities and how software should be split, there’s something clear: <strong class="markup--strong markup--blockquote-strong">unless we move the code out of the view layer, it will be complicated to unit test</strong>. But where should we put that code?</blockquote><p name="7462" id="7462" class="graf graf--p graf-after--blockquote">I hope you have <strong class="markup--strong markup--p-strong">TDD TITAN</strong> on your bingo card. He just swept the view-related questions under the rug and moved on to do test.</p><p name="e2a9" id="e2a9" class="graf graf--p graf-after--p">These are such basic concepts that TDD titans got wrong. The difficulty of test depends largely on the quality of your functions, e.g.; side effects, hidden states… etc. <strong class="markup--strong markup--p-strong">And ease of test does NOT equal to quality of test</strong>. You can write dummy tests all day long. None of these TDD titans will teach you how to write effective tests. I’ve reviewed some of the test examples they provided myself, and they are <strong class="markup--strong markup--p-strong">SHIT</strong>. Most commonly they use brute force to generate mock data, i.e.; instead of variables, they use <em class="markup--em markup--p-em">classes via cumbersome injection.</em></p><p name="b48e" id="b48e" class="graf graf--p graf-after--p">On the other hand, is creating a sink object always easier to test? Not really. You need comparison. And where is this comparison? I challenge you to find one on Internet.</p><blockquote name="2cee" id="2cee" class="graf graf--blockquote graf-after--p">In all these scenarios, a view model makes a lot of sense. It makes sense because it bundles essential business logic, which is only important for that view. <strong class="markup--strong markup--blockquote-strong">Moving this view-specific business logic to a domain model will likely make it less cohesive and, eventually, the wrong abstraction.</strong></blockquote><p name="0068" id="0068" class="graf graf--p graf-after--blockquote">Note that he never bothered to define what “<strong class="markup--strong markup--p-strong">business logic</strong>” is. So by <em class="markup--em markup--p-em">bundling </em>he actually meant <em class="markup--em markup--p-em">sinking</em>. Instead of having one sink object for many “views”, he is going to have one sink object for every “view”. Where do you thnk all the shit-y “massive view controller” devs go? They became MVVM devs.</p><p name="4379" id="4379" class="graf graf--p graf-after--p">So this is his core defense. <em class="markup--em markup--p-em">Less cohesive</em>… and a link to another article.</p><p name="c1ce" id="c1ce" class="graf graf--p graf-after--p">Does anyone speak English?</p><p name="5fac" id="5fac" class="graf graf--p graf-after--p">Is this “domain model” the same “model” I’m refering to? Because that’s not what that “model” is about. Are you confused yet?</p><p name="fafb" id="fafb" class="graf graf--p graf-after--p">There are three things here. View-specific business logic, domain model, and <code class="markup--code markup--p-code">struct Model: View</code> .</p><p name="aa84" id="aa84" class="graf graf--p graf-after--p">Up to this point, he had been referring to <code class="markup--code markup--p-code">struct Model: View</code> , but then a domain model popped up. So the discussion is off track. If domain model is anything like domain layer, e.g.; use case in Android, then it’s not what I meant by <code class="markup--code markup--p-code">struct Model: View</code> . Let’s see if we can get more info.</p><blockquote name="f55f" id="f55f" class="graf graf--blockquote graf-after--p">Ultimately, <strong class="markup--strong markup--blockquote-strong">it’s just a matter of moving business logic out of the view in a place where it makes sense, guided by cohesion and coupling principles</strong> (or SOLID principles in general), so it can be easily testable.</blockquote><blockquote name="0d63" id="0d63" class="graf graf--blockquote graf-after--blockquote">Finally, I wonder why the best iOS course in the world, Standford’s CS193P, still teaches MVVM as the main presentation pattern for SwiftUI apps.</blockquote><p name="800d" id="800d" class="graf graf--p graf-after--blockquote">First, best iOS course? I have an <a href="https://swift2931.medium.com/mvvm-but-without-view-model-and-without-view-88bd85c3e4fa" data-href="https://swift2931.medium.com/mvvm-but-without-view-model-and-without-view-88bd85c3e4fa" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">article </a>right here detailing why it’s wrong on basic level.</p><p name="dade" id="dade" class="graf graf--p graf-after--p">Second, you can propose whatever architecture you want. But how do you say it’s good? Only by comparison. Do you offer any comparison?</p><p name="fb3f" id="fb3f" class="graf graf--p graf-after--p">Third, he is assuming that you can only satisfy cohesion and coupling principles by moving things out. Why can’t you satisfy the same by NOT moving things out? SOLID principles are dog shit as I explained in my linked article. So even the <em class="markup--em markup--p-em">cohesion</em> and <em class="markup--em markup--p-em">coupling</em> princles are in question.</p><p name="0b71" id="0b71" class="graf graf--p graf-after--p">He had to rely on outside re-affirmations to support his argument. E.g.;</p><blockquote name="66c1" id="66c1" class="graf graf--blockquote graf-after--p">Also, Apple seems to feel the same way about not using View as the view model</blockquote><p name="67d5" id="67d5" class="graf graf--p graf-after--blockquote">Is it though? Let’s see.</p><figure name="adf2" id="adf2" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*wqZ67jcN9eili-4WUbw8Tg.png" data-width="1760" data-height="1091" src="https://cdn-images-1.medium.com/max/800/1*wqZ67jcN9eili-4WUbw8Tg.png"></figure><p name="4b3c" id="4b3c" class="graf graf--p graf-after--figure">It depends on what you think a <code class="markup--code markup--p-code">ViewModel</code> should do.</p><p name="1732" id="1732" class="graf graf--p graf-after--p">This Apple engineer&#39;s major argument is that it makes “the view” less reusable by tying “business logic” to SwiftUI “views”.</p><p name="19ad" id="19ad" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“Views” aside, because we want to emphasize that we work on “model” that conforms to <code class="markup--code markup--p-code">View</code> instead of traditional “views”, <strong class="markup--strong markup--p-strong">why are people assuming we won’t be able to refactor out anything if needed</strong>?</p><p name="888e" id="888e" class="graf graf--p graf-after--p">Why is “view model” de facto way to refactor? Or test. Or anything. Quite the contrary, the people who can’t refactor are often MVVM devs, because they have a sink object for every “view”.</p><p name="e82d" id="e82d" class="graf graf--p graf-after--p">This Apple guy is careful with his words by saying “that <strong class="markup--strong markup--p-strong">could</strong> have consequences”. <code class="markup--code markup--p-code">struct Model: View</code> is NOT another way to do MVVM, because immutable value type puts a severe restriction on state changes, and MVVM is all about implicit changes on mutable model. In fact it all but hints that you should <em class="markup--em markup--p-em">refactor out control</em>, as we’ll see later. You need a completely different mind set when working with SwiftUI. It’s not even OOP. Why do you insist on doing things the old way?</p><p name="3226" id="3226" class="graf graf--p graf-after--p">The mis-conceptions here are that <code class="markup--code markup--p-code">struct Model: View</code> is the new view model, and that you somehow could “couple” stuff with view. Do you remember the question earlier? When I say</p><blockquote name="9a5e" id="9a5e" class="graf graf--pullquote graf-after--p">And since they are <strong class="markup--strong markup--pullquote-strong">view-related</strong>, they are <strong class="markup--strong markup--pullquote-strong">coupled</strong>. It doesn’t matter where you move them, you have to connect, i.e.; <em class="markup--em markup--pullquote-em">bind </em>them one way or another.</blockquote><p name="75ff" id="75ff" class="graf graf--p graf-after--pullquote">This is the <strong class="markup--strong markup--p-strong">magic </strong>understanding of MVVM. If you put the same stuff outside, then they are <strong class="markup--strong markup--p-strong">de-coupled</strong> somehow. But if you put it all inside (which is not the case, we can refactor), they are <strong class="markup--strong markup--p-strong">coupled</strong>. The stuff is the same!</p><p name="b6a4" id="b6a4" class="graf graf--p graf-after--p">Your counter-argument will be that “but I want to reuse some stuff without creating a view”.</p><p name="3c13" id="3c13" class="graf graf--p graf-after--p">So refactor it out. What’s stopping you? The difference between @StateObject and @ObservedObject is that one is shared. If you want something to be shared, then share it!</p><p name="2e95" id="2e95" class="graf graf--p graf-after--p">And if you think about it. You are not creating a view. “The view” is in <code class="markup--code markup--p-code">var body: some View</code> , a <em class="markup--em markup--p-em">computed </em>property. You are creating a model, that can be used to render “view”. That’s why we keep highlighting this fact. It changes <em class="markup--em markup--p-em">every </em>paradigm. You should have the confidence to create a value type without worrying about side effects or someone else could mutate it. If you put too much side effect in initializer, MVVM will not save you either; If anything, it exposes the problems of MVVM that you overlooked all these years.</p><h4 name="4afd" id="4afd" class="graf graf--h4 graf-after--p">Only the penitent men will pass</h4><figure name="a39c" id="a39c" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*gdtUM256cTT-T-x4HFdCmw.jpeg" data-width="913" data-height="403" src="https://cdn-images-1.medium.com/max/800/1*gdtUM256cTT-T-x4HFdCmw.jpeg"></figure><p name="6a8b" id="6a8b" class="graf graf--p graf-after--figure">What is <strong class="markup--strong markup--p-strong">Business Logic</strong>, really?</p><p name="307e" id="307e" class="graf graf--p graf-after--p">Is JSON parsing to <code class="markup--code markup--p-code">Codable</code> a business logic? Hell, is networking in general business logic? Is “presenter” logic considered as “business logic”?</p><p name="86ce" id="86ce" class="graf graf--p graf-after--p">Do you have refactor in mind when you dump everything to view model?</p><p name="c85c" id="c85c" class="graf graf--p graf-after--p">The efforts you put in are</p><p name="29ff" id="29ff" class="graf graf--p graf-after--p">a. create an object</p><p name="14b8" id="14b8" class="graf graf--p graf-after--p">b. put everything you can to it</p><p name="4424" id="4424" class="graf graf--p graf-after--p">Then it’s testable, reusable, … and 1000 other benefits. And you get to lecture people about coupling shit together and tying “business logic” to “view”. This is the beauty of MVVM. You don’t actually learn anything about refactor.</p><p name="7f6f" id="7f6f" class="graf graf--p graf-after--p">Let me show you another side of story.</p><p name="ee6b" id="ee6b" class="graf graf--p graf-after--p">What if we don’t give a shit about “business logic”?</p><p name="2ba9" id="2ba9" class="graf graf--p graf-after--p">All we care about is refactor or not; to share something or not; to provide a service or not, and what its scope should be.</p><p name="ce0f" id="ce0f" class="graf graf--p graf-after--p">We don’t give a shit about abstract terms like ViewModel, business logic, single responsibility, <em class="markup--em markup--p-em">cohesive,</em> … etc.</p><p name="cfd3" id="cfd3" class="graf graf--p graf-after--p">Say I want to refactor out networking.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="c422" id="c422" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Model</span>: <span class="hljs-title class_">View</span> {<br />  <span class="hljs-meta">@ObservedObject</span> <span class="hljs-keyword">var</span> api <span class="hljs-operator">=</span> <span class="hljs-type">NetworkService</span>()<br />  <span class="hljs-comment">// api.fetch(...)</span><br />}</span></pre><p name="4f2e" id="4f2e" class="graf graf--p graf-after--pre">Are we tying “business logic” to “view”?</p><p name="18f7" id="18f7" class="graf graf--p graf-after--p">Compare to this:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="less" name="e3d7" id="e3d7" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-selector-tag">struct</span> <span class="hljs-selector-tag">GrailView</span>: <span class="hljs-selector-tag">View</span> {<br />  <span class="hljs-variable">@ObservedObject</span> var vm = <span class="hljs-built_in">ViewModel</span>()<br />  <span class="hljs-comment">// vm.api.fetch(...)</span><br />}</span></pre><p name="31e0" id="31e0" class="graf graf--p graf-after--pre">Now from MVVM we <em class="markup--em markup--p-em">know</em> this is NOT coupled to “view”, which is the same thing as above with a name change. So why would you think we would be “tying business logic” to “view”. Quotation marks are there to remind you that we are working under MVVM logic for the sake of argument.</p><p name="2eca" id="2eca" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">This is the <em class="markup--em markup--p-em">holy grail </em>of every tutorial seller. </strong>A fking name change that automatically gives you 1000+ benefits.</p><p name="1259" id="1259" class="graf graf--p graf-after--p">Note that your <code class="markup--code markup--p-code">fetch</code> call is now nested. You have to call it via <code class="markup--code markup--p-code">vm</code> . MVVM will tell you it’s a feature not a bug. Some idiots will even add wrappers to make it look more clean. e.g.; <code class="markup--code markup--p-code">vm.fetch() // which calls api.fetch()</code> .</p><p name="0e1f" id="0e1f" class="graf graf--p graf-after--p">So what are you really providing? A wrapper that contains every service you used? Why can’t I just create or reference the service I need? What if I only want <em class="markup--em markup--p-em">some</em> of which. You shouldn’t need complex intialization to wrap with in the first place unless you are an <em class="markup--em markup--p-em">injection idiot</em>.</p><p name="0730" id="0730" class="graf graf--p graf-after--p">You may argue that “but it won’t be just simple function call, it could be complex chain of operations”.</p><p name="e3b3" id="e3b3" class="graf graf--p graf-after--p">That’s why I ask if you have the refactor in mind at the beginning. Use protocols to refactor it out. Hell, you could create some library functions in an environment object for all I care. None of these need to tie with a specific aggregate object.</p><p name="c6be" id="c6be" class="graf graf--p graf-after--p">I’ve seen MVVM devs times and times again, trying to transport data from environment object to view model, because you don’t access to view model in external observable. Why? @EnvrionmentObject has the same shared scope as @ObservableObject. But somehow you are afraid to use envrionment object directly. There is also no reason you can’t have multiple observables.</p><p name="8e43" id="8e43" class="graf graf--p graf-after--p">It all comes down to comparison. None of these matter if your approach is more <em class="markup--em markup--p-em">efficient</em>. But is it? All evidence to the contrary. (source: I’m the largest SwiftUI MVVM code reviewer you can find) Hey, don’t take my words for it. Make your own comparison.</p><p name="9208" id="9208" class="graf graf--p graf-after--p">SwiftUI is the “breath of God” in <em class="markup--em markup--p-em">Indiana Jones: the last crusade</em>.</p><p name="5c14" id="5c14" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Only the penitent men will pass</strong>. Why? Because value type changes every thing; because <code class="markup--code markup--p-code">struct Model: View</code> changes everything; because it builds around protocol composition / extension and it changes everything.</p><p name="cd3c" id="cd3c" class="graf graf--p graf-after--p">Kneel!</p><h4 name="b2fa" id="b2fa" class="graf graf--h4 graf-after--p">The word of God</h4><figure name="8c50" id="8c50" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*7IMtIb8W_kQhkSyMbrDm4w.jpeg" data-width="730" data-height="405" src="https://cdn-images-1.medium.com/max/800/1*7IMtIb8W_kQhkSyMbrDm4w.jpeg"></figure><p name="4b26" id="4b26" class="graf graf--p graf-after--figure">Basically he wants to build a Redux-ViewModel-TCA mixed architecture.</p><p name="4b15" id="4b15" class="graf graf--p graf-after--p">Let’s skip to his end results.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="dc0c" id="dc0c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">import</span> Foundation<br /><br /><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">APIClient</span> {<br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">numbers</span>() <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> -&gt; [<span class="hljs-type">Int</span>] {<br />        <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> <span class="hljs-type">Task</span>.sleep(nanoseconds: <span class="hljs-number">1</span> <span class="hljs-operator">*</span> <span class="hljs-type">NSEC_PER_SEC</span>)<br />        <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br />    }<br />}<br /><br /><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NumbersViewReducer</span>: <span class="hljs-title class_">Reducer</span> {<br />    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span>: <span class="hljs-title class_">Equatable</span> {<br />        <span class="hljs-keyword">case</span> idle<br />        <span class="hljs-keyword">case</span> loading<br />        <span class="hljs-keyword">case</span> loaded([<span class="hljs-type">Int</span>])<br />        <span class="hljs-keyword">case</span> error<br />    }<br /><br />    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Input</span> {<br />        <span class="hljs-keyword">case</span> onAppear<br />    }<br /><br />    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Feedback</span> {<br />        <span class="hljs-keyword">case</span> numbersDownloaded(<span class="hljs-type">Result</span>&lt;[<span class="hljs-type">Int</span>], <span class="hljs-type">Error</span>&gt;)<br />    }<br /><br />    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Output</span> {<br />        <span class="hljs-keyword">case</span> numbersDownloaded<br />    }<br /><br />    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> apiClient <span class="hljs-operator">=</span> <span class="hljs-type">APIClient</span>()<br /><br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">reduce</span>(<span class="hljs-params">message</span>: <span class="hljs-type">Message</span>&lt;<span class="hljs-type">Input</span>, <span class="hljs-type">Feedback</span>&gt;, <span class="hljs-params">into</span> <span class="hljs-params">state</span>: <span class="hljs-keyword">inout</span> <span class="hljs-type">State</span>) -&gt; <span class="hljs-type">Effect</span>&lt;<span class="hljs-type">Feedback</span>, <span class="hljs-type">Output</span>&gt; {<br />        <span class="hljs-keyword">switch</span> message {<br />        <span class="hljs-keyword">case</span> .input(.onAppear):<br />            state <span class="hljs-operator">=</span> .loading<br />            <span class="hljs-keyword">return</span> .run { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] send <span class="hljs-keyword">in</span><br />                <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword">self</span> <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }<br /><br />                <span class="hljs-keyword">do</span> {<br />                    <span class="hljs-keyword">let</span> numbers <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> apiClient.numbers()<br />                    <span class="hljs-keyword">await</span> send(.numbersDownloaded(.success(numbers)))<br />                } <span class="hljs-keyword">catch</span> {<br />                    <span class="hljs-keyword">await</span> send(.numbersDownloaded(.failure(error)))<br />                }<br />            }<br /><br />        <span class="hljs-keyword">case</span> .feedback(.numbersDownloaded(.success(<span class="hljs-keyword">let</span> values))):<br />            state <span class="hljs-operator">=</span> .loaded(values)<br />            <span class="hljs-keyword">return</span> .output(.numbersDownloaded)<br /><br />        <span class="hljs-keyword">case</span> .feedback(.numbersDownloaded(.failure)):<br />            state <span class="hljs-operator">=</span> .error<br />            <span class="hljs-keyword">return</span> .none<br />        }<br />    }<br />}<br /><br /><span class="hljs-keyword">import</span> SwiftUI<br /><br /><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NumbersListView</span>: <span class="hljs-title class_">View</span> {<br />    <span class="hljs-meta">@StateObject</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> viewModel <span class="hljs-operator">=</span> <span class="hljs-type">Store</span>(<br />        state: <span class="hljs-type">NumbersViewReducer</span>.<span class="hljs-type">State</span>.idle,<br />        reducer: <span class="hljs-type">NumbersViewReducer</span>()<br />    )<br /><br />    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {<br />        <span class="hljs-type">Group</span> {<br />            <span class="hljs-keyword">switch</span> viewModel.state {<br />            <span class="hljs-keyword">case</span> .idle, .loading:<br />                <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;…&quot;</span>)<br /><br />            <span class="hljs-keyword">case</span> .loaded(<span class="hljs-keyword">let</span> values):<br />                <span class="hljs-type">List</span>(values, id: \.<span class="hljs-keyword">self</span>) { value <span class="hljs-keyword">in</span><br />                    <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(value)</span>&quot;</span>)<br />                }<br /><br />            <span class="hljs-keyword">case</span> .error:<br />                <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Some error happened&quot;</span>)<br />            }<br />        }.onAppear {<br />            viewModel.send(.onAppear)<br />        }<br />    }<br />}</span></pre><p name="3e92" id="3e92" class="graf graf--p graf-after--pre">Now, what can we learn from this.</p><p name="a1a6" id="a1a6" class="graf graf--p graf-after--p">This is MVVM <strong class="markup--strong markup--p-strong">NOT </strong>coupling with specific view:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="fe8d" id="fe8d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-meta">@StateObject</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> viewModel <span class="hljs-operator">=</span> <span class="hljs-type">Store</span>(<br />        state: <span class="hljs-type">NumbersViewReducer</span>.<span class="hljs-type">State</span>.idle,<br />        reducer: <span class="hljs-type">NumbersViewReducer</span>()<br />    )</span></pre><p name="41e3" id="41e3" class="graf graf--p graf-after--pre">This is MVVM <strong class="markup--strong markup--p-strong">NOT </strong>nesting simple <code class="markup--code markup--p-code">fetch</code> that can otherwise be easiliy refactored:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="8629" id="8629" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">// call site</span><br /><span class="hljs-type">Store</span>(<br />        state: <span class="hljs-type">NumbersViewReducer</span>.<span class="hljs-type">State</span>.idle,<br />        reducer: <span class="hljs-type">NumbersViewReducer</span>()<br />    )<br /><span class="hljs-comment">// initializer</span><br />    <span class="hljs-keyword">init</span>(<br />        <span class="hljs-params">state</span>: <span class="hljs-type">State</span>,<br />        <span class="hljs-params">reducer</span>: <span class="hljs-keyword">some</span> <span class="hljs-type">Reducer</span>&lt;<span class="hljs-type">State</span>, <span class="hljs-type">Input</span>, <span class="hljs-type">Feedback</span>, <span class="hljs-type">Output</span>&gt;<br />    ) {<br />        <span class="hljs-keyword">self</span>.state <span class="hljs-operator">=</span> state<br />        <span class="hljs-keyword">self</span>.reducer <span class="hljs-operator">=</span> reducer<br />        stateSubject <span class="hljs-operator">=</span> .<span class="hljs-keyword">init</span>(state)<br />    }<br /><span class="hljs-comment">// reducer</span><br /><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NumbersViewReducer</span>: <span class="hljs-title class_">Reducer</span> {<br />    <span class="hljs-comment">// ... </span><br /><br />    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> apiClient <span class="hljs-operator">=</span> <span class="hljs-type">APIClient</span>()<br /><br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">reduce</span>(<span class="hljs-params">message</span>: <span class="hljs-type">Message</span>&lt;<span class="hljs-type">Input</span>, <span class="hljs-type">Feedback</span>&gt;, <span class="hljs-params">into</span> <span class="hljs-params">state</span>: <span class="hljs-keyword">inout</span> <span class="hljs-type">State</span>) -&gt; <span class="hljs-type">Effect</span>&lt;<span class="hljs-type">Feedback</span>, <span class="hljs-type">Output</span>&gt; {<br />        <span class="hljs-keyword">switch</span> message {<br />        <span class="hljs-keyword">case</span> .input(.onAppear):<br />            state <span class="hljs-operator">=</span> .loading<br />            <span class="hljs-keyword">return</span> .run { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] send <span class="hljs-keyword">in</span><br />                <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword">self</span> <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }<br /><br />                <span class="hljs-keyword">do</span> {<br />     <span class="hljs-keyword">let</span> numbers <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> apiClient.numbers() <span class="hljs-comment">// &lt;--- this is the shit you want to reuse</span><br />                    <span class="hljs-keyword">await</span> send(.numbersDownloaded(.success(numbers)))<br />    <span class="hljs-comment">// ....</span><br />}</span></pre><p name="f090" id="f090" class="graf graf--p graf-after--pre">As compared to</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="6e55" id="6e55" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">let</span> api <span class="hljs-operator">=</span> <span class="hljs-type">NetworkService</span>()<br /><span class="hljs-keyword">_</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> api.numbers()<br /><span class="hljs-comment">// check request state via dedicated network service</span><br /><span class="hljs-keyword">_</span> <span class="hljs-operator">=</span> api.isLoading</span></pre><blockquote name="49eb" id="49eb" class="graf graf--blockquote graf-after--pre">This guy got a 7 year head start on you, which is more than he needs. He got friends in every town and village from here to <strong class="markup--strong markup--blockquote-strong">Better Programming</strong>. He speaks a dozen languages, knows every design pattern. He’ll blend in, disappear; you’ll never see him again. With any luck, he’s got the Grail already.</blockquote><p name="3e72" id="3e72" class="graf graf--p graf-after--blockquote">Oh, I’m sorry. Quoting the wrong things.</p><blockquote name="4d91" id="4d91" class="graf graf--blockquote graf-after--p">All the separation of state management and effects has emerged a lot of new <strong class="markup--strong markup--blockquote-strong">functional paradigms</strong> within the iOS community, with many people already using TCA as their default architecture for any new iOS project with SwiftUI. This is great news and shows the maturity of the iOS ecosystem at this point.</blockquote><p name="eadf" id="eadf" class="graf graf--p graf-after--blockquote">Let me assure you. This is <strong class="markup--strong markup--p-strong">NOT AT ALL</strong> a functional paradigm. I wrote Elm which is a purely a functional language. If anything this shows how dog shit the iOS ecosystem is at this point.</p><p name="35cb" id="35cb" class="graf graf--p graf-after--p">Even without view model, this is a dog shit Redux implementation.</p><p name="a312" id="a312" class="graf graf--p graf-after--p">Most importantly,</p><blockquote name="246e" id="246e" class="graf graf--pullquote graf-after--p">in the latin alphabet jehovah begins with an i</blockquote><p name="fcbf" id="fcbf" class="graf graf--p graf-after--pullquote">If I were to review anything, first thing to see is how he builds <code class="markup--code markup--p-code">NetworkService</code> .</p><p name="5e67" id="5e67" class="graf graf--p graf-after--p">In this case, in the latin alphabet Redux starts with N. <code class="markup--code markup--p-code">NetworkService</code> .</p><p name="dd63" id="dd63" class="graf graf--p graf-after--p">Architecture is not something you build out of thin air. You need to have the most common usage in mind, and build around it. Why re-invent wheel for a reducer that will duplicate network state management in every network request? Refactor it out.</p><p name="afef" id="afef" class="graf graf--p graf-after--p">These are the people lecturing other people about tying up “business logic”.</p><h4 name="1d90" id="1d90" class="graf graf--h4 graf-after--p">The leap of faith</h4><p name="7c54" id="7c54" class="graf graf--p graf-after--h4">Let’s recount.</p><p name="8b63" id="8b63" class="graf graf--p graf-after--p">View model monkey -&gt; check.</p><p name="8d6b" id="8d6b" class="graf graf--p graf-after--p">Injection idiot -&gt; not as severe, but check</p><p name="195c" id="195c" class="graf graf--p graf-after--p">Tdd titan -&gt; check</p><p name="3e79" id="3e79" class="graf graf--p graf-after--p">Brute force boilerplate -&gt; check (from those Input, Output, State, Stream, this is probably a student of Clean Swift)</p><p name="42fe" id="42fe" class="graf graf--p graf-after--p">Reference tons of Clean Architecture, Redux, abstract design principles -&gt; check</p><p name="c020" id="c020" class="graf graf--p graf-after--p">Can’t write a half competent network service -&gt; check</p><p name="e996" id="e996" class="graf graf--p graf-after--p">These are my opinions, of course. Make your own judgement.</p><p name="a8a1" id="a8a1" class="graf graf--p graf-after--p">I’ll give you my take on the business logic. Everything is business logic. Your app is the business. Everything in your app is to build that business.</p><p name="3aa0" id="3aa0" class="graf graf--p graf-after--p">The only guiding principle you need is “what are the things you want to refactor out”. The skill you want to build is to refactor it out in an efficient way. Not dumb shit Clean Architecture way. How do you know if you are doing it right? Boilerplate. That’s why boilerplate is not a feature, it’s a bug.</p><p name="ad58" id="ad58" class="graf graf--p graf-after--p">Take a leap of faith. Forget everything you’ve learned. For newcomers, you don’t have baggages like these MVVM influencers. This is your chance to DESTROY them and make your name.</p><p name="2737" id="2737" class="graf graf--p graf-after--p">I’m doing this to show you that it’s not even hard. Do I use anything beyond basics? At the very least can you look at above code snippet, and say “yeah, this cannot be improved”? E.g.;</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="40e1" id="40e1" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-meta">@MainActor</span><br /><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">StoreType</span>&lt;<span class="hljs-title class_">State</span>, <span class="hljs-title class_">Output</span>&gt;: <span class="hljs-title class_">ObservableObject</span> <span class="hljs-title class_">where</span> <span class="hljs-title class_">State</span>: <span class="hljs-title class_">Equatable</span> {<br />    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">State</span><br />    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Output</span><br />    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">StateStream</span>: <span class="hljs-type">AsyncSequence</span> <span class="hljs-keyword">where</span> <span class="hljs-type">StateStream</span>.<span class="hljs-type">Element</span> <span class="hljs-operator">==</span> <span class="hljs-type">State</span><br />    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">OutputStream</span>: <span class="hljs-type">AsyncSequence</span> <span class="hljs-keyword">where</span> <span class="hljs-type">OutputStream</span>.<span class="hljs-type">Element</span> <span class="hljs-operator">==</span> <span class="hljs-type">Output</span><br /><br />    <span class="hljs-keyword">var</span> stateStream: <span class="hljs-type">StateStream</span> { <span class="hljs-keyword">get</span> }<br />    <span class="hljs-keyword">var</span> outputStream: <span class="hljs-type">OutputStream</span> { <span class="hljs-keyword">get</span> }<br /><br />    <span class="hljs-keyword">var</span> state: <span class="hljs-type">State</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> }<br />}</span></pre><p name="1cf8" id="1cf8" class="graf graf--p graf-after--pre">Really? Let’s compare it to what I come up just top of my head:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="dc20" id="dc20" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Reducer</span> {<br />  <span class="hljs-keyword">var</span> api: <span class="hljs-type">NetworkService</span> {<span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span>}<br />  <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">changeNumbers</span>() <br />}<br /><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Reducer</span> {<br /><span class="hljs-operator">...</span> <span class="hljs-comment">// default impl.</span><br />}</span></pre><p name="1dda" id="1dda" class="graf graf--p graf-after--pre">Where is state? Use existing @State. Where is store? Use local state instead of global state; <code class="markup--code markup--p-code">stuct Model: View</code> where model is your store.</p><p name="98f9" id="98f9" class="graf graf--p graf-after--p">You can’t mutate @State properties without <code class="markup--code markup--p-code">mutating</code> keyword, so basically everything marked with <code class="markup--code markup--p-code">mutating</code> is a reducer.</p><p name="2d8c" id="2d8c" class="graf graf--p graf-after--p">What’s input, output, state type? No need. Use Swift’s strict type system and type inference.</p><p name="c68d" id="c68d" class="graf graf--p graf-after--p">Where’s stream? No need. Encapsulate networking details. Delegate it to dedicated service.</p><p name="8fdb" id="8fdb" class="graf graf--p graf-after--p">With all these gone, you don’t need generics, which simplifies your design.</p><p name="aa75" id="aa75" class="graf graf--p graf-after--p">I’m writing this on the fly. So obviously there are details you need to fill in, problems you need to handle.</p><p name="dd16" id="dd16" class="graf graf--p graf-after--p">The point I want to make is that, learn SDK, learn refactor, learn to design simple architecture that speeds up most common usage. Design to work with your services, meaning you have to design a robust / configurable service first.</p><h4 name="7920" id="7920" class="graf graf--h4 graf-after--p">You have chosen… wisely</h4><p name="a7bc" id="a7bc" class="graf graf--p graf-after--h4">If for some reason you are still reading. You have chosen wisely.</p><p name="8197" id="8197" class="graf graf--p graf-after--p">The holy grail is not the shiny one that says Clean Architecture + MVVM with coordinator. The only word missing is flawless.</p><p name="2293" id="2293" class="graf graf--p graf-after--p">The holy grail is the basic looking one. Learn to solve problem efficiently.</p><p name="dbdc" id="dbdc" class="graf graf--p graf-after--p">Things I say here I do it in the first project. And things I learned from Swift someone built it into language feature a decade ago.</p><p name="9a13" id="9a13" class="graf graf--p graf-after--p">This should give you an indicator how far you are falling behind.</p><p name="3b45" id="3b45" class="graf graf--p graf-after--p">Since this guy doesn’t really apply Clean Architecture all that much, I can’t really apply my <strong class="markup--strong markup--p-strong">Effin Architecture</strong> in more details. But hey, take a leap of faith.</p><p name="f219" id="f219" class="graf graf--p graf-after--p graf--trailing">Be patient. I believe that <em class="markup--em markup--p-em">Better Programming</em> will provide whatever anti-pattern example we need in no time.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/f8c6e2bc5fd2"><time class="dt-published" datetime="2023-04-06T10:27:20.969Z">April 6, 2023</time></a>.</p><p><a href="https://medium.com/@swift2931/everything-is-business-logic-f8c6e2bc5fd2" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>