<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>SwiftUI unit test without MVVM</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">SwiftUI unit test without MVVM</h1>
</header>
<section data-field="subtitle" class="p-summary">
What if there’s no view
</section>
<section data-field="body" class="e-content">
<section name="0f9c" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="6479" id="6479" class="graf graf--h3 graf--leading graf--title">SwiftUI unit test without MVVM</h3><h4 name="aca0" id="aca0" class="graf graf--h4 graf-after--h3 graf--subtitle">What if there’s no view</h4><figure name="3e43" id="3e43" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*AxxmcPtmYtXBJbiPF7rTrQ.jpeg" data-width="500" data-height="622" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*AxxmcPtmYtXBJbiPF7rTrQ.jpeg"></figure><h4 name="8883" id="8883" class="graf graf--h4 graf-after--figure">What about testing?</h4><p name="c5ef" id="c5ef" class="graf graf--p graf-after--h4">Every MVVM dev asks this question as if they were TDD titans.</p><p name="efc4" id="efc4" class="graf graf--p graf-after--p">Yet the dumbest, most brute-force tests I’ve seen are from these MVVM TDD titans.</p><p name="d73e" id="d73e" class="graf graf--p graf-after--p">At some point they forgot that a good design must come before unit test. If you can’t write highly refactored code, you can’t write highly refactored test, and due to your over-emphasized focus on testing, you will retroactively damage your design to fit your dumb shit test.</p><p name="28fe" id="28fe" class="graf graf--p graf-after--p">I’m going to look at two articles here. One from a recent MVVM unit test tutorial, the other from google top result of SwiftUI unit testing.</p><h4 name="e611" id="e611" class="graf graf--h4 graf-after--p">Is there a REFACTOR in your MVVM + clean architecture + TDD + DI + coordinator?</h4><p name="2694" id="2694" class="graf graf--p graf-after--h4">Saw this <a href="https://medium.com/@brsrld/testable-code-and-unit-testing-in-swiftui-cd454f35b8d0" data-href="https://medium.com/@brsrld/testable-code-and-unit-testing-in-swiftui-cd454f35b8d0" class="markup--anchor markup--p-anchor" target="_blank">“Testable Code and Unit Testing in SwiftUI”</a> on recommended.</p><p name="29c3" id="29c3" class="graf graf--p graf-after--p">What’s the design problem in this snippet?</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="160b" id="160b" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeViewModel</span>: <span class="hljs-title class_">BaseViewModel</span>&lt;<span class="hljs-title class_">HomeViewStates</span>&gt; {<br />    <span class="hljs-keyword">let</span> service: <span class="hljs-type">NewsServiceable</span><br />    <span class="hljs-keyword">var</span> showingAlert: <span class="hljs-type">Bool</span><br />    <br />    <span class="hljs-meta">@Published</span> <span class="hljs-keyword">private(set)</span> <span class="hljs-keyword">var</span> allNews: [<span class="hljs-type">Article</span>]<br />    <br />    <span class="hljs-keyword">init</span>(<span class="hljs-params">service</span>: <span class="hljs-type">NewsServiceable</span>) {<br />        <span class="hljs-keyword">self</span>.service <span class="hljs-operator">=</span> service<br />        <span class="hljs-keyword">self</span>.allNews <span class="hljs-operator">=</span> []<br />        <span class="hljs-keyword">self</span>.showingAlert <span class="hljs-operator">=</span> <span class="hljs-literal">false</span><br />    }<br />    <br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">serviceInitialize</span>() {<br />        fetchNews()<br />    }<br />    <br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">changeStateToEmpty</span>() {<br />        changeState(.empty)<br />    }<br />    <br />    <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">fetchNews</span>() {<br />        changeState(.loading)<br />        <span class="hljs-type">Task</span> { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] <span class="hljs-keyword">in</span><br />            <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword">self</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span> <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }<br />            <span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> <span class="hljs-keyword">await</span> <span class="hljs-keyword">self</span>.service.fetchAllNews(country: .us)<br />            <span class="hljs-keyword">self</span>.changeState(.finished)<br />            <span class="hljs-keyword">switch</span> result {<br />            <span class="hljs-keyword">case</span> .success(<span class="hljs-keyword">let</span> success):<br />                <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> articles <span class="hljs-operator">=</span> success.articles <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }<br />                <span class="hljs-type">DispatchQueue</span>.main.async {<br />                    <span class="hljs-keyword">self</span>.allNews <span class="hljs-operator">=</span> articles<br />                }<br />            <span class="hljs-keyword">case</span> .failure(<span class="hljs-keyword">let</span> failure):<br />                <span class="hljs-keyword">self</span>.changeState(.error(error: failure.customMessage))<br />                <span class="hljs-keyword">self</span>.showingAlert.toggle()<br />            }<br />        }<br />    }<br />}</span></pre><p name="b0dd" id="b0dd" class="graf graf--p graf-after--pre">His fetch call is not refactored. Did you seriously repeat all these for <strong class="markup--strong markup--p-strong">EVERY </strong>endpoint?</p><p name="87be" id="87be" class="graf graf--p graf-after--p">Rename <code class="markup--code markup--p-code">HomeViewModel</code>to <code class="markup--code markup--p-code">NewsAPIService</code> which inherits <code class="markup--code markup--p-code">NetworkService</code> , then it becomes a boilerplate brute force fetcher.</p><p name="026b" id="026b" class="graf graf--p graf-after--p">So what is it that you thnk MVVM is bringing to the table?</p><p name="4bdb" id="4bdb" class="graf graf--p graf-after--p">Oh the unit test of course!</p><h4 name="fe22" id="fe22" class="graf graf--h4 graf-after--p">TDD Titan</h4><p name="cc91" id="cc91" class="graf graf--p graf-after--h4">Let’s see what google top result for “SwiftUI unit test” says about this.</p><p name="f7a0" id="f7a0" class="graf graf--p graf-after--p"><a href="https://www.swiftbysundell.com/articles/writing-testable-code-when-using-swiftui/" data-href="https://www.swiftbysundell.com/articles/writing-testable-code-when-using-swiftui/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Writing testable code when using SwiftUI</a>.</p><p name="8f54" id="8f54" class="graf graf--p graf-after--p">I want to start with this legendary (as in retarded) interpretation from MVVM devs:</p><blockquote name="56ac" id="56ac" class="graf graf--blockquote graf-after--p">… as our view model now contains <strong class="markup--strong markup--blockquote-strong">all of the logic</strong> that our view needs to decide how it should be rendered — making that <strong class="markup--strong markup--blockquote-strong">UI code much simpler</strong> in the process:</blockquote><figure name="ea7d" id="ea7d" class="graf graf--figure graf-after--blockquote"><img class="graf-image" data-image-id="1*K0AofF0ZOfDa6yyS5HNOrQ.png" data-width="1039" data-height="714" src="https://cdn-images-1.medium.com/max/800/1*K0AofF0ZOfDa6yyS5HNOrQ.png"></figure><p name="1860" id="1860" class="graf graf--p graf-after--figure">No. It is <strong class="markup--strong markup--p-strong">NOT</strong>.</p><p name="376c" id="376c" class="graf graf--p graf-after--p">There are two components that are supposed <em class="markup--em markup--p-em">to make UI code much simpler.</em></p><ol class="postList"><li name="e73b" id="e73b" class="graf graf--li graf-after--p">Dumping every property to a sink object called view model.</li><li name="5f20" id="5f20" class="graf graf--li graf-after--li">Use computed property from view model, e.g.; <code class="markup--code markup--li-code">viewModel.isSendingDisabled</code></li></ol><p name="e793" id="e793" class="graf graf--p graf-after--li">Note that you are NOT reducing the number of properties used nor simplifying computed properties.</p><p name="2527" id="2527" class="graf graf--p graf-after--p">You are just moving things so you don’t see it.</p><p name="69ff" id="69ff" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">That doesn’t mean it’s not there.</strong></p><p name="482a" id="482a" class="graf graf--p graf-after--p">By this logic, why not conforming to <code class="markup--code markup--p-code">View</code>in another file? E.g.;</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="fe61" id="fe61" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SendMessage</span> {<br />    <span class="hljs-meta">@State</span> <span class="hljs-keyword">var</span> message <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span><br />    <span class="hljs-meta">@State</span> <span class="hljs-keyword">var</span> errorText: <span class="hljs-type">String</span>?<br />    <span class="hljs-meta">@State</span> <span class="hljs-keyword">var</span> isSending <span class="hljs-operator">=</span> <span class="hljs-literal">false</span><br /><br />    <span class="hljs-comment">// nothing stopping you to use computed property here</span><br />    <span class="hljs-keyword">var</span> buttonTitle: <span class="hljs-type">String</span> { isSending <span class="hljs-operator">?</span> <span class="hljs-string">&quot;Sending...&quot;</span> : <span class="hljs-string">&quot;Send&quot;</span> }<br />    <span class="hljs-keyword">var</span> isSendingDisabled: <span class="hljs-type">Bool</span> { isSending <span class="hljs-operator">||</span> message.isEmpty }<br /><br />    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> sender: <span class="hljs-type">MessageSender</span><br />}<br /><br /><span class="hljs-comment">// another file</span><br /><span class="hljs-keyword">extension</span> <span class="hljs-title class_">SendMessage</span>: <span class="hljs-title class_">View</span> {<br />    <span class="hljs-comment">// ... var body</span><br />    <span class="hljs-comment">// without redundant viewModel prefix</span><br />    <span class="hljs-comment">// ... Button(buttonTitle) </span><br />}<br /><br /></span></pre><p name="e475" id="e475" class="graf graf--p graf-after--pre">Can I say this makes <em class="markup--em markup--p-em">UI code much simpler too?</em></p><p name="e173" id="e173" class="graf graf--p graf-after--p">This way I don’t need a sink object and extra overheads, and better yet I don’t need to sacrifice the usage of @State, @EnvironmentObject just so it <em class="markup--em markup--p-em">looks</em> <em class="markup--em markup--p-em">simpler</em>.</p><p name="0978" id="0978" class="graf graf--p graf-after--p">Oh shit, what about testing? Damn. These TDD titans.</p><blockquote name="2346" id="2346" class="graf graf--blockquote graf-after--p">First, we’ll now be able to unit test our code without having to worry about SwiftUI at all. And second, we’ll even be able to improve our SwiftUI view itself, as our view model now contains <strong class="markup--strong markup--blockquote-strong">all of the logic</strong> that our view needs to decide how it should be rendered.</blockquote><p name="3c07" id="3c07" class="graf graf--p graf-after--blockquote">To his second point, <strong class="markup--strong markup--p-strong">all of the logic </strong>is not always a good thing; there are other factors to consider, e.g.; reuse, refactor, composition… etc. There’s nothing in the argument that explains why you can only have <strong class="markup--strong markup--p-strong">ONE </strong>view model. Say I want to refactor out networking. That is one observable. Then I want to refactor out view processing logic, which can be another independent observable; I can also throw in shared environment object, which is another observable. Each of which can be unit tested even according to his test logic.</p><p name="7c01" id="7c01" class="graf graf--p graf-after--p">In fact, since anything can conform to <code class="markup--code markup--p-code">ObservableObject</code> , what MVVM asked you to do is to use exactly ONE observable. It’s not like you have to create binding manually and build around it. SwiftUI took care of that.</p><p name="2ede" id="2ede" class="graf graf--p graf-after--p">To his first point, let’s ask what it is that he is worrying about.</p><blockquote name="3e6a" id="3e6a" class="graf graf--blockquote graf-after--p">However, unit testing that view’s logic would currently be incredibly difficult — as we’d have to find some way to <strong class="markup--strong markup--blockquote-strong">spin up our view within our tests</strong>, then <strong class="markup--strong markup--blockquote-strong">find its various UI controls</strong> (such as its “Send” button), and <strong class="markup--strong markup--blockquote-strong">then figure out a way to trigger and observe those views ourselves</strong>.</blockquote><ol class="postList"><li name="2925" id="2925" class="graf graf--li graf-after--blockquote">Spin up our view within our tests</li></ol><p name="103d" id="103d" class="graf graf--p graf-after--li">You mean <code class="markup--code markup--p-code">var model = SendMessage()</code> ? Yes there are problems with @State not working in unit test. But this is how you “spin up a view” in a test regardless. It’s not like you need to load from a nib and setup @IBObservable like good old days. Are you applying MVVM for obj-c to SwiftUI?</p><p name="4401" id="4401" class="graf graf--p graf-after--p">2. Find its various UI controls</p><p name="23ff" id="23ff" class="graf graf--p graf-after--p">This is very reference type thinking. Get used to the idea that you can no longer holds a reference to UI object. In this case he wants to find “Send” button, which is described via binding. This means you can instead find <code class="markup--code markup--p-code">buttonTitle</code> because it binds to “Send” button. They are now two sides of the same coin.</p><p name="a948" id="a948" class="graf graf--p graf-after--p">3. Figure out a way to trigger and observe those views ourselves</p><p name="d166" id="d166" class="graf graf--p graf-after--p">This is his MVVM unit test utility function</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="dec9" id="dec9" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">XCTestCase</span> {<br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">waitUntil</span>&lt;<span class="hljs-type">T</span>: <span class="hljs-type">Equatable</span>&gt;(<br />        <span class="hljs-keyword">_</span> <span class="hljs-params">propertyPublisher</span>: <span class="hljs-type">Published</span>&lt;<span class="hljs-type">T</span>&gt;.<span class="hljs-type">Publisher</span>,<br />        <span class="hljs-params">equals</span> <span class="hljs-params">expectedValue</span>: <span class="hljs-type">T</span>,<br />        <span class="hljs-params">timeout</span>: <span class="hljs-type">TimeInterval</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>,<br />        <span class="hljs-params">file</span>: <span class="hljs-type">StaticString</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">#file</span>,<br />        <span class="hljs-params">line</span>: <span class="hljs-type">UInt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">#line</span><br />    ) { <span class="hljs-operator">...</span> }</span></pre><p name="1a9a" id="1a9a" class="graf graf--p graf-after--pre">Which is to setup a trigger and observe @Published view properties.</p><p name="3ab1" id="3ab1" class="graf graf--p graf-after--p">In fact, why bother with publisher when you have async-await? E.g.;</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="3ebd" id="3ebd" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> viewModel.send() <span class="hljs-comment">// if you can have some kind of timeout</span><br /><span class="hljs-built_in">assert</span>(viewModel.message　<span class="hljs-operator">==</span> <span class="hljs-string">&quot;&quot;</span>)</span></pre><p name="9835" id="9835" class="graf graf--p graf-after--pre">I’m guessing here because I haven’t been up-to-date with SwiftUI. But regardless, what efforts does he really save? He has to setup trigger and observe one way or another.</p><figure name="dcdc" id="dcdc" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*_wbZyfHxU_sHV0GUdgxa0Q.jpeg" data-width="600" data-height="470" src="https://cdn-images-1.medium.com/max/800/1*_wbZyfHxU_sHV0GUdgxa0Q.jpeg"></figure><p name="cfeb" id="cfeb" class="graf graf--p graf-after--figure">Obvisouly I need to look more closely. So here is one of his more detailed arguments:</p><blockquote name="89e9" id="89e9" class="graf graf--blockquote graf-after--p">Because we have to remember that SwiftUI views aren’t actual, concrete representations of the UI that we’re drawing on-screen, which can then be controlled and inspected as we wish. Instead, <strong class="markup--strong markup--blockquote-strong">they’re ephemeral descriptions of what we want our various views to look like</strong>, which the system then renders and manages on our behalf.</blockquote><blockquote name="b8b3" id="b8b3" class="graf graf--blockquote graf-after--blockquote">So, although we <em class="markup--em markup--blockquote-em">could</em> most likely find a way to unit test our SwiftUI views directly — ideally, <strong class="markup--strong markup--blockquote-strong">we’ll probably want to verify our logic in a much more controlled, isolated environment.</strong></blockquote><blockquote name="ac97" id="ac97" class="graf graf--blockquote graf-after--blockquote">One way to create such an isolated environment would be to extract all of the logic that we’re looking to test out from our views, and into objects and functions that are under our complete control — for example by using a view model.</blockquote><p name="8d85" id="8d85" class="graf graf--p graf-after--blockquote">You know what else is an <strong class="markup--strong markup--p-strong">ephemeral description?</strong></p><p name="9e82" id="9e82" class="graf graf--p graf-after--p">A test. Wouldn’t it make more sense that if you can make “view” an ephemeral description such that they can be created and destroyed on demand, e.g.; like a value type, it would help simplify the test process? Since you don’t need to worry about setting up @IBObservable from storyboard?</p><p name="c093" id="c093" class="graf graf--p graf-after--p">But somehow this is a negative to him? He needs a much more <em class="markup--em markup--p-em">controlled</em>, <em class="markup--em markup--p-em">isolated </em>environment. Why is this not qualified as one?</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="typescript" name="821f" id="821f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">struct <span class="hljs-title class_">SendMessage</span>: <span class="hljs-title class_">View</span> {<br />    <span class="hljs-meta">@State</span> <span class="hljs-keyword">var</span> message = <span class="hljs-string">&quot;&quot;</span><br />    <span class="hljs-meta">@State</span> <span class="hljs-keyword">var</span> <span class="hljs-attr">errorText</span>: <span class="hljs-title class_">String</span>?<br />    <span class="hljs-meta">@State</span> <span class="hljs-keyword">var</span> isSending = <span class="hljs-literal">false</span><br /><br />    <span class="hljs-comment">// nothing stopping you to use computed property here</span><br />    <span class="hljs-keyword">var</span> <span class="hljs-attr">buttonTitle</span>: <span class="hljs-title class_">String</span> { isSending ? <span class="hljs-string">&quot;Sending...&quot;</span> : <span class="hljs-string">&quot;Send&quot;</span> }<br />    <span class="hljs-keyword">var</span> <span class="hljs-attr">isSendingDisabled</span>: <span class="hljs-title class_">Bool</span> { isSending || message.<span class="hljs-property">isEmpty</span> }<br /><br />    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> <span class="hljs-attr">sender</span>: <span class="hljs-title class_">MessageSender</span><br />    <span class="hljs-comment">// var body...</span><br />}</span></pre><p name="3d43" id="3d43" class="graf graf--p graf-after--pre">OK. @State is not working in unit test. But your app contains more than just unit tests. Does this qualify as a controlled, isolated environment in production code?</p><p name="a47b" id="a47b" class="graf graf--p graf-after--p">Everything in this is created by you. i.e.; custom model type. @State properties do not hinder you from using them as a value type.</p><p name="6feb" id="6feb" class="graf graf--p graf-after--p">Can you test <code class="markup--code markup--p-code">buttonTitle</code> ? Ideally we could, if @State were a regular property wrapper.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="e3ea" id="e3ea" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">var</span> m <span class="hljs-operator">=</span> <span class="hljs-type">SendMessage</span>()<br /><span class="hljs-built_in">assert</span>(m.buttonTitle <span class="hljs-operator">==</span> <span class="hljs-string">&quot;Send&quot;</span>)<br />m.message <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test&quot;</span><br /><span class="hljs-built_in">assert</span>(m.message <span class="hljs-operator">==</span> <span class="hljs-string">&quot;test&quot;</span>)</span></pre><p name="1ecd" id="1ecd" class="graf graf--p graf-after--pre">But it is not. @State is so special that it cannot be mutated in unit test.</p><p name="965f" id="965f" class="graf graf--p graf-after--p">Thank God, because otherwise it shows all MVVM devs are idiots.</p><p name="c730" id="c730" class="graf graf--p graf-after--p">But because of this caveat, we have no choice but to at least consider some merits of MVVM, right?</p><p name="66e9" id="66e9" class="graf graf--p graf-after--p">This is exactly what this guy did. He even emphasized it:</p><blockquote name="8836" id="8836" class="graf graf--blockquote graf-after--p">Now, is the point of the above series of examples that all SwiftUI-based apps should completely adopt the MVVM (<em class="markup--em markup--blockquote-em">Model-View-ViewModel</em>) architecture? No, <strong class="markup--strong markup--blockquote-strong">absolutely not</strong>.</blockquote><p name="68d7" id="68d7" class="graf graf--p graf-after--blockquote">This is funny. When someone said there are other good architectures besides MVVM, it means he didn’t know shit about other architectures and is about to pump MVVM.</p><p name="907c" id="907c" class="graf graf--p graf-after--p">When someone wrote a view model unit test tutorial on his own website, you better believe his intention is NOT to PUMP MVVM.</p><p name="e786" id="e786" class="graf graf--p graf-after--p">But no. MVVM is just lazy. Of course it will be simpler to dump everything in one reference type object, which defeats the whole purpose of immutability; and do I really need to remind these MVVM TDD titans who need to inject a new class for each mock data that you shouldn’t <strong class="markup--strong markup--p-strong">CRIPPLE </strong>your design, i.e.; ONE observable only for what? So you can write unit tests easier? If that were true, first thing to dump is the DI dumb shit.</p><p name="32cd" id="32cd" class="graf graf--p graf-after--p">Let’s now compare it to POP.</p><h4 name="af99" id="af99" class="graf graf--h4 graf-after--p">POP and Value type</h4><p name="f96c" id="f96c" class="graf graf--p graf-after--h4">Recall that Swift is protocol-oriented. E.g.;</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="64bc" id="64bc" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Sender</span> {<br />  <span class="hljs-keyword">var</span> message: <span class="hljs-type">String</span> {<span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span>}<br />  <span class="hljs-keyword">var</span> errorText: <span class="hljs-type">String</span>? {<span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span>}<br />  <span class="hljs-keyword">var</span> isSending: <span class="hljs-type">Bool</span> {<span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span>}<br />  <span class="hljs-keyword">let</span> sender: <span class="hljs-type">MessageSender</span> {<span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span>}<br />}<br /><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Sender</span> {<br />  <span class="hljs-keyword">var</span> buttonTitle: <span class="hljs-type">String</span> { isSending <span class="hljs-operator">?</span> <span class="hljs-string">&quot;Sending...&quot;</span> : <span class="hljs-string">&quot;Send&quot;</span> }<br />  <span class="hljs-keyword">var</span> isSendingDisabled: <span class="hljs-type">Bool</span> { isSending <span class="hljs-operator">||</span> message.isEmpty }<br />}</span></pre><p name="5483" id="5483" class="graf graf--p graf-after--pre">The common misconception is that you use it as a requirement.</p><p name="d02d" id="d02d" class="graf graf--p graf-after--p">No. You make it a mix-in, i.e.; a piece of self-contained working code.</p><p name="fe0d" id="fe0d" class="graf graf--p graf-after--p">So you will <strong class="markup--strong markup--p-strong">provide </strong>the behavior here, in protocol extension.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="5d15" id="5d15" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Sender</span> {<br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">send</span>(<span class="hljs-operator">...</span>) {<br />    <span class="hljs-operator">...</span><br />  }<br />}</span></pre><p name="a098" id="a098" class="graf graf--p graf-after--pre">Anything you may need, you need to include it in protocol requirement to keep it self-contained. You need to find a balance to keep the protocol manageable, so as to <strong class="markup--strong markup--p-strong">NOT CONTAIN EVERYTHING</strong>.</p><p name="d537" id="d537" class="graf graf--p graf-after--p">See the difference in thinking?</p><p name="ba69" id="ba69" class="graf graf--p graf-after--p">We embrace immutability, state changes must be declared <code class="markup--code markup--p-code">mutating</code> ;The goal is to keep things small; and you are limited to the protocol extension sandbox; anything you require must be declared as requirement and can be easily spotted. It’s insanely hard to provide default initializer, so there’s no DI dumb shit. Since you are working with value type, there’s no point doing inheritance. Since you want to keep things small, it encourages composition.</p><p name="1c70" id="1c70" class="graf graf--p graf-after--p">Let’s say you’ve finished implementing it. What’s next? Conform to it.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="efb4" id="efb4" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SendMessage</span>: <span class="hljs-title class_">Sender</span> {<span class="hljs-operator">...</span>}</span></pre><p name="efad" id="efad" class="graf graf--p graf-after--pre">What’s next? Provide binding.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="cb2d" id="cb2d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">SendMessage</span>: <span class="hljs-title class_">View</span> {<span class="hljs-operator">...</span>}</span></pre><p name="4edc" id="4edc" class="graf graf--p graf-after--pre">So now it can be used to render view.</p><p name="9a6b" id="9a6b" class="graf graf--p graf-after--p">What’s next? Unit test.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="05ff" id="05ff" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SenderMock</span>: <span class="hljs-title class_">Sender</span> {<br />    <span class="hljs-comment">// protocol requirements are what you mock</span><br />    <span class="hljs-comment">// default implementations are what you test</span><br />}</span></pre><p name="e042" id="e042" class="graf graf--p graf-after--pre">Wait for auto-complete, then enter mock data. Then write your tests.</p><p name="0f5b" id="0f5b" class="graf graf--p graf-after--p">Obviously we have some overheads of creating variables, even with auto-complete. But what are we comparing to? Dumb shit DI that doesn’t know how to use variable? That has to create a new class for each mock data? And inject it via type-erased protocol?</p><p name="c81a" id="c81a" class="graf graf--p graf-after--p">Or MVVM that creates a<strong class="markup--strong markup--p-strong"> </strong><em class="markup--em markup--p-em">SHIT TON</em> of <strong class="markup--strong markup--p-strong">MUTABLE REPOSITORY? </strong>Creating dedicated mock class and variables is where you draw the line?</p><p name="6c29" id="6c29" class="graf graf--p graf-after--p">These mock classes are not even necessary. Simple computed properties can be verified using @State even when they are immutable, e.g.;</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="35e4" id="35e4" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">var</span> m <span class="hljs-operator">=</span> <span class="hljs-type">SendMessage</span>(isSending: <span class="hljs-literal">false</span>, message: <span class="hljs-string">&quot;&quot;</span>)<br /><span class="hljs-built_in">assert</span>(m.isSendingDisabled <span class="hljs-operator">==</span> <span class="hljs-literal">true</span>)</span></pre><p name="d5eb" id="d5eb" class="graf graf--p graf-after--pre">Or you can test multiple protocols in one mock class. We can do composition, remember?</p><p name="7743" id="7743" class="graf graf--p graf-after--p">If I were SwiftUI SDK lead designer, I’ll be confused. Because I told you to think in protocol first, design SDK around value type, give you automatic binding by conforming to @ObservableObject which can be conformed by anything. And these TDD titans decided to ignore all of these and crippled themselves by using <strong class="markup--strong markup--p-strong">ONE REFERENCE TYPE SINK OBJECT ONLY</strong>.</p><p name="bab7" id="bab7" class="graf graf--p graf-after--p">Do you know how <strong class="markup--strong markup--p-strong">VALUE </strong>type affects MVVM? I want my model be immutable. No more REPOSITORY shit. No more view model shit. Is it a MODEL or not? If it is not value type then why not? What are you hidding?</p><p name="b46e" id="b46e" class="graf graf--p graf-after--p">With this POP approach, Control / State changes are described in some protocol extension somewhere. Model is immutable except explicit state changes. Binding is described in some protocol extension somewhere. There are no “views” because there are no view properties, e.g.; <code class="markup--code markup--p-code">backgroundColor</code> .</p><p name="9a0e" id="9a0e" class="graf graf--p graf-after--p">It’s not even model-view binding if you think about it. Say you map <code class="markup--code markup--p-code">buttonTitle</code> to <code class="markup--code markup--p-code">Button(buttonTitle)</code> , is <code class="markup--code markup--p-code">Button</code> a “view”? It may as well be a model as long as SDK knows how to render it; and there are no “view” properties that you can acess.</p><p name="3990" id="3990" class="graf graf--p graf-after--p">It can be “viewed” as a model-model binding. Of all people, who are the idiots that keep insisting there’s a view and we need to remove everything from view?</p><p name="d7e6" id="d7e6" class="graf graf--p graf-after--p">Let’s look at his example of showing “you don’t always need a view model”.</p><figure name="d6e3" id="d6e3" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*C_2u7ewrS9a_FByeOy9N3g.png" data-width="1247" data-height="902" src="https://cdn-images-1.medium.com/max/800/1*C_2u7ewrS9a_FByeOy9N3g.png"></figure><p name="03cc" id="03cc" class="graf graf--p graf-after--figure">He wants to be able to test<code class="markup--code markup--p-code">event.isBookable</code> , <code class="markup--code markup--p-code">event.startData &gt; .now</code> … etc.</p><p name="71b2" id="71b2" class="graf graf--p graf-after--p">Ironically, this is where you use dependency injection. Because usually you want to avoid hard-coded condition checks. Not the massive initializer dumb shit. A <code class="markup--code markup--p-code">events.first(where: {event in event.isSelectable})</code> will do.</p><p name="eec3" id="eec3" class="graf graf--p graf-after--p">This is just basic refactor, not “it’s in the view so it’s hard to test”.</p><p name="d921" id="d921" class="graf graf--p graf-after--p">Let’s change it a bit. Say <code class="markup--code markup--p-code">selection = special()</code> . And you want to test <code class="markup--code markup--p-code">special()</code> .</p><p name="c789" id="c789" class="graf graf--p graf-after--p">Let’s “view” this as a model.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="7310" id="7310" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">EventSelection</span>: <span class="hljs-title class_">View</span> {<br />  <span class="hljs-keyword">var</span> events: [<span class="hljs-type">Event</span>]<br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">special</span>() -&gt; <span class="hljs-type">Event</span> {<span class="hljs-operator">...</span>}<br />  <span class="hljs-comment">// ...</span><br />  <span class="hljs-comment">// Button(&quot;Select next available&quot;) { selection = special() }</span><br />}</span></pre><p name="1253" id="1253" class="graf graf--p graf-after--pre">How do we test it?</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="b42f" id="b42f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">var</span> m <span class="hljs-operator">=</span> <span class="hljs-type">EventSelection</span>()<br />m.events <span class="hljs-operator">=</span> mockEvents<br /><span class="hljs-comment">// assert(m.special() == ...)</span></span></pre><p name="0511" id="0511" class="graf graf--p graf-after--pre">Because <code class="markup--code markup--p-code">var events</code> is not a @State. It’s possible if it’s not view-related data.</p><p name="8be7" id="8be7" class="graf graf--p graf-after--p">But maybe this is a typo, so what if it is a @State?</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="471a" id="471a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">var</span> m <span class="hljs-operator">=</span> <span class="hljs-type">EventSelection</span>(events: mockEvents)<br /><span class="hljs-comment">// assert(m.special() == ...)</span></span></pre><p name="cda6" id="cda6" class="graf graf--p graf-after--pre">You need to recreate the variable for every mock data. But it’s doable for simple checks.</p><p name="d381" id="d381" class="graf graf--p graf-after--p">You can extend <code class="markup--code markup--p-code">special()</code>from somewhere else if you really really, really need the extra space for some reason. Again, just because you don’t see it doesn’t mean it’s not there. Your code is not simplified.</p><p name="fd21" id="fd21" class="graf graf--p graf-after--p">I don’t know why this “makes UI look simpler” is such an important metric for MVVM devs. You will never hear them say “yeah, my UI may look simpler, but my sink object is fuk”.</p><p name="ee0b" id="ee0b" class="graf graf--p graf-after--p">So what’s the problem you think MVVM is “solving”?</p><p name="b70d" id="b70d" class="graf graf--p graf-after--p">Irrational fear of “view”?</p><p name="1dc8" id="1dc8" class="graf graf--p graf-after--p">Let’s wrap up.</p><h4 name="5843" id="5843" class="graf graf--h4 graf-after--p">There’s no view</h4><figure name="803f" id="803f" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*c3EgtPuX29-WoJGqd-vKvw.png" data-width="1136" data-height="522" src="https://cdn-images-1.medium.com/max/800/1*c3EgtPuX29-WoJGqd-vKvw.png"></figure><blockquote name="b633" id="b633" class="graf graf--blockquote graf-after--figure">Young Monk: “Do not try and bend the spoon — that’s impossible. Instead, only try to realize the truth.”</blockquote><blockquote name="8361" id="8361" class="graf graf--blockquote graf-after--blockquote">Neo: “What truth?”</blockquote><blockquote name="bda8" id="bda8" class="graf graf--blockquote graf-after--blockquote">Young Monk: “There is no spoon.”</blockquote><p name="d423" id="d423" class="graf graf--p graf-after--blockquote">There’s no view in SwiftUI. You have model. You have model-model binding. SwiftUI renders view from model. This is the simplest interpretation.</p><p name="7f70" id="7f70" class="graf graf--p graf-after--p">You can see it as a “view” in UIView sense, as long as it gives you benefits in design.</p><p name="0c00" id="0c00" class="graf graf--p graf-after--p">But what benefits does it give you? As compared to where there’s no view?</p><p name="fbe1" id="fbe1" class="graf graf--p graf-after--p">You lost @EnvironmentObject for what? Unit test? Did they cover don’t cripple your design in MVVM master class?</p><p name="32d3" id="32d3" class="graf graf--p graf-after--p">It’s not like you can’t otherwise, as I’ve just shown. With arguably fewer drawbacks and acceptable overheads.</p><p name="181d" id="181d" class="graf graf--p graf-after--p">His conclusion:</p><blockquote name="a4d5" id="a4d5" class="graf graf--blockquote graf-after--p">Instead, I focus on extracting <strong class="markup--strong markup--blockquote-strong">all of the logic</strong> that I wish to test out from my views and into objects that are <strong class="markup--strong markup--blockquote-strong">under my complete control</strong>. That way, I can spend <strong class="markup--strong markup--blockquote-strong">less time fighting with Apple’s UI frameworks </strong>in order to make them unit testing-friendly, and more time <strong class="markup--strong markup--blockquote-strong">writing solid, reliable tests</strong>.</blockquote><ol class="postList"><li name="fc8f" id="fc8f" class="graf graf--li graf-after--blockquote">It says nothing about why you can only have ONE observable. You can divide / refactor all of the logic.</li><li name="6c3f" id="6c3f" class="graf graf--li graf-after--li">His method of gaining complete control is to fight Apple’s UI frameworks, e.g.; self-inflicted damage like avoiding using “View” that he himself named. (Apple only requires you to conform to View, not naming it)</li><li name="2354" id="2354" class="graf graf--li graf-after--li">Solid, reliable tests are nice to have if you can write them. But your job is not writing unit tests! Note that there’s never any discussion as to how you are going to refactor that <strong class="markup--strong markup--li-strong">all of the logic</strong>. Like once you put all logic in one place, you are done. <strong class="markup--strong markup--li-strong">You haven’t even begun to refactor, man.</strong> Learn how to refactor before you claim to be a TDD titan!</li></ol><p name="3b18" id="3b18" class="graf graf--p graf-after--li">Oh, I was going to criticize the shit out of the other article. But it all came from shit refactor; and it’s hard to argue if a test is good or not. I have a different advice to give:</p><p name="b027" id="b027" class="graf graf--p graf-after--p graf--trailing">Spend less time trying to write unit tests, spend more time refactoring your shit.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/a769aade21a2"><time class="dt-published" datetime="2023-05-07T09:38:30.265Z">May 7, 2023</time></a>.</p><p><a href="https://medium.com/@swift2931/swiftui-unit-test-without-mvvm-a769aade21a2" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>