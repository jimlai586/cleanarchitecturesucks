<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>A complete failure of MVVM+C in SwiftUI</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">A complete failure of MVVM+C in SwiftUI</h1>
</header>
<section data-field="subtitle" class="p-summary">
Learn value type and refactor
</section>
<section data-field="body" class="e-content">
<section name="0e14" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="1780" id="1780" class="graf graf--h3 graf--leading graf--title">A complete failure of MVVM+C in SwiftUI</h3><h4 name="38e1" id="38e1" class="graf graf--h4 graf-after--h3 graf--subtitle">Learn value type and refactor</h4><figure name="a7f6" id="a7f6" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*wzY1axVXqFFNB5-VqJNWIQ.jpeg" data-width="779" data-height="320" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*wzY1axVXqFFNB5-VqJNWIQ.jpeg"><figcaption class="imageCaption">John Wick helping a fellow MVVM dev</figcaption></figure><h4 name="caf4" id="caf4" class="graf graf--h4 graf-after--figure">You working again, John?</h4><p name="15a0" id="15a0" class="graf graf--p graf-after--h4">Afraid so.</p><p name="3c2e" id="3c2e" class="graf graf--p graf-after--p">Saw this on highlight.</p><p name="cd04" id="cd04" class="graf graf--p graf-after--p"><a href="https://medium.com/@katramesh91/how-to-build-uikit-like-mvvm-c-coordinator-hierarchy-with-swiftui-d758b035f91a" data-href="https://medium.com/@katramesh91/how-to-build-uikit-like-mvvm-c-coordinator-hierarchy-with-swiftui-d758b035f91a" class="markup--anchor markup--p-anchor" target="_blank">How to build UIKit like MVVM-C Coordinator hierarchy with SwiftUI</a></p><p name="5f05" id="5f05" class="graf graf--p graf-after--p">As usual, I’m going to rant about it. At the very least this should give you a perspective outside of MVVM echo chamber.</p><p name="717b" id="717b" class="graf graf--p graf-after--p">Let’s appreciate this iconic MVVM+C design:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="0a31" id="0a31" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserFlowCoordinator</span>: <span class="hljs-title class_">ObservableObject</span>, <span class="hljs-title class_">Hashable</span> {<br />    <span class="hljs-comment">// ...</span><br />      <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">usersListView</span>() -&gt; <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> { <span class="hljs-comment">// create a view</span><br />        <span class="hljs-keyword">let</span> viewModel <span class="hljs-operator">=</span> <span class="hljs-type">UsersListViewModel</span>()<br />        <span class="hljs-keyword">let</span> usersListView <span class="hljs-operator">=</span> <span class="hljs-type">UsersListView</span>(viewModel: viewModel)<br />        bind(view: usersListView)<br />        <span class="hljs-keyword">return</span> usersListView<br />    }<br />    <span class="hljs-comment">// ...</span><br />}</span></pre><p name="23f1" id="23f1" class="graf graf--p graf-after--pre">This is supposed to be more <em class="markup--em markup--p-em">scalable </em>than this?</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="b375" id="b375" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UserList</span>: <span class="hljs-title class_">View</span> {<span class="hljs-operator">...</span>}<br /><span class="hljs-type">UserList</span>(<span class="hljs-operator">...</span>) <span class="hljs-comment">// create a view</span></span></pre><p name="52ad" id="52ad" class="graf graf--p graf-after--pre">Really?</p><p name="827b" id="827b" class="graf graf--p graf-after--p">Oh, reusable, separate logic from view… etc. Of course.</p><p name="27bd" id="27bd" class="graf graf--p graf-after--p">But is it? Is it really reusable? Do you actually separate logic from view?</p><p name="7467" id="7467" class="graf graf--p graf-after--p">You can’t reuse <code class="markup--code markup--p-code">UserListViewModel</code> , most likely you will need to inherit it.</p><p name="12e6" id="12e6" class="graf graf--p graf-after--p">Is this separate logic from view?</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="52ce" id="52ce" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UserList</span>: <span class="hljs-title class_">View</span> {<br />  <span class="hljs-meta">@ObservedObject</span> <span class="hljs-keyword">var</span> sink: <span class="hljs-type">SinkObject</span> <br />  <span class="hljs-comment">// dump everything to sink</span><br />}<br />  </span></pre><p name="5ef2" id="5ef2" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">View is still associated with logic.</strong> You just now access it via a wrapper.</p><p name="775a" id="775a" class="graf graf--p graf-after--p">Logic is not simplified, code is not reduced. More reusable? But you dump everything to it, which reduces it; You need to create a new class anyway to inherit it, which reduces it. In the meantime you ignore other means of refactor like computed properties and protocol extension.</p><p name="d763" id="d763" class="graf graf--p graf-after--p">You will argue that it’s not a fair comparison, because I ignored DI and coordinator logic. And you are right.</p><p name="0e95" id="0e95" class="graf graf--p graf-after--p">But, do you really need it? Let’s see his argument.</p><h4 name="f016" id="f016" class="graf graf--h4 graf-after--p">Oh, he has no argument</h4><p name="07ce" id="07ce" class="graf graf--p graf-after--h4">You need it because it worked so well in UIKit.</p><p name="a823" id="a823" class="graf graf--p graf-after--p">But it is a dog shit even in UIKit. I’m sorry, let’s approach this in a more objective way.</p><p name="e906" id="e906" class="graf graf--p graf-after--p">He started with MVVM being an well-established design pattern. Then coordinator is added to <em class="markup--em markup--p-em">separate routing logic from view</em>.</p><p name="42f3" id="42f3" class="graf graf--p graf-after--p">This is objectively false. In UIKit you separate routing logic from <code class="markup--code markup--p-code">ViewController</code> . You can only access <code class="markup--code markup--p-code">NavigationViewController</code> from there. Even he knew this:</p><blockquote name="ed49" id="ed49" class="graf graf--blockquote graf-after--p">The whole idea behind introducing MVVM-C over MVVM to s<strong class="markup--strong markup--blockquote-strong">eparate app’s routing logic from the view layer.</strong> In UIKit we can do it perfectly since we can scratch the UINavigationController out of the <strong class="markup--strong markup--blockquote-strong">ViewController </strong>and use it separately.</blockquote><p name="d4c0" id="d4c0" class="graf graf--p graf-after--blockquote">So objectively, he didn’t mention anything as to why he thought it’s a good idea to port something built for UIKit to SwiftUI, despite of them having completely different architecture; he didn’t show any argument or comparison as to why this is better than using basic SDK. And he didn’t even get basic fact right.</p><p name="4c93" id="4c93" class="graf graf--p graf-after--p">Not only did he think you can just port UIKit coordinator-like hierarchy to SwiftUI, but also it would be an improvement over a single coordinator approach.</p><blockquote name="396d" id="396d" class="graf graf--blockquote graf-after--p">Most famous approach to use Coordinator pattern with SwiftUI is to use single coordinator throughout the whole application as an observable object. Here, we are only using coordinator for navigation purpose and <strong class="markup--strong markup--blockquote-strong">we aren’t using coordinator to handle other responsibilities which we used to do in UIKit MVVM-C Coordinator</strong>. This approach has following drawbacks.</blockquote><p name="eaca" id="eaca" class="graf graf--p graf-after--blockquote">Wait, you used coordinator to handle other responsibilities? So it’s not just a coordinator then?</p><p name="ddb7" id="ddb7" class="graf graf--p graf-after--p">Let’s take a moment to appreciate how full of shit MVVM+C is.</p><p name="0fac" id="0fac" class="graf graf--p graf-after--p">And there are drawbacks! That’s not what MVVM+C tutorial said!</p><p name="cce1" id="cce1" class="graf graf--p graf-after--p">Oh now it suddenly occured to you that MVVM+C has drawbacks!?</p><p name="37ae" id="37ae" class="graf graf--p graf-after--p">What other shit did these MVVM devs not disclose before?</p><blockquote name="8c33" id="8c33" class="graf graf--blockquote graf-after--p">Single coordinator responsible for <strong class="markup--strong markup--blockquote-strong">handling all the navigations</strong>.</blockquote><blockquote name="a0b7" id="a0b7" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong">Coordinator becomes too heavy</strong> when the app is scaling.</blockquote><blockquote name="43ab" id="43ab" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong">Coordinator knows too much and hard</strong> to modularise the app.</blockquote><blockquote name="585e" id="585e" class="graf graf--blockquote graf-after--blockquote">Becomes less readable &amp; hard to maintain when the app grows.</blockquote><p name="d3c5" id="d3c5" class="graf graf--p graf-after--blockquote">You can already see a pattern here: these guys don’t know a thing about <strong class="markup--strong markup--p-strong">REFACTOR</strong>.</p><p name="cfab" id="cfab" class="graf graf--p graf-after--p">All they know is create some God object. Dump everything to it until it becomes too crowded. Then you create <strong class="markup--strong markup--p-strong">MORE GOD OBJECTS</strong>!</p><p name="92d7" id="92d7" class="graf graf--p graf-after--p">So for <strong class="markup--strong markup--p-strong">EVERY </strong>view, we at mimimum need to have 1 view model, 1 coordinator, 1 function to package all that shit to the view so they are <strong class="markup--strong markup--p-strong">SEPARATED</strong>. And to <strong class="markup--strong markup--p-strong">reuse </strong>any of them, you have to <strong class="markup--strong markup--p-strong">create</strong> new classes / protocols and inherit old classes.</p><p name="a63e" id="a63e" class="graf graf--p graf-after--p">What a load of shit. I’m sorry, let’s look at this from a more objective perspective.</p><p name="5311" id="5311" class="graf graf--p graf-after--p">There’s nothing that says you can only create one coordinator in the first place. So he is not wrong yet. But nothing says you can only create one observable in view either. His argument can apply to view model as well.</p><p name="caf5" id="caf5" class="graf graf--p graf-after--p">So why didn’t he do the same for view model? Obvisouly MVVM would collapse then. E.g.;</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="6d93" id="6d93" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ContentView</span>: <span class="hljs-title class_">View</span> {<br />    <span class="hljs-meta">@StateObject</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> appCoordinator <span class="hljs-operator">=</span> <span class="hljs-type">AppCoordinator</span>(path: <span class="hljs-type">NavigationPath</span>())<br />    <span class="hljs-comment">// ...</span><br />}</span></pre><p name="f7c9" id="f7c9" class="graf graf--p graf-after--pre">Where do you put view model then? By MVVM’s definition, your “view”contains “logic” now.</p><p name="777b" id="777b" class="graf graf--p graf-after--p">This is a singularity that MVVM cannot explain. All they can do is avoid it, like what he has to do with @EnvironmentObject.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="scss" name="50b7" id="50b7" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">        <span class="hljs-built_in">NavigationStack</span>(path: $appCoordinator.path) {<br />           <span class="hljs-comment">// ... </span><br />        }<br />        <span class="hljs-selector-class">.environmentObject</span>(appCoordinator)</span></pre><p name="bca6" id="bca6" class="graf graf--p graf-after--pre">Nowhere in his code snippets did he observe environment object. So what’s the point of having it as an environment object?</p><p name="31c1" id="31c1" class="graf graf--p graf-after--p">He can’t observe it, (at least explicitly), otherwise “view” would contain “logic”, would it?</p><p name="7a8c" id="7a8c" class="graf graf--p graf-after--p">This lack of respect for SDK is precisely why MVVM is dog shit. It doesn’t matter whether it is UIKit or SwiftUI. There are always excuses for MVVM devs to ignore SDK so they can write design pattern for the sake of writing design pattern.</p><p name="10c1" id="10c1" class="graf graf--p graf-after--p">I’m sorry, let’s keep things objective and take a more in-depth look at coordinator(s).</p><h4 name="ad3b" id="ad3b" class="graf graf--h4 graf-after--p">Reference type + manual binding versus value type + automatic binding</h4><p name="1551" id="1551" class="graf graf--p graf-after--h4">Given the choice, would you prefer NOT to manually create a view model followed by manually creating binding? Because these are routine boilerplate?</p><p name="a7ad" id="a7ad" class="graf graf--p graf-after--p">No. How else can I virtue-signal my prowess as a lead iOS dev that pioneered MVVM+C in SwiftUI?</p><p name="3ed2" id="3ed2" class="graf graf--p graf-after--p">I want to repeat the word “view model” as many times as I could. People need to be constantly reminded that I’m writing MVVM. E.g.;</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="3b95" id="3b95" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">bind</span>(<span class="hljs-params">userCoordinator</span>: <span class="hljs-type">UserFlowCoordinator</span>) {<br />        userCoordinator.pushCoordinator<br />            .receive(on: <span class="hljs-type">DispatchQueue</span>.main)<br />            .sink(receiveValue: { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] coordinator <span class="hljs-keyword">in</span><br />                <span class="hljs-keyword">self</span><span class="hljs-operator">?</span>.push(coordinator)<br />            })<br />            .store(in: <span class="hljs-operator">&amp;</span>cancellables)<br />    }</span></pre><p name="b0a2" id="b0a2" class="graf graf--p graf-after--pre">This right here is material for 3 tutorials covering MVVM + Combine + C, in which I can talk about how SwiftUI is designed so you can do manual binding easily.</p><p name="0411" id="0411" class="graf graf--p graf-after--p">What I wouldn’t cover is that why you need it? E.g.;</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="java" name="8d1a" id="8d1a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Pages</span> {<br />  <span class="hljs-keyword">case</span> user1, user2, user3, setting1, setting2<br />}<br /><span class="hljs-comment">// ... </span><br /><span class="hljs-meta">@EnvironmentObject</span> <span class="hljs-keyword">var</span> coo: Coordinator<br /><span class="hljs-comment">// ...</span><br /><span class="hljs-comment">// coo.path = [user1, user2, setting1, setting2]</span><br /><span class="hljs-comment">// ... NavigationStack($coo.path) </span></span></pre><p name="af59" id="af59" class="graf graf--p graf-after--pre">Automatic binding. Value type.</p><p name="c863" id="c863" class="graf graf--p graf-after--p">But this doesn’t cover multiple coordinators.</p><p name="8595" id="8595" class="graf graf--p graf-after--p">You can easily apply this to a subtree of view hierarchy. Then multiple subtrees. These coordinators can be observable properties of an enclosing coordinator, which is observable. E.g.;</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="ff1d" id="ff1d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UserList</span>: <span class="hljs-title class_">View</span> {<br />  <span class="hljs-meta">@EnvrionmentObject</span> <span class="hljs-keyword">var</span> coo: <span class="hljs-type">Coordinator</span><br />  <span class="hljs-comment">// ... NavigationStack($coo.path)</span><br />  <span class="hljs-comment">// let userFlowCoo worry about updating coo.path</span><br />  <span class="hljs-comment">// ... coo.userFlowCoo.changePage()</span><br />}</span></pre><p name="7a92" id="7a92" class="graf graf--p graf-after--pre">Automatic binding. Value type. Oh, and dependency injection since we don’t know anything about how <code class="markup--code markup--p-code">changePage()</code> is implemented.</p><p name="43c3" id="43c3" class="graf graf--p graf-after--p">Tell me again how MVVM+C is supposed to <em class="markup--em markup--p-em">scalable</em>?</p><blockquote name="7549" id="7549" class="graf graf--blockquote graf-after--p">There are a lots of benefits on this approach compared to single coordinator approach with SwiftUI. Those are,</blockquote><blockquote name="e85e" id="e85e" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong">Easier to scale </strong>and <strong class="markup--strong markup--blockquote-strong">modularise </strong>the app by adding different flow coordinators.</blockquote><blockquote name="f00d" id="f00d" class="graf graf--blockquote graf-after--blockquote">You can further break down the flows by <strong class="markup--strong markup--blockquote-strong">adding more sub coordinators</strong>.</blockquote><p name="71d9" id="71d9" class="graf graf--p graf-after--blockquote">I think there’s a misunderstanding here. That you can add more when needed doesn’t mean it can scale. The key to scale is how <strong class="markup--strong markup--p-strong">NOT </strong>to add anything or as few as possible.</p><p name="e0ea" id="e0ea" class="graf graf--p graf-after--p">Having to create one view model for every view is the complete opposite of <em class="markup--em markup--p-em">scalable</em>. Not only MVVM devs ignore that, they are adding more! And they see it as a <em class="markup--em markup--p-em">feature</em> not bug!</p><p name="9e75" id="9e75" class="graf graf--p graf-after--p">This concept has a name. It’s called <strong class="markup--strong markup--p-strong">REFACTOR</strong>.</p><p name="9e34" id="9e34" class="graf graf--p graf-after--p">Oh, not to mention. Did he really put reference types as navigation stack path? Let me check again.</p><blockquote name="1ce3" id="1ce3" class="graf graf--blockquote graf-after--p"><strong class="markup--strong markup--blockquote-strong">Technical Lead</strong> (Swift, Objective C, Flutter, react-native) | iOS Developer | Mobile Development <strong class="markup--strong markup--blockquote-strong">Lecturer</strong></blockquote><p name="6a09" id="6a09" class="graf graf--p graf-after--blockquote">Oh sorry, copy paste the wrong thing.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="c3f7" id="c3f7" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">push</span>&lt;<span class="hljs-type">T</span>: <span class="hljs-type">Hashable</span>&gt;(<span class="hljs-keyword">_</span> <span class="hljs-params">coordinator</span>: <span class="hljs-type">T</span>) {<br />        path.append(coordinator)<br />    }</span></pre><p name="564f" id="564f" class="graf graf--p graf-after--pre">Shit…</p><p name="83c8" id="83c8" class="graf graf--p graf-after--p">Not that you can’t. But wouldn’t it be simpler to just use value type? You don’t have to implement <code class="markup--code markup--p-code">Hashable</code> for EVERY coordinator for one?</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="ee53" id="ee53" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">    <span class="hljs-keyword">func</span> <span class="hljs-title function_">hash</span>(<span class="hljs-params">into</span> <span class="hljs-params">hasher</span>: <span class="hljs-keyword">inout</span> <span class="hljs-type">Hasher</span>) {<br />        hasher.combine(id)<br />    }</span></pre><p name="ebea" id="ebea" class="graf graf--p graf-after--pre">In case you didn’t notice, all he did so far is creating reference types. (besides view) In addition, he promised that <em class="markup--em markup--p-em">more </em>can be added and hence <em class="markup--em markup--p-em">scalable… </em>in a SDK where even “view” is a value type.</p><p name="211e" id="211e" class="graf graf--p graf-after--p">Navigation stack is now where you build view:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="8091" id="8091" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">usersListView</span>() -&gt; <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {<br />        <span class="hljs-keyword">let</span> viewModel <span class="hljs-operator">=</span> <span class="hljs-type">UsersListViewModel</span>()<br />        <span class="hljs-keyword">let</span> usersListView <span class="hljs-operator">=</span> <span class="hljs-type">UsersListView</span>(viewModel: viewModel)<br />        bind(view: usersListView)<br />        <span class="hljs-keyword">return</span> usersListView<br />    }</span></pre><p name="f339" id="f339" class="graf graf--p graf-after--pre">This defeats the purpose of having immutable value type as view and automatic binding.</p><p name="ca56" id="ca56" class="graf graf--p graf-after--p">If it were me writing this, I’ll stop and compare it to</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="cpp" name="1603" id="1603" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UserList</span>: View {...}<br /><span class="hljs-comment">// UserList()</span></span></pre><p name="d17d" id="d17d" class="graf graf--p graf-after--pre">And realize I have no advantage, or at least not significant enough to justify the overheads.</p><p name="8b43" id="8b43" class="graf graf--p graf-after--p">On the other hand, I won’t be able to use this view directly:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="324d" id="324d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MainSettingsView</span>: <span class="hljs-title class_">View</span> {<br />    <span class="hljs-keyword">let</span> didClickPrivacy <span class="hljs-operator">=</span> <span class="hljs-type">PassthroughSubject</span>&lt;<span class="hljs-type">Bool</span>, <span class="hljs-type">Never</span>&gt;()<br />    <span class="hljs-keyword">let</span> didClickCustom <span class="hljs-operator">=</span> <span class="hljs-type">PassthroughSubject</span>&lt;<span class="hljs-type">Bool</span>, <span class="hljs-type">Never</span>&gt;()<br />    <br />    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {<br />      <span class="hljs-comment">// ... didClickPrivacy.send()</span><br />    }<br />}</span></pre><p name="1164" id="1164" class="graf graf--p graf-after--pre">Because I don’t know how to setup these passthrough objects. This view is designed only to be generated during runtime by a coordinator. You can’t even get it from coordinator directly because this function is private.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="446e" id="446e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">mainSettingsView</span>() -&gt; <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {<br />        <span class="hljs-keyword">let</span> mainView <span class="hljs-operator">=</span> <span class="hljs-type">MainSettingsView</span>()<br />        bind(view: mainView)<br />        <span class="hljs-keyword">return</span> mainView<br />    }</span></pre><p name="9e43" id="9e43" class="graf graf--p graf-after--pre">So view is coupled with coordinator. I see how MVVM succeeded in separating logic from view.</p><p name="a67f" id="a67f" class="graf graf--p graf-after--p">This is important because you expect “view” to be created and destroyed on demand, especially when it is a value type. And you want to be able to preview or test it.</p><p name="731d" id="731d" class="graf graf--p graf-after--p">He didn’t bother using view model in this case because even he got tired of writing that shit. How many nested levels do you need for a view? What do you gain from NOT using environment object?</p><p name="663d" id="663d" class="graf graf--p graf-after--p">In basic SwiftUI flow, external dependencies are shared most likely via environment object. The rest should be locally created unless you are doing DI dumb shit. Create one and use it to preview or test.</p><p name="2a7f" id="2a7f" class="graf graf--p graf-after--p">Or do you rather want this?</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="f084" id="f084" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">bind</span>(<span class="hljs-params">view</span>: <span class="hljs-type">MainSettingsView</span>) {<br />        view.didClickPrivacy<br />            .receive(on: <span class="hljs-type">DispatchQueue</span>.main)<br />            .sink(receiveValue: { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] didClick <span class="hljs-keyword">in</span><br />                <span class="hljs-keyword">if</span> didClick {<br />                    <span class="hljs-keyword">self</span><span class="hljs-operator">?</span>.showPrivacySettings()<br />                }<br />            })<br />            .store(in: <span class="hljs-operator">&amp;</span>cancellables)<br />        <br />        view.didClickCustom<br />            .receive(on: <span class="hljs-type">DispatchQueue</span>.main)<br />            .sink(receiveValue: { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] didClick <span class="hljs-keyword">in</span><br />                <span class="hljs-keyword">if</span> didClick {<br />                    <span class="hljs-keyword">self</span><span class="hljs-operator">?</span>.showCustomSettings()<br />                }<br />            })<br />            .store(in: <span class="hljs-operator">&amp;</span>cancellables)<br />    }</span></pre><p name="c1d0" id="c1d0" class="graf graf--p graf-after--pre">It’s private so can’t be called from outside. (a binding that is not reusable) Copy paste the same shit twice, for <strong class="markup--strong markup--p-strong">ONE </strong>view. What if you need to do it for multiple views? Oh that’s right, we can add more if needed, and that is <em class="markup--em markup--p-em">scalable</em>. If you know anything about <strong class="markup--strong markup--p-strong">REFACTOR</strong>, this is where you do it!</p><p name="b7d3" id="b7d3" class="graf graf--p graf-after--p">Somebody needs to stop dumb shit MVVM. I’m writing this so more people can come forward. MVVM is dog shit unless you have binding support. And it may still be dog shit given how these guys just ignored automatic binding.</p><p name="0e85" id="0e85" class="graf graf--p graf-after--p">Let’s wrap up.</p><h4 name="38bb" id="38bb" class="graf graf--h4 graf-after--p">Everything’s got a price.</h4><figure name="e8dd" id="e8dd" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*wZS6_kbUO16-bn5bJwg33g.png" data-width="1169" data-height="577" src="https://cdn-images-1.medium.com/max/800/1*wZS6_kbUO16-bn5bJwg33g.png"></figure><p name="3b33" id="3b33" class="graf graf--p graf-after--figure">In MVVM, creating objects and manual binding is free. The inevitable result is brute force boilerplate. When you get a free pass to create one view model for each view on top of other dumb shit, you don’t have any incentive to refactor.</p><p name="80eb" id="80eb" class="graf graf--p graf-after--p">No. Creating types has a price. Interactions (callback, delegate, binding) has a price. Passing objects has a price. Everything’s got a price.</p><p name="9234" id="9234" class="graf graf--p graf-after--p">For example, this is seen as a feature in MVVM+C</p><figure name="9411" id="9411" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*B9ls5_nsUKJMc_UnGPU7bQ.png" data-width="760" data-height="627" src="https://cdn-images-1.medium.com/max/800/1*B9ls5_nsUKJMc_UnGPU7bQ.png"></figure><p name="fb4e" id="fb4e" class="graf graf--p graf-after--figure">That is 7 files for a view. You repeat the same thing for EVERY view.</p><p name="1521" id="1521" class="graf graf--p graf-after--p">A junior level developer should be able to refactor and combine all these.</p><p name="35f9" id="35f9" class="graf graf--p graf-after--p">One <code class="markup--code markup--p-code">Codable</code> model type for each response? Refactor.</p><p name="20e2" id="20e2" class="graf graf--p graf-after--p">One view model for each view? Refactor.</p><p name="4c62" id="4c62" class="graf graf--p graf-after--p">One coordinator for each view? For God’s sake, who wrote this shit?</p><p name="4916" id="4916" class="graf graf--p graf-after--p">So you might start with using a JSON type for every response. Remove view model because everything can conform to observable and binding is automatic. Then try using no coordinator unless you really need one. Use value type for navigation stack path, not this full-fledged coordinator reference type that only does routing, binding, view generation in private and you should be grateful MVVM+C doesn’t do more than that. Not to mention the brute force binding code, unecessary DI, extra overheads that are somehow <em class="markup--em markup--p-em">scalable</em>.</p><p name="574d" id="574d" class="graf graf--p graf-after--p">Compare to his conclusions again:</p><blockquote name="3c09" id="3c09" class="graf graf--blockquote graf-after--p"><strong class="markup--strong markup--blockquote-strong">Conclusion</strong></blockquote><blockquote name="7d2a" id="7d2a" class="graf graf--blockquote graf-after--blockquote">There are <strong class="markup--strong markup--blockquote-strong">a lots of benefits </strong>on this approach compared to single coordinator approach with SwiftUI. Those are,</blockquote><blockquote name="ee78" id="ee78" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong">Easier to scale</strong> and modularise the app by adding different flow coordinators.</blockquote><blockquote name="804d" id="804d" class="graf graf--blockquote graf-after--blockquote">You can further break down the flows by <strong class="markup--strong markup--blockquote-strong">adding more sub coordinators</strong>.</blockquote><blockquote name="ddc6" id="ddc6" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong">Main coordinator doesn’t become too heavy to handle</strong>.</blockquote><blockquote name="9784" id="9784" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong">Each coordinator only knows about navigations of its own flow only</strong>. This will make easier to maintain the the navigations of the each flow.</blockquote><blockquote name="4b92" id="4b92" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong">Becomes more readable &amp; easy to maintain when the app grows</strong>.</blockquote><p name="cca9" id="cca9" class="graf graf--p graf-after--blockquote">Most are just due to having more objects / interactions / overheads.</p><p name="b262" id="b262" class="graf graf--p graf-after--p">Why would a coordinator know about navigation other than its own flow in the first place? This is just basic design requirement.</p><p name="a9a1" id="a9a1" class="graf graf--p graf-after--p">Easy to maintain… compared to one file per view? I hope you at least feel plausible that I can put everything in one “view” and it will be more compact than your view + view model + coordinator.</p><p name="8892" id="8892" class="graf graf--p graf-after--p">Finally,</p><blockquote name="fb34" id="fb34" class="graf graf--blockquote graf-after--p">This approach is open to your thoughts as well. If you see anything to be improved or changed on this approach, just let me know via comments.<br>Let’s improve this together. Have a nice coding !</blockquote><p name="3e78" id="3e78" class="graf graf--p graf-after--blockquote">Well, since you asked. It’s wrong on so many levels that it needs an article review.</p><p name="bcfa" id="bcfa" class="graf graf--p graf-after--p">View model is not free, coordinator is not free, coordination and injection is not free. Everything’s got a price.</p><p name="17eb" id="17eb" class="graf graf--p graf-after--p graf--trailing">Consider this as a professional courtesy.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/e62bdf20057c"><time class="dt-published" datetime="2023-05-18T10:54:02.296Z">May 18, 2023</time></a>.</p><p><a href="https://medium.com/@swift2931/a-complete-failure-of-mvvm-c-in-swiftui-e62bdf20057c" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>