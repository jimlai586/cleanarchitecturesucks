<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Slow architecture in Swift</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Slow architecture in Swift</h1>
</header>
<section data-field="subtitle" class="p-summary">
How to fail Agile using Clean Architecture
</section>
<section data-field="body" class="e-content">
<section name="aa1e" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="3b73" id="3b73" class="graf graf--h3 graf--leading graf--title">Slow architecture in Swift</h3><h4 name="4f4a" id="4f4a" class="graf graf--h4 graf-after--h3 graf--subtitle">How to fail Agile using Clean Architecture</h4><figure name="196d" id="196d" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*a1yua78VvEPDGwVQFMA3UQ.png" data-width="698" data-height="560" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*a1yua78VvEPDGwVQFMA3UQ.png"></figure><h4 name="8027" id="8027" class="graf graf--h4 graf-after--figure">Godamn it, I was playing Diablo 4</h4><p name="f963" id="f963" class="graf graf--p graf-after--h4">Saw this when waiting my breakfast.</p><p name="4741" id="4741" class="graf graf--p graf-after--p"><a href="https://betterprogramming.pub/agile-architecture-in-swift-a7b5a4fc9773" data-href="https://betterprogramming.pub/agile-architecture-in-swift-a7b5a4fc9773" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Agile Architecture in Swift</a></p><p name="6b68" id="6b68" class="graf graf--p graf-after--p">Published in <em class="markup--em markup--p-em">Better Programming, </em>in whch he touted <strong class="markup--strong markup--p-strong">Clean Architecture</strong> as a solution to be <strong class="markup--strong markup--p-strong">more Agile</strong>.</p><p name="3afa" id="3afa" class="graf graf--p graf-after--p">I laughed my ass off. What a brilliant comedy piece from our friend at <em class="markup--em markup--p-em">Better Programming</em>.</p><p name="fc30" id="fc30" class="graf graf--p graf-after--p">I would describe Clean Architecture as clumpsy, awkward, rigid, sluggish and stupid. In fact I have to look up dictionary for adjectives, as shown in the picture above.</p><p name="a199" id="a199" class="graf graf--p graf-after--p">Dude, I came from <strong class="markup--strong markup--p-strong">Chaos </strong>development flow. Let me provide my two cents on this.</p><h4 name="fd04" id="fd04" class="graf graf--h4 graf-after--p">Introducing: Slow Architecture</h4><p name="e228" id="e228" class="graf graf--p graf-after--h4">As he pointed out:</p><blockquote name="c700" id="c700" class="graf graf--blockquote graf-after--p">For most, “agile” had become a meaningless word, just describing a marketing term for a certification industry.</blockquote><p name="de3e" id="de3e" class="graf graf--p graf-after--blockquote">You know what else is a marketing term for a certification industry?</p><p name="c20e" id="c20e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Clean Architecture</strong>.</p><p name="8f4e" id="8f4e" class="graf graf--p graf-after--p">What are the steps you take in a certification industry?</p><ol class="postList"><li name="90a0" id="90a0" class="graf graf--li graf-after--p">Hero worship</li></ol><p name="ef89" id="ef89" class="graf graf--p graf-after--li">So Bob is deified becasue he used the word “Clean” in his book. Then it must be clean, right?</p><p name="f6e5" id="f6e5" class="graf graf--p graf-after--p">2. A brand</p><p name="8fbd" id="8fbd" class="graf graf--p graf-after--p">Next step is to create your own brand, and promote it in the name of said hero. In his case,</p><blockquote name="1f30" id="1f30" class="graf graf--blockquote graf-after--p">I recently developed an Agile Architecture “Khipu” in Swift. If this interests you and your team and you want to learn more about it, feel free to contact me.</blockquote><p name="74f8" id="74f8" class="graf graf--p graf-after--blockquote">But it is doomed to fail, because the word has no meaning.</p><p name="d4ac" id="d4ac" class="graf graf--p graf-after--p">You need something that has “Clean” or “View Model” in it. You are in <strong class="markup--strong markup--p-strong">certification industry </strong>after all. This is the part where they will piggyback dumb shit under hero’s name.</p><p name="cc2f" id="cc2f" class="graf graf--p graf-after--p">3. Marketing campaign</p><p name="e3c6" id="e3c6" class="graf graf--p graf-after--p">Of course you need visibility. So you will publish it under <em class="markup--em markup--p-em">Better Programming</em>, with memebership exclusive. They will publish any dumb shit under the sun from what I can tell. I have no doubt ChatGPT can write an article to be published on <em class="markup--em markup--p-em">Better Programming </em>at this point. Or is it already?</p><p name="30a7" id="30a7" class="graf graf--p graf-after--p">Why do I bother breaking down these steps? To prepare you for the mis-direction that follows:</p><blockquote name="fcc9" id="fcc9" class="graf graf--blockquote graf-after--p">Using protocols with attributed types and nested enums to implement<strong class="markup--strong markup--blockquote-strong"> Robert C. Martin’s use cases</strong></blockquote><blockquote name="ad0b" id="ad0b" class="graf graf--blockquote graf-after--blockquote">In this article, I want to show you how I combine protocols with attributed types by building expressive yet simplistic modules that offer their own flexible and safe DSL. These are constructed by <strong class="markup--strong markup--blockquote-strong">nesting enums</strong>, associating model objects as values where needed.</blockquote><p name="c634" id="c634" class="graf graf--p graf-after--blockquote">Hero worship, brand promotion in a marketing campaign with an emphasis on the words “flexible” and “safe”.</p><p name="fc80" id="fc80" class="graf graf--p graf-after--p">This is all to distract you from asking: why <strong class="markup--strong markup--p-strong">nested </strong>enums?</p><p name="e13d" id="e13d" class="graf graf--p graf-after--p">And you won’t ask proof or comparison that it is as good as claimed either. Because it’s<strong class="markup--strong markup--p-strong"> Robert C. Martin</strong>! OMFG!</p><p name="e20f" id="e20f" class="graf graf--p graf-after--p">Be extra cautious when someone uses “nesting” as a feature not bug. And guess in what “architecture” the usage of “nesting” is normalized?</p><p name="be90" id="be90" class="graf graf--p graf-after--p">But let’s not dwell upon small techinical details. What makes it agile?</p><p name="701a" id="701a" class="graf graf--p graf-after--p">The idea is to <em class="markup--em markup--p-em">modularize </em>everything, to break things into smaller <em class="markup--em markup--p-em">use cases</em>. E.g.;</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="7fe2" id="7fe2" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AddTodoItemUseCase</span>: <span class="hljs-title class_">UseCase</span> {<br />    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Request</span>  {<br />        <span class="hljs-keyword">case</span> add (item: <span class="hljs-type">TodoItem</span>)<br />    }<br />    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Response</span> {<br />        <span class="hljs-keyword">case</span> wasAdded(item: <span class="hljs-type">TodoItem</span>)<br />    }<br />    <span class="hljs-keyword">typealias</span> <span class="hljs-type">RequestType</span> <span class="hljs-operator">=</span> <span class="hljs-type">Request</span><br />    <span class="hljs-keyword">typealias</span> <span class="hljs-type">ResponseType</span> <span class="hljs-operator">=</span> <span class="hljs-type">Response</span><br /><br />    <span class="hljs-keyword">init</span>(<span class="hljs-params">store</span>: <span class="hljs-type">StateStore</span>, <span class="hljs-params">responder</span>: <span class="hljs-keyword">@escaping</span> ((<span class="hljs-type">Response</span>) -&gt; ())) {<br />        <span class="hljs-keyword">self</span>.interactor <span class="hljs-operator">=</span> <span class="hljs-type">Interactor</span>(store: store, responder: responder)<br />    }<br /><br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">request</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">request</span>: <span class="hljs-type">Request</span>) {<br />        <span class="hljs-keyword">switch</span> request {<br />        <span class="hljs-keyword">case</span> .add(item: <span class="hljs-keyword">let</span> item):<br />            interactor.add(item: item)<br />        }<br />    }<br />    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> interactor: <span class="hljs-type">AddTodoItemUseCase</span>.<span class="hljs-type">Interactor</span><br />}</span></pre><p name="6286" id="6286" class="graf graf--p graf-after--pre">Now, can you tell you what makes this idea so <strong class="markup--strong markup--p-strong">slow</strong>?</p><ol class="postList"><li name="e899" id="e899" class="graf graf--li graf-after--p">You don’t have clearly-defined request-response most of the time</li></ol><p name="6954" id="6954" class="graf graf--p graf-after--li">In <strong class="markup--strong markup--p-strong">Chaos </strong>development, everything is changing, all the time. The last thing you need is a strict type system that incurs more costs to changing.</p><p name="92d3" id="92d3" class="graf graf--p graf-after--p">If his use case does only one thing, like he claimed:</p><blockquote name="7d92" id="7d92" class="graf graf--blockquote graf-after--p">Use cases should only do one thing, like adding items.</blockquote><p name="ffcf" id="ffcf" class="graf graf--p graf-after--blockquote">It’s just a function!</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="7d78" id="7d78" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">func</span> <span class="hljs-title function_">add</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">items</span>: [<span class="hljs-type">Item</span>]) -&gt; isSuccess {<span class="hljs-operator">...</span>}<br /><span class="hljs-comment">//  request                    response      </span></span></pre><p name="afa7" id="afa7" class="graf graf--p graf-after--pre">He said it himself:</p><blockquote name="5dc4" id="5dc4" class="graf graf--blockquote graf-after--p">The goal of this architecture is to be reasonable, meaning that at any time, you can deduct its state and logic.</blockquote><p name="2e1d" id="2e1d" class="graf graf--p graf-after--blockquote">You can deduct its state and logic from function signature at any time!</p><p name="5ccc" id="5ccc" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Robert C. Martin’s use cases, ladies and gentlemen.</strong></p><p name="4b6e" id="4b6e" class="graf graf--p graf-after--p">You may argue, but there’s interactor and store and shit. OK, let’s go into more details.</p><h4 name="f4dc" id="f4dc" class="graf graf--h4 graf-after--p">I stand by my principle until I don’t</h4><p name="af5f" id="af5f" class="graf graf--p graf-after--h4">Let’s get more context:</p><blockquote name="f855" id="f855" class="graf graf--blockquote graf-after--p"><strong class="markup--strong markup--blockquote-strong">Use cases should only do one thing</strong>, like adding items. Therefore, the request often has one command. And the response will often have two cases: one success and one failure case.<strong class="markup--strong markup--blockquote-strong"> But this is neither a law nor a rule,</strong> i.e., you might want to combine symmetric commands in one use case, such as opening and closing files.</blockquote><p name="d1b7" id="d1b7" class="graf graf--p graf-after--blockquote">So use cases should only do one thing, but this is not a rule. You can do more than one thing if you need it.</p><p name="c5bd" id="c5bd" class="graf graf--p graf-after--p">WTF?</p><p name="65b7" id="65b7" class="graf graf--p graf-after--p">He is establishing and demolishing his own rule in the same paragraph. It’s quite impressive really.</p><p name="d880" id="d880" class="graf graf--p graf-after--p">It is ChatGPT writing this, isn’t it? It is a reverse-Turing test. Only qualified human developer can pass it.</p><p name="ab11" id="ab11" class="graf graf--p graf-after--p">What’s stopping you from writing two functions?</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="a3a3" id="a3a3" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">func</span> <span class="hljs-title function_">open</span>(<span class="hljs-operator">...</span>) -&gt; <span class="hljs-type">FileStatus</span><br /><span class="hljs-keyword">func</span> <span class="hljs-title function_">close</span>(<span class="hljs-operator">...</span>) -&gt; <span class="hljs-type">FileStatus</span></span></pre><p name="64ca" id="64ca" class="graf graf--p graf-after--pre">What <strong class="markup--strong markup--p-strong">Agile </strong>benefits are you providing when you can easily do the same using functions?</p><p name="b514" id="b514" class="graf graf--p graf-after--p">If you want to consider interactor and store, then I first ask you, why is use case a value type?</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="e259" id="e259" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AddTodoItemUseCase</span>: <span class="hljs-title class_">UseCase</span></span></pre><p name="2398" id="2398" class="graf graf--p graf-after--pre">In the context of SwiftUI, this value type doesn’t conform to <code class="markup--code markup--p-code">View</code> . You can’t just put a reference type in it and pretend to be a value type.</p><p name="c757" id="c757" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">You need to justify it.</strong></p><p name="31ae" id="31ae" class="graf graf--p graf-after--p">Otherwise what’s the point of having value type if you can bypass it by accessing its member reference type?</p><p name="15de" id="15de" class="graf graf--p graf-after--p">Didn’t <strong class="markup--strong markup--p-strong">Robert C. Martin </strong>cover this in his book<strong class="markup--strong markup--p-strong">? </strong>Oh right, he didn’t.</p><p name="8bb9" id="8bb9" class="graf graf--p graf-after--p">Does he know you are writing dumb shit in his name?</p><p name="4f63" id="4f63" class="graf graf--p graf-after--p">So this use case is bullshit from the get-go. It should be reference type if it can change app state, which is a reference type passed in as parameter.</p><p name="e8fd" id="e8fd" class="graf graf--p graf-after--p">Then the logical “use case” would be</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="03a0" id="03a0" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddItemInteractor</span> {<span class="hljs-operator">...</span>}</span></pre><p name="386d" id="386d" class="graf graf--p graf-after--pre">It doesn’t need the affix <code class="markup--code markup--p-code">Interactor</code> at all, I’m just making it consistent with Clean Architecture terms.</p><p name="3351" id="3351" class="graf graf--p graf-after--p">So all the <code class="markup--code markup--p-code">Request</code> , <code class="markup--code markup--p-code">Response</code> , <code class="markup--code markup--p-code">UseCase</code> can be consolidated without loss of deductability.</p><p name="2cb0" id="2cb0" class="graf graf--p graf-after--p">This will definitely<strong class="markup--strong markup--p-strong"> NOT SCALE</strong>. Which is exactly why Clean Architecture will market it as <strong class="markup--strong markup--p-strong">SCALABLE</strong>.</p><p name="6633" id="6633" class="graf graf--p graf-after--p">The overheads of creating a type for every task will <strong class="markup--strong markup--p-strong">SLOW </strong>you down.</p><p name="9f99" id="9f99" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Function over object.</strong></p><p name="c975" id="c975" class="graf graf--p graf-after--p">Funny thing is, he knows it!</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="3f2f" id="3f2f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">typealias</span>  <span class="hljs-type">Input</span> <span class="hljs-operator">=</span> (<span class="hljs-type">Message</span>) -&gt; ()<br /><span class="hljs-keyword">typealias</span> <span class="hljs-type">Output</span> <span class="hljs-operator">=</span> (<span class="hljs-type">Message</span>) -&gt; ()<br /><br /><span class="hljs-keyword">func</span> <span class="hljs-title function_">createTodoListFeature</span>(<span class="hljs-params">store</span>: <span class="hljs-type">StateStore</span>, <span class="hljs-params">output</span>: <span class="hljs-keyword">@escaping</span> <span class="hljs-type">Output</span>) -&gt; <span class="hljs-type">Input</span> {<span class="hljs-operator">...</span>}</span></pre><p name="f7ab" id="f7ab" class="graf graf--p graf-after--pre">And he even talked about functional programming.</p><p name="7233" id="7233" class="graf graf--p graf-after--p">All these are extra complexity that you don’t need.</p><p name="a4b9" id="a4b9" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Agile</strong>. <strong class="markup--strong markup--p-strong">Robert C. Martin. Clean.</strong></p><p name="1adb" id="1adb" class="graf graf--p graf-after--p">Why is his return type <code class="markup--code markup--p-code">Input</code> … nevermind.</p><p name="5af2" id="5af2" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Agile</strong>. <strong class="markup--strong markup--p-strong">Robert C. Martin. Clean.</strong></p><p name="fdfe" id="fdfe" class="graf graf--p graf-after--p">Oh I’m sorry, he used another guy’s name</p><blockquote name="5a01" id="5a01" class="graf graf--blockquote graf-after--p">This is behaviour we know from OOP. I’d rather describe it as a variation of OOP — Message Orientated Programming or MOP.</blockquote><blockquote name="9caf" id="9caf" class="graf graf--blockquote graf-after--blockquote">If you feel this isn’t any form of OOP, please argue with the master<strong class="markup--strong markup--blockquote-strong"> Alan Kay</strong> himself.</blockquote><p name="26b3" id="26b3" class="graf graf--p graf-after--blockquote">I have no doubt Alan Kay is a master in OOP. But is he? And how valuable is OOP in a POP language?</p><p name="b0ff" id="b0ff" class="graf graf--p graf-after--p">Dude, you can’t even create a reference type object right. You know what, let’s review his code.</p><h4 name="2675" id="2675" class="graf graf--h4 graf-after--p">If your theory is so right, why is your code so shit</h4><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="16d5" id="16d5" class="graf graf--pre graf-after--h4 graf--preV2"><span class="pre--content"><span class="hljs-keyword">typealias</span>  <span class="hljs-type">Input</span> <span class="hljs-operator">=</span> (<span class="hljs-type">Message</span>) -&gt; ()<br /><span class="hljs-keyword">typealias</span> <span class="hljs-type">Output</span> <span class="hljs-operator">=</span> (<span class="hljs-type">Message</span>) -&gt; ()<br /><br /><span class="hljs-keyword">func</span> <span class="hljs-title function_">createTodoListFeature</span>(<span class="hljs-params">store</span>: <span class="hljs-type">StateStore</span>, <span class="hljs-params">output</span>: <span class="hljs-keyword">@escaping</span> <span class="hljs-type">Output</span>) -&gt; <span class="hljs-type">Input</span> {<br />    <span class="hljs-keyword">let</span> itemAdder   <span class="hljs-operator">=</span> <span class="hljs-type">AddTodoItemUseCase</span>   (store: store, responder: handle(output: output))<br />    <span class="hljs-keyword">let</span> itemDeleter <span class="hljs-operator">=</span> <span class="hljs-type">DeleteTodoItemUseCase</span>(store: store, responder: handle(output: output))<br />    <span class="hljs-keyword">let</span> itemChecker <span class="hljs-operator">=</span> <span class="hljs-type">CheckTodoItemUseCase</span> (store: store, responder: handle(output: output))<br /><br />    <span class="hljs-keyword">return</span> { msg <span class="hljs-keyword">in</span><br />        <span class="hljs-keyword">if</span> <span class="hljs-keyword">case</span> .todo(.add    (<span class="hljs-keyword">let</span> item)) <span class="hljs-operator">=</span> msg {   itemAdder.request( .add    (item: item) ) }<br />        <span class="hljs-keyword">if</span> <span class="hljs-keyword">case</span> .todo(.delete (<span class="hljs-keyword">let</span> item)) <span class="hljs-operator">=</span> msg { itemDeleter.request( .delete (item: item) ) }<br />        <span class="hljs-keyword">if</span> <span class="hljs-keyword">case</span> .todo(.check  (<span class="hljs-keyword">let</span> item)) <span class="hljs-operator">=</span> msg { itemChecker.request( .check  (item: item) ) }<br />        <span class="hljs-keyword">if</span> <span class="hljs-keyword">case</span> .todo(.uncheck(<span class="hljs-keyword">let</span> item)) <span class="hljs-operator">=</span> msg { itemChecker.request( .uncheck(item: item) ) }<br />    }<br />}</span></pre><p name="f453" id="f453" class="graf graf--p graf-after--pre">Handling cases without <code class="markup--code markup--p-code">swtich</code> means he didn’t want to handle <code class="markup--code markup--p-code">default</code> .</p><p name="b181" id="b181" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">store</code> is repeated so many times, it needs to be refactored out. It’s not like you are passing in different <code class="markup--code markup--p-code">store</code> at runtime, at least not in here.</p><p name="f4e2" id="f4e2" class="graf graf--p graf-after--p">This “message”-oriented programming that he implemented using <code class="markup--code markup--p-code">enum</code> is not new. Remember in <strong class="markup--strong markup--p-strong">Objective-C </strong>you are sending “<strong class="markup--strong markup--p-strong">message</strong>” all the time via functions? This nostalgia?</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="csharp" name="89a9" id="89a9" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">[<span class="hljs-meta">receiver message</span>]</span></pre><p name="ccc9" id="ccc9" class="graf graf--p graf-after--pre">Use function as message? Which is what I just said?</p><p name="1583" id="1583" class="graf graf--p graf-after--p">It’s dynamic, run-time, and didn’t require strict type overheads?</p><p name="aac7" id="aac7" class="graf graf--p graf-after--p">Not saying we go back to Objective-C, but is this redundant boilerplate the best we can do in Swift? <code class="markup--code markup--p-code">dynamicMemberLookup</code> might be a way to go, but let’s keep things simple.</p><p name="acc2" id="acc2" class="graf graf--p graf-after--p">What about</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="853a" id="853a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">func</span> <span class="hljs-title function_">createTodoList</span>(<span class="hljs-operator">...</span>) {<br />  <span class="hljs-comment">// store is a member property, so no need to pass it repeatedly</span><br />  <span class="hljs-keyword">try</span> {<br />    addItem(<span class="hljs-operator">...</span>)<br />    checkItem(<span class="hljs-operator">...</span>)<br />  } <span class="hljs-keyword">catch</span> {<span class="hljs-operator">...</span>}<br />}<br />  </span></pre><p name="911e" id="911e" class="graf graf--p graf-after--pre">Straight-forward.</p><p name="8424" id="8424" class="graf graf--p graf-after--p">Note that <code class="markup--code markup--p-code">@Escaping</code> closure is not a harmless decorator. It specifically <strong class="markup--strong markup--p-strong">WARNED </strong>you that your closure may implicitly capture something.</p><p name="cb4f" id="cb4f" class="graf graf--p graf-after--p">What did he do? Use it as a sign of skill, functional programming and shit.</p><p name="5667" id="5667" class="graf graf--p graf-after--p">Pass it around like candies which make it hard to track and debug.</p><p name="bd4a" id="bd4a" class="graf graf--p graf-after--p">Use <code class="markup--code markup--p-code">Output</code> to generate <code class="markup--code markup--p-code">Input</code> via escaping closure is confusing and dangerous.</p><p name="d539" id="d539" class="graf graf--p graf-after--p">The golden rule of thumb of Agile is this:</p><p name="823b" id="823b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Always assume your co-workers are dumb idiots</strong></p><p name="a483" id="a483" class="graf graf--p graf-after--p">There’s no fking possible way you can teach them <strong class="markup--strong markup--p-strong">currying </strong>without backfiring. And it is a very situational technique with a lot to consider, e.g.; abuse of escaping closures.</p><p name="86bd" id="86bd" class="graf graf--p graf-after--p">I’ll reject this submit from code replication alone, let along readability.</p><p name="db43" id="db43" class="graf graf--p graf-after--p">Oh I’m sorry. <strong class="markup--strong markup--p-strong">Agile</strong>. <strong class="markup--strong markup--p-strong">Robert C. Martin. Clean.</strong></p><p name="df25" id="df25" class="graf graf--p graf-after--p">Not only is he slowing himself down, he has to spend time bringing his team up to speed, hence slowing the team down.</p><p name="34a4" id="34a4" class="graf graf--p graf-after--p">These can be considered captital investment if the architecture is actually good, but code duplication alone would kill it, including redundant <code class="markup--code markup--p-code">request</code> — <code class="markup--code markup--p-code">response</code> and nested enum messsage.</p><p name="bca0" id="bca0" class="graf graf--p graf-after--p">One more example:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="720f" id="720f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">init</span> (<span class="hljs-keyword">_</span> <span class="hljs-params">text</span>: <span class="hljs-type">String</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">completed</span>: <span class="hljs-type">Bool</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">id</span>: <span class="hljs-type">UUID</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">dueDate</span>:<span class="hljs-type">Date</span>?, <span class="hljs-keyword">_</span> <span class="hljs-params">creationDate</span>: <span class="hljs-type">Date</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">alterDate</span>:<span class="hljs-type">Date</span>?) {<br />        <span class="hljs-keyword">self</span>.text <span class="hljs-operator">=</span> text<br />        <span class="hljs-keyword">self</span>.completed <span class="hljs-operator">=</span> completed<br />        <span class="hljs-keyword">self</span>.id <span class="hljs-operator">=</span> id<br />        <span class="hljs-keyword">self</span>.creationDate <span class="hljs-operator">=</span> creationDate<br />        <span class="hljs-keyword">self</span>.dueDate <span class="hljs-operator">=</span> dueDate<br />        <span class="hljs-keyword">self</span>.alterDate <span class="hljs-operator">=</span> alterDate<br />    }<br /><br />    <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">alter</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">change</span>:<span class="hljs-type">Change</span>) -&gt; <span class="hljs-type">TodoItem</span> {<br />        <span class="hljs-keyword">let</span> alterDate <span class="hljs-operator">=</span> <span class="hljs-type">Date</span>()<br />        <span class="hljs-keyword">switch</span> change {<br />        <span class="hljs-keyword">case</span> .text     (<span class="hljs-keyword">let</span> text     ): <span class="hljs-keyword">return</span> <span class="hljs-type">TodoItem</span>( text, completed, id, dueDate, creationDate, alterDate )<br />        <span class="hljs-keyword">case</span> .completed(<span class="hljs-keyword">let</span> completed): <span class="hljs-keyword">return</span> <span class="hljs-type">TodoItem</span>( text, completed, id, dueDate, creationDate, alterDate )<br />        <span class="hljs-keyword">case</span> .due      (<span class="hljs-keyword">let</span> dueDate  ): <span class="hljs-keyword">return</span> <span class="hljs-type">TodoItem</span>( text, completed, id, dueDate, creationDate, alterDate )<br />        }<br />    }</span></pre><p name="eba3" id="eba3" class="graf graf--p graf-after--pre">Use the default initializer man. So you don’t need <code class="markup--code markup--p-code">init()</code> .</p><p name="0c55" id="0c55" class="graf graf--p graf-after--p">Use default value man. So you don’t repeat every property. E.g.;</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="98d8" id="98d8" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">var</span> item <span class="hljs-operator">=</span> <span class="hljs-type">TodoItem</span>()<br /><span class="hljs-keyword">switch</span> change {<br />  <span class="hljs-keyword">case</span> .text(<span class="hljs-keyword">let</span> text): <br />    item.text <span class="hljs-operator">=</span> text<br />  <span class="hljs-keyword">case</span> .due(<span class="hljs-keyword">let</span> dueDate):<br />    item.dueDate <span class="hljs-operator">=</span> dueDate<br />  <span class="hljs-comment">// ...</span><br />}<br /><span class="hljs-keyword">return</span> item</span></pre><p name="12a7" id="12a7" class="graf graf--p graf-after--pre">This will come in handy when you <strong class="markup--strong markup--p-strong">CHANGE PROPERTY</strong>.</p><p name="13ac" id="13ac" class="graf graf--p graf-after--p">You could probably get away from auto-refactoring, but keep it a good practice.</p><p name="8eab" id="8eab" class="graf graf--p graf-after--p">Again, he is asking for trouble. He didn’t get it right himself, how do you expect his team that he trained to get it right?</p><p name="52a1" id="52a1" class="graf graf--p graf-after--p">I mentioned nested enum from the beginning. Here’s why:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="java" name="3332" id="3332" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">struct AppState: Codable {<br />    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Change</span> {<br /><br />        <span class="hljs-keyword">case</span> <span class="hljs-title function_">add</span><span class="hljs-params">(_Add)</span><br />        <span class="hljs-keyword">case</span> <span class="hljs-title function_">update</span><span class="hljs-params">(_Update)</span><br />        <span class="hljs-keyword">case</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(_Remove)</span><br />        <span class="hljs-keyword">case</span> <span class="hljs-title function_">replace</span><span class="hljs-params">(_Replace)</span><br /><br />        <span class="hljs-keyword">enum</span> <span class="hljs-title class_">_Add</span> {<br />            <span class="hljs-keyword">case</span> <span class="hljs-title function_">item</span><span class="hljs-params">(TodoItem)</span><br />            <span class="hljs-keyword">case</span> <span class="hljs-title function_">entry</span><span class="hljs-params">(Entry)</span><br />            <span class="hljs-keyword">case</span> <span class="hljs-title function_">tag</span><span class="hljs-params">(Tag)</span><br />        }<br />        <span class="hljs-keyword">enum</span> <span class="hljs-title class_">_Update</span>  { <span class="hljs-keyword">case</span> <span class="hljs-title function_">item</span><span class="hljs-params">(TodoItem)</span> }<br />        <span class="hljs-keyword">enum</span> <span class="hljs-title class_">_Replace</span> { <span class="hljs-keyword">case</span> <span class="hljs-title function_">tags</span><span class="hljs-params">([Tag]   )</span> }<br />        <span class="hljs-keyword">enum</span> <span class="hljs-title class_">_Remove</span>  { <span class="hljs-keyword">case</span> <span class="hljs-title function_">item</span><span class="hljs-params">(TodoItem)</span> }<br />    }<br />    <span class="hljs-comment">// ...</span><br />}</span></pre><p name="6256" id="6256" class="graf graf--p graf-after--pre">Enum-inception, which is nested inside a <code class="markup--code markup--p-code">struct</code> .</p><p name="5543" id="5543" class="graf graf--p graf-after--p">When you can flatten it with</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="f4bb" id="f4bb" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Action</span> {<br />  <span class="hljs-keyword">case</span> addItem(<span class="hljs-type">TodoItem</span>)<br />  <span class="hljs-keyword">case</span> addEntry(<span class="hljs-type">Entry</span>)<br />  <span class="hljs-keyword">case</span> updateItem(<span class="hljs-type">TodoItem</span>)<br />  <span class="hljs-operator">...</span><br />}</span></pre><p name="c4b1" id="c4b1" class="graf graf--p graf-after--pre">Or you are a puzzle enjoyer?</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="6f14" id="6f14" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">case</span> add(_Add)</span></pre><p name="6a10" id="6a10" class="graf graf--p graf-after--pre">Did <strong class="markup--strong markup--p-strong">Robert C. Martin </strong>teach you this<strong class="markup--strong markup--p-strong"> </strong>in his book?</p><p name="63de" id="63de" class="graf graf--p graf-after--p">This means you can’t just use a case. You need to prefix it with the whole family history. E.g.;</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="0a87" id="0a87" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">case</span> <span class="hljs-type">AppState</span>.<span class="hljs-type">Change</span>.add(<span class="hljs-keyword">let</span> add: _Add)</span></pre><p name="4723" id="4723" class="graf graf--p graf-after--pre">which <strong class="markup--strong markup--p-strong">SLOWS YOU DOWN</strong>!</p><p name="6c34" id="6c34" class="graf graf--p graf-after--p">Also wtf is this?</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="7da1" id="7da1" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">alter</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">change</span>:<span class="hljs-type">Change</span>) -&gt; <span class="hljs-type">AppState</span> {<br />        <span class="hljs-keyword">switch</span> change {<br />        <span class="hljs-keyword">case</span> .add    (<span class="hljs-keyword">let</span> msg): <span class="hljs-keyword">return</span> add    (msg)<br />        <span class="hljs-keyword">case</span> .update (<span class="hljs-keyword">let</span> msg): <span class="hljs-keyword">return</span> update (msg)<br />        <span class="hljs-keyword">case</span> .remove (<span class="hljs-keyword">let</span> msg): <span class="hljs-keyword">return</span> remove (msg)<br />        <span class="hljs-keyword">case</span> .replace(<span class="hljs-keyword">let</span> msg): <span class="hljs-keyword">return</span> replace(msg)<br />        }<br />    }</span></pre><p name="2860" id="2860" class="graf graf--p graf-after--pre">State change logic shouldn’t be inside value type. But this seems too trivial for that.</p><p name="5101" id="5101" class="graf graf--p graf-after--p">But on the other hand, if it didn’t do shit, why is it here?</p><p name="d704" id="d704" class="graf graf--p graf-after--p">This is as boilerplate as it gets, and you don’t have time to write redundant shit. And guess what happens when you add / remove cases… how many places you have to re-visit?</p><p name="c42b" id="c42b" class="graf graf--p graf-after--p">All this setup so he can write this?</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="0be1" id="0be1" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">remove</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">change</span>: <span class="hljs-type">Change</span>._Remove) -&gt; <span class="hljs-type">AppState</span> {<br />      <span class="hljs-keyword">switch</span> change {<br />      <span class="hljs-keyword">case</span> .item(<span class="hljs-keyword">let</span> item): <span class="hljs-keyword">return</span> <span class="hljs-type">AppState</span>( items.filter{ <span class="hljs-variable">$0</span>.id <span class="hljs-operator">!=</span> item.id }, entries, tags.map( { <span class="hljs-variable">$0</span>.alter(.remove(item)) } ) )<br />      }<br />  }</span></pre><p name="d049" id="d049" class="graf graf--p graf-after--pre">Wtf knows what he is writing about?</p><p name="7f49" id="7f49" class="graf graf--p graf-after--p">I speak it from a perspective of a dumb idiot co-worker that you might run in. Wtf is <code class="markup--code markup--p-code">$0</code> ???</p><p name="a827" id="a827" class="graf graf--p graf-after--p">Dude you have a reference type <code class="markup--code markup--p-code">AppStore</code> that you pass in everywhere. Use it!!!!!! E.g.;</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="3027" id="3027" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">store.change(<span class="hljs-keyword">_</span> newState: .remove(item))</span></pre><p name="3d30" id="3d30" class="graf graf--p graf-after--pre">Dependency injection!!!</p><p name="3cad" id="3cad" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">What Robert C. Martin’s book is all about!!!!!!!!!!!!!</strong></p><p name="9a2b" id="9a2b" class="graf graf--p graf-after--p">How the F do you fail the one thing noteworthy in his book? The thing Clean Architecture never shuts up about?</p><h4 name="6150" id="6150" class="graf graf--h4 graf-after--p">I can’t. The shit is too stupid.</h4><p name="02ce" id="02ce" class="graf graf--p graf-after--h4">Uh, I mean as in the opposite of <strong class="markup--strong markup--p-strong">Agile</strong>.</p><p name="af26" id="af26" class="graf graf--p graf-after--p">It’s in the dictionary, look:</p><figure name="163c" id="163c" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*R7K23gQMGpWAaen_P4cVOw.png" data-width="698" data-height="560" src="https://cdn-images-1.medium.com/max/800/1*R7K23gQMGpWAaen_P4cVOw.png"></figure><p name="9516" id="9516" class="graf graf--p graf-after--figure">I don’t have time to review every bit of his code. Because it would take away more of my time playing Diablo 4.</p><p name="429b" id="429b" class="graf graf--p graf-after--p">I’m going to wrap up by just looking at one of his tests. That he is so proud of and throws buzzwords like BDD around.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="6883" id="6883" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TodoItemSpec</span> : <span class="hljs-title class_">QuickSpec</span> {<br />    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">spec</span>() {<br />        describe(<span class="hljs-string">&quot;TodoItem&quot;</span>) {<br />            <span class="hljs-keyword">let</span> orig <span class="hljs-operator">=</span> <span class="hljs-type">TodoItem</span>(text:<span class="hljs-string">&quot;Hey Ho&quot;</span>)<br />            context(<span class="hljs-string">&quot;creation default&quot;</span>) {<br />                <span class="hljs-keyword">let</span> now <span class="hljs-operator">=</span> <span class="hljs-type">Date</span>()<br />                it(<span class="hljs-string">&quot;has custom text&quot;</span>          ) { expect( orig.text         ) <span class="hljs-operator">==</span> <span class="hljs-string">&quot;Hey Ho&quot;</span>        }<br />                it(<span class="hljs-string">&quot;has random id&quot;</span>            ) { expect( orig.id           ).toNot(beNil())     }<br />                it(<span class="hljs-string">&quot;is not completed&quot;</span>         ) { expect( orig.completed    ) <span class="hljs-operator">==</span> <span class="hljs-literal">false</span>           }<br />                it(<span class="hljs-string">&quot;has the creation date set&quot;</span>) { expect( orig.creationDate ).to(beCloseTo(now)) }<br />                it(<span class="hljs-string">&quot;has no due date set&quot;</span>      ) { expect( orig.dueDate      ).to(beNil())        }<br />                it(<span class="hljs-string">&quot;has no alter date set&quot;</span>    ) { expect( orig.alterDate    ).to(beNil())        }<br />            }<br />        }<br />    }<br />}</span></pre><p name="03c1" id="03c1" class="graf graf--p graf-after--pre">What’s wrong with this?</p><p name="c4fd" id="c4fd" class="graf graf--p graf-after--p">You have to know precisely how <code class="markup--code markup--p-code">TodoItem</code> is defined.</p><p name="dbc4" id="dbc4" class="graf graf--p graf-after--p">You don’t. Models change all the time, behaviors change all the time, features change all the time. That is, spec changes all the time.</p><p name="4f56" id="4f56" class="graf graf--p graf-after--p">If spec changes, you now have at least one more place to modify, which cannot be done by auto-refactoring. This manual work <strong class="markup--strong markup--p-strong">SLOWS </strong>you down.</p><p name="2664" id="2664" class="graf graf--p graf-after--p">What value does this test provide?</p><p name="3799" id="3799" class="graf graf--p graf-after--p">No spec will tell you what variables you should use and their initial values. Dude they are written by PM. They focus on features. It is your job to handle implementation.</p><p name="6f9e" id="6f9e" class="graf graf--p graf-after--p">So you are glimping yourself by dictating what variables and their inital values should be. Nobody gives a shit.</p><p name="4400" id="4400" class="graf graf--p graf-after--p">Is the feature complete or not, do they pass QA or not. That’s the things that matter.</p><p name="2d21" id="2d21" class="graf graf--p graf-after--p">For an architecture that builds around state management, this is just stupid.</p><p name="c221" id="c221" class="graf graf--p graf-after--p">The only thing you should check is state. E.g.;</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="c38a" id="c38a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">func</span> <span class="hljs-title function_">testUpdate</span>() {<br />  <span class="hljs-built_in">assert</span>(store.state <span class="hljs-operator">==</span> .initial)<br />  store.update(<span class="hljs-operator">...</span>)<br />  <span class="hljs-built_in">assert</span>(store.state <span class="hljs-operator">==</span> .updateSuccess)<br />}</span></pre><p name="b63c" id="b63c" class="graf graf--p graf-after--pre">The rest follows from <em class="markup--em markup--p-em">state</em>. This <em class="markup--em markup--p-em">decouples </em>you from implementation details. You don’t check every property at every time like an idiot!</p><p name="64ac" id="64ac" class="graf graf--p graf-after--p">This is just part of the “tests” of ONE model type at differnt times:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="70c4" id="70c4" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">spec</span>() {<br />        describe(<span class="hljs-string">&quot;TodoItem&quot;</span>) {<br />            <span class="hljs-keyword">let</span> orig <span class="hljs-operator">=</span> <span class="hljs-type">TodoItem</span>(text:<span class="hljs-string">&quot;Hey Ho&quot;</span>)<br />            context(<span class="hljs-string">&quot;default&quot;</span>) {<br />                <span class="hljs-comment">// ...</span><br />            }<br /><br />            context(<span class="hljs-string">&quot;altering&quot;</span>) {<br />                <span class="hljs-keyword">let</span> new <span class="hljs-operator">=</span> orig.alter(.completed(<span class="hljs-literal">true</span>))<br />                context(<span class="hljs-string">&quot;check&quot;</span>) {<br />                    it(<span class="hljs-string">&quot;changes completed&quot;</span>           ) { expect( new.completed <span class="hljs-operator">==</span> <span class="hljs-literal">true</span> ) <span class="hljs-operator">!=</span> orig.completed }<br />                    it(<span class="hljs-string">&quot;doesnt changes the id&quot;</span>       ) { expect( new.id           ) <span class="hljs-operator">==</span> orig.id           }<br />                    it(<span class="hljs-string">&quot;doesnt changes the text&quot;</span>     ) { expect( new.text         ) <span class="hljs-operator">==</span> orig.text         }<br />                    it(<span class="hljs-string">&quot;changes the alterDate&quot;</span>       ) { expect( new.alterDate    ).toNot(beNil()) ; expect( orig.alterDate ).to(beNil()) }<br />                    it(<span class="hljs-string">&quot;doesn&#x27;t change the due date&quot;</span> ) { expect( new.dueDate      ).to   (beNil()) ; expect( orig.dueDate   ).to(beNil()) }<br />                    it(<span class="hljs-string">&quot;doesn&#x27;t change creation date&quot;</span>) { expect( new.creationDate ) <span class="hljs-operator">==</span> orig.creationDate }<br />                }<br />                context(<span class="hljs-string">&quot;uncheck&quot;</span>) {<br />                    <span class="hljs-keyword">let</span> orig <span class="hljs-operator">=</span> new<br />                    <span class="hljs-keyword">let</span> new <span class="hljs-operator">=</span> orig.alter(.complete(<span class="hljs-literal">false</span>))<br />                    it(<span class="hljs-string">&quot;changes completed&quot;</span>           ) { expect( new.completed    ) <span class="hljs-operator">!=</span> orig.completed    }<br />                    it(<span class="hljs-string">&quot;doesnt changes the id&quot;</span>       ) { expect( new.id           ) <span class="hljs-operator">==</span> orig.id           }<br />                    it(<span class="hljs-string">&quot;doesnt changes the text&quot;</span>     ) { expect( new.text         ) <span class="hljs-operator">==</span> orig.text         }<br />                    it(<span class="hljs-string">&quot;changes the alterDate&quot;</span>       ) { expect( new.alterDate    ) <span class="hljs-operator">&gt;</span>  orig.alterDate<span class="hljs-operator">!</span>   }<br />                    it(<span class="hljs-string">&quot;doesn&#x27;t change the due date&quot;</span> ) { expect( new.dueDate      ).to (beNil()) ; expect( orig.dueDate ).to(beNil()) }<br />                    it(<span class="hljs-string">&quot;doesn&#x27;t change creation date&quot;</span>) { expect( new.creationDate ) <span class="hljs-operator">==</span> orig.creationDate }<br />                  }<br />            }<br />        }<br />    }</span></pre><p name="54e9" id="54e9" class="graf graf--p graf-after--pre">You will never get to the end of it. Too many possibilities. What if you change parameters? E.g.; add a different item. And all these are worthless if design changes.</p><p name="5968" id="5968" class="graf graf--p graf-after--p">Really? This is the BDD Clean Architecture? Did they cover this in the book or…?</p><p name="3b13" id="3b13" class="graf graf--p graf-after--p">And is this the “readability” I’ve heard so much about?</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="d750" id="d750" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">let</span> fork <span class="hljs-operator">=</span> orig.alter(.fork([.due(orig.dueDate<span class="hljs-operator">?</span>.dayAfter), .completed(<span class="hljs-operator">!</span>orig.completed), .fork([.text(<span class="hljs-string">&quot;Let&#x27;s go&quot;</span>)])]))</span></pre><p name="8c83" id="8c83" class="graf graf--p graf-after--pre">I especially love that he had <code class="markup--code markup--p-code">store</code> and everything, but he gets to change state without going through <code class="markup--code markup--p-code">store</code> . Not that I can see from above.</p><p name="3b4e" id="3b4e" class="graf graf--p graf-after--p">Finally, let’s summarize what did we learn.</p><blockquote name="14ed" id="14ed" class="graf graf--blockquote graf-after--p">What Did We Learn From This Exercise?</blockquote><blockquote name="50a6" id="50a6" class="graf graf--blockquote graf-after--blockquote">First of all, adding features is purely additive in this architecture.<br>We didn’t need to go through jungle-like code paths and alter complex statements.</blockquote><blockquote name="8a3a" id="8a3a" class="graf graf--blockquote graf-after--blockquote">We didn’t even have to code anything where our todo items were changed. We listen for the message that the change occurred. We are using true black boxes.</blockquote><blockquote name="5e7e" id="5e7e" class="graf graf--blockquote graf-after--blockquote">We have seen that feature can resemble a sink. They can also resemble a source, i.e., chat inboxes, heartbeat clocks.</blockquote><blockquote name="dbb6" id="dbb6" class="graf graf--blockquote graf-after--blockquote">It took me mere minutes to implement this. I have seen teams struggle with the same task for months.</blockquote><p name="8e3b" id="8e3b" class="graf graf--p graf-after--blockquote">First of all, he went through jungle-like <strong class="markup--strong markup--p-strong">NESTED </strong>code paths and alter complex statements. E.g.;</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="522c" id="522c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">let</span> fork <span class="hljs-operator">=</span> orig.alter(.fork([.due(orig.dueDate<span class="hljs-operator">?</span>.dayAfter), .completed(<span class="hljs-operator">!</span>orig.completed), .fork([.text(<span class="hljs-string">&quot;Let&#x27;s go&quot;</span>)])]))</span></pre><p name="01da" id="01da" class="graf graf--p graf-after--pre">He coded <strong class="markup--strong markup--p-strong">EVERYTHING </strong>where his todo items were changed.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="81b3" id="81b3" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">context(<span class="hljs-string">&quot;uncheck&quot;</span>) {<br />                    <span class="hljs-keyword">let</span> orig <span class="hljs-operator">=</span> new<br />                    <span class="hljs-keyword">let</span> new <span class="hljs-operator">=</span> orig.alter(.complete(<span class="hljs-literal">false</span>))<br />                    it(<span class="hljs-string">&quot;changes completed&quot;</span>           ) { expect( new.completed    ) <span class="hljs-operator">!=</span> orig.completed    }<br />                    it(<span class="hljs-string">&quot;doesnt changes the id&quot;</span>       ) { expect( new.id           ) <span class="hljs-operator">==</span> orig.id           }<br />                    it(<span class="hljs-string">&quot;doesnt changes the text&quot;</span>     ) { expect( new.text         ) <span class="hljs-operator">==</span> orig.text         }<br />                    it(<span class="hljs-string">&quot;changes the alterDate&quot;</span>       ) { expect( new.alterDate    ) <span class="hljs-operator">&gt;</span>  orig.alterDate<span class="hljs-operator">!</span>   }<br />                    it(<span class="hljs-string">&quot;doesn&#x27;t change the due date&quot;</span> ) { expect( new.dueDate      ).to (beNil()) ; expect( orig.dueDate ).to(beNil()) }<br />                    it(<span class="hljs-string">&quot;doesn&#x27;t change creation date&quot;</span>) { expect( new.creationDate ) <span class="hljs-operator">==</span> orig.creationDate }<br />                  }</span></pre><p name="c556" id="c556" class="graf graf--p graf-after--pre">It took him <strong class="markup--strong markup--p-strong">HOURS </strong>at <strong class="markup--strong markup--p-strong">MINIMUM </strong>to implement this. Look at above.</p><blockquote name="b133" id="b133" class="graf graf--blockquote graf-after--p">I have seen teams struggle with the same task for months.</blockquote><p name="7e1b" id="7e1b" class="graf graf--p graf-after--blockquote">Because they run <strong class="markup--strong markup--p-strong">Clean Architecutre</strong>?</p><p name="38dc" id="38dc" class="graf graf--p graf-after--p">Oh I’m sorry.</p><p name="ffdb" id="ffdb" class="graf graf--p graf-after--p graf--trailing"><strong class="markup--strong markup--p-strong">Agile</strong>. <strong class="markup--strong markup--p-strong">Robert C. Martin. Clean.</strong></p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/61e1c55966b8"><time class="dt-published" datetime="2023-06-21T07:12:40.791Z">June 21, 2023</time></a>.</p><p><a href="https://medium.com/@swift2931/slow-architecture-in-swift-61e1c55966b8" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>