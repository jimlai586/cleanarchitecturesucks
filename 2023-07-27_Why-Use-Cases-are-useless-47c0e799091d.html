<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Why Use Cases are useless</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Why Use Cases are useless</h1>
</header>
<section data-field="subtitle" class="p-summary">
I, Refactor
</section>
<section data-field="body" class="e-content">
<section name="f0e9" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="a60a" id="a60a" class="graf graf--h3 graf--leading graf--title">Why Use Cases are useless</h3><h4 name="5d96" id="5d96" class="graf graf--h4 graf-after--h3 graf--subtitle">I, Refactor</h4><figure name="9bac" id="9bac" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*Uux_5eev8F98DsrZ4WO2ng.jpeg" data-width="1167" data-height="500" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*Uux_5eev8F98DsrZ4WO2ng.jpeg"><figcaption class="imageCaption">Do you think we were all built for a purpose?</figcaption></figure><h4 name="a9c5" id="a9c5" class="graf graf--h4 graf-after--figure">Denser alloy</h4><p name="089b" id="089b" class="graf graf--p graf-after--h4">I read it somewhere that some Android dev team can output twice as much as iOS team because of the “reusability” provided by <em class="markup--em markup--p-em">Clean Architecture</em>.</p><p name="6fa3" id="6fa3" class="graf graf--p graf-after--p">Wait, you mean <strong class="markup--strong markup--p-strong">Bob’s Brute Force Boilerplate</strong>? That <em class="markup--em markup--p-em">Clean Architecure</em>?</p><p name="f34a" id="f34a" class="graf graf--p graf-after--p">But hey, maybe I was wrong. So I embarked on a pilgrimage, to learn from wiser Android devs. It is in the mountains of Tibet I found this article:</p><p name="be2b" id="be2b" class="graf graf--p graf-after--p"><a href="https://proandroiddev.com/why-you-need-use-cases-interactors-142e8a6fe576" data-href="https://proandroiddev.com/why-you-need-use-cases-interactors-142e8a6fe576" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Why you need Use Cases/Interactors</a></p><p name="cab5" id="cab5" class="graf graf--p graf-after--p">This is from 2019. I’m going to provide a “modern” 2023 view, argue its problems, and why Swift / POP is built for that purpose.</p><h4 name="1385" id="1385" class="graf graf--h4 graf-after--p">First law of refactor</h4><blockquote name="610e" id="610e" class="graf graf--blockquote graf-after--h4">Hologram of Dr. Lanning<strong class="markup--strong markup--blockquote-strong">:</strong> I’m sorry, my responses are limited…you must ask the right questions.</blockquote><p name="f844" id="f844" class="graf graf--p graf-after--blockquote">His article is to answer the question:</p><p name="509b" id="509b" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">Why should I have a Use Case that does nothing other than just calling a Repository, isn’t this an overkill for my app?</em></p><p name="6ba9" id="6ba9" class="graf graf--p graf-after--p">My answer is the opposite. You shouldn’t. Be very suspicious when something called <em class="markup--em markup--p-em">Clean Architecture</em> asked you to write redundant boilerplate.</p><p name="4375" id="4375" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">First law of refactor: Don’t make excuses for repeats / redundant shit.</strong></p><p name="2afc" id="2afc" class="graf graf--p graf-after--p">This is a lot harder than you think, for example:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="kotlin" name="edcf" id="edcf" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><br /><span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionsViewModelImpl</span>(<br />    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> userRepository: UserRepository,<br />    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> transactionRepository: TransactionRepository<br />) : TransactionsViewModel, ViewModel() {</span></pre><p name="a713" id="a713" class="graf graf--p graf-after--pre">How many times do you need to repeat “ViewModel”, “Repository”?</p><p name="9b05" id="9b05" class="graf graf--p graf-after--p">If your mindset is that this is impossible, then</p><figure name="b0e8" id="b0e8" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*YiPEvrUEDKpImkfiA4dlWw.jpeg" data-width="300" data-height="168" src="https://cdn-images-1.medium.com/max/800/1*YiPEvrUEDKpImkfiA4dlWw.jpeg"></figure><p name="318f" id="318f" class="graf graf--p graf-after--figure">you lost an opportunity to create SwiftUI.</p><p name="ca8e" id="ca8e" class="graf graf--p graf-after--p">Your skill of refactor only improves when you try to refactor something seemingly impossible.</p><p name="edc4" id="edc4" class="graf graf--p graf-after--p">On the other hand, if you are complacent, you might confuse brute force for brilliance. Do you ever wonder why these “view model” and “repository” have <strong class="markup--strong markup--p-strong">DEPENDENCIES </strong>on specific model or “use case”? In an architecture that is all about <strong class="markup--strong markup--p-strong">REMOVE DEPENDENCIES</strong>?</p><p name="80f0" id="80f0" class="graf graf--p graf-after--p">E.g.; <code class="markup--code markup--p-code">UserRepository</code> , <code class="markup--code markup--p-code">TransactionsViewModel</code></p><p name="2f7f" id="2f7f" class="graf graf--p graf-after--p">This is interesting. Because if you want reusability, the last thing you want is to tie it to something specifc.</p><p name="f496" id="f496" class="graf graf--p graf-after--p">You wouldn’t create a <code class="markup--code markup--p-code">UserNetworkService</code> , right? You create <code class="markup--code markup--p-code">NetworkService</code> that can be used regardless of the underlying data model.</p><p name="f26d" id="f26d" class="graf graf--p graf-after--p">And we are also told that Android team that practiced <strong class="markup--strong markup--p-strong">BBFB (Bob’s brute force boilerplate, a.k.a Clean Architecture) </strong>have x2 productivity <strong class="markup--strong markup--p-strong">DESPITE OF</strong> writing boilerplate and case-dependent repositories / view models / use cases.</p><p name="8258" id="8258" class="graf graf--p graf-after--p">Which means we are about to see some <strong class="markup--strong markup--p-strong">MIND BLOWING</strong> refactor techniques to achive such reusability that this is even possible.</p><p name="8f37" id="8f37" class="graf graf--p graf-after--p">I hope you are on the edge your seat, teeming with excitement now.</p><h4 name="d021" id="d021" class="graf graf--h4 graf-after--p">2 = 1 + 1 + 0.5</h4><p name="f31d" id="f31d" class="graf graf--p graf-after--h4">First I need to comment on how useless interface (protocol in Swift) is in BBFB.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="kotlin" name="e2c8" id="e2c8" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">// User</span><br /><span class="hljs-keyword">interface</span> <span class="hljs-title class_">GetCurrentUserUseCase</span> {<br />    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">()</span></span>: Result&lt;User&gt;<br />}<br /><br /><span class="hljs-comment">// Transaction</span><br /><span class="hljs-keyword">interface</span> <span class="hljs-title class_">GetUserTransactionsUseCase</span> {<br /><br />    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">()</span></span>: Single&lt;Result&lt;List&lt;Transaction&gt;&gt;&gt;<br /><br />}</span></pre><p name="0bff" id="0bff" class="graf graf--p graf-after--pre">The two only differ in return type. What’s the first law?</p><p name="81c9" id="81c9" class="graf graf--p graf-after--p">This seems impossible, let me think. Uh… hmm… <code class="markup--code markup--p-code">func invoke&lt;T&gt;() -&gt; T</code> ? (note I use Swift syntax)</p><p name="c6ab" id="c6ab" class="graf graf--p graf-after--p">But this requires us to break BBFB. Because use cases are useless now.</p><p name="e66d" id="e66d" class="graf graf--p graf-after--p">Which comes first? Abstract architecture model based on abstract principles? Or basic refactor?</p><p name="2b35" id="2b35" class="graf graf--p graf-after--p">To be fair, architecture and implementation are two things. Bob might as well be right in his architecture, it’s just people who implemented it suck.</p><p name="2938" id="2938" class="graf graf--p graf-after--p">How do you know you are not being bamboozled by people who just want to sell tutorials? First law. Did he make excuses? Did you?</p><p name="d77d" id="d77d" class="graf graf--p graf-after--p">This is such a brute force shit that you can’t even find it among beginners. They will ask why you need this shit. It’s funny how the turn tables.</p><p name="8cb5" id="8cb5" class="graf graf--p graf-after--p">But let’s look at larger context, maybe there’s some redeeming value.</p><blockquote name="c257" id="c257" class="graf graf--blockquote graf-after--p">At first look, you should notice that thanks to Use Cases our ViewModel is much leaner since we get rid of the dataflow logic.</blockquote><p name="bdc1" id="bdc1" class="graf graf--p graf-after--blockquote">Wrong! He didn’t get rid of the dataflow logic. He <em class="markup--em markup--p-em">moved </em>it elsewhere.</p><p name="f48c" id="f48c" class="graf graf--p graf-after--p">This is how math works: 2 = 1 + 1 + 0.5.</p><p name="c665" id="c665" class="graf graf--p graf-after--p">Say his view model has 20 lines of code. He moved 10 lines out. His view model is now <em class="markup--em markup--p-em">Clean</em>. OK. But that 10 lines has to go somewhere, say <code class="markup--code markup--p-code">GetCurrentUserUseCase</code> , then <code class="markup--code markup--p-code">GetCurrentUserUseCase</code> got worse. And you need 5 lines of overhead to create interface, pass parameters… etc.</p><p name="da81" id="da81" class="graf graf--p graf-after--p">In normal situation, this kind of trade-off is justified by increased reusability. But since he tied use case to <code class="markup--code markup--p-code">GetCurrentUser</code> , that reusability is reduced. In his example:</p><blockquote name="7afc" id="7afc" class="graf graf--blockquote graf-after--p">You should also be able to see how the first approach without Use Cases doesn’t scale very well: if our <strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">TransactionRepository</em></strong> now needs an extra parameter coming from another repository our <strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">TransactionsViewModel</em></strong> will need to use an additional repository and maybe handle an extra success/failure logic as well.</blockquote><p name="80ea" id="80ea" class="graf graf--p graf-after--blockquote">This is the same math problem that I’m going to break down.</p><p name="fb97" id="fb97" class="graf graf--p graf-after--p">First you move every shit to view model. 2 = 1 + 1 + 0.5. Your view is clean.</p><p name="1aa7" id="1aa7" class="graf graf--p graf-after--p">But then your view model got worse:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="kotlin" name="37ad" id="37ad" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionsViewModelImpl</span>(<br />    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> userRepository: UserRepository,<br />    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> transactionRepository: TransactionRepository<br />) : TransactionsViewModel, ViewModel()</span></pre><p name="d15c" id="d15c" class="graf graf--p graf-after--pre">So you move every shit to use case:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="kotlin" name="ebd5" id="ebd5" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionsViewModelImpl</span>(<br />    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> getUserTransactionsUseCase: GetUserTransactionsUseCase<br />) : TransactionsViewModel, ViewModel() {</span></pre><p name="d1e1" id="d1e1" class="graf graf--p graf-after--pre">2 = 1 + 1 + 0.5. Now your view model is clean. But your use case got worse…</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="kotlin" name="cf5a" id="cf5a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GetUserTransactionsUseCaseImpl</span>(<br />    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> getCurrentUserUseCase: GetCurrentUserUseCase,<br />    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> transactionRepository: TransactionRepository<br />) : GetUserTransactionsUseCase {<br /><br />    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">()</span></span>: Single&lt;Result&lt;List&lt;Transaction&gt;&gt;&gt; {<br />        <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> result = getCurrentUserUseCase()) {<br />            <span class="hljs-keyword">is</span> Result.Success -&gt; transactionRepository.getUserTransactions(result.value)<br />            <span class="hljs-keyword">is</span> Result.Failure -&gt; Single.just(Result.Failure(result.throwable))<br />        }<br />    }<br /><br />}</span></pre><p name="a590" id="a590" class="graf graf--p graf-after--pre">The process can go on, for example, what if view model needs another use case?</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="kotlin" name="fb3b" id="fb3b" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionsViewModelImpl</span>(<br />    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> getUserTransactionsUseCase: GetUserTransactionsUseCase<br />    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> dogShitUseCase: DogShitUseCase<br />) : TransactionsViewModel, ViewModel() {</span></pre><p name="a8b8" id="a8b8" class="graf graf--p graf-after--pre">Nested 3 level use case? Is there an end to this hypothetical need for infinite generalization? And note that your code is not reduced / simplified in any way! Whatever dog shit you had before, you have it now, just in 10 different places, with extra dog shit as overhead.</p><p name="09ef" id="09ef" class="graf graf--p graf-after--p">This is such an iconic skill of MVVM devs. <strong class="markup--strong markup--p-strong">“If you don’t see it, it doesn’t exist”.</strong> You know this shit is implemented and shilled by MVVM devs just from this.</p><p name="dbf2" id="dbf2" class="graf graf--p graf-after--p">View model <em class="markup--em markup--p-em">can </em>reduce code provided proper SDK support, and as a means to refactor UI updates. But modern SDK like SwiftUI made it so that it is the only way to update UI without you needing to write view model. Even in UIKit a good dev could use property observer to refactor UI updates in a similar way.</p><p name="2dea" id="2dea" class="graf graf--p graf-after--p">Remember when view model is supposed to solve “massive view controller”?</p><p name="e65d" id="e65d" class="graf graf--p graf-after--p">Look at what he said:</p><blockquote name="3010" id="3010" class="graf graf--blockquote graf-after--p">Avoid “God” Presenters/ViewModels</blockquote><blockquote name="e03c" id="e03c" class="graf graf--blockquote graf-after--blockquote">What happens when we don’t separate properly the concerns? The answer is “we have god objects”.</blockquote><p name="c1ee" id="c1ee" class="graf graf--p graf-after--blockquote">So your solution may still become God object… Aren’t we owed an apology from those pumping MVVM?</p><p name="0aa3" id="0aa3" class="graf graf--p graf-after--p">Back to his last point:</p><blockquote name="8d98" id="8d98" class="graf graf--blockquote graf-after--p">And at last reusability: thanks to those Use Cases if you have another ViewModel that uses the same dataflow logic you can reuse the same Use Cases.</blockquote><p name="0be7" id="0be7" class="graf graf--p graf-after--blockquote">No. Because <code class="markup--code markup--p-code">UserTransactionUseCase</code> depends on <code class="markup--code markup--p-code">UserTransaction</code> . What if I want <code class="markup--code markup--p-code">Transaction </code>but not <code class="markup--code markup--p-code">User</code> ?</p><p name="6fb8" id="6fb8" class="graf graf--p graf-after--p">Remember there’s a poor sucker somewhere that has to initialize this use case with nested dependencies on other use cases and repositories? If you just want to reuse dataflow logic from <code class="markup--code markup--p-code">Transaction</code> , you become that sucker!</p><p name="81fa" id="81fa" class="graf graf--p graf-after--p">2 = 1 + 1 + 0.5. That 0.5 will keep accumulating and drop on some poor sucker. I haven’t even considered the problems of inheritance, and different view models modifying shared use case.</p><p name="6c76" id="6c76" class="graf graf--p graf-after--p">Now, let’s examine his arguments on why use cases are not useless.</p><h4 name="23e4" id="23e4" class="graf graf--h4 graf-after--p">You are experiencing a car accident</h4><blockquote name="aa35" id="aa35" class="graf graf--blockquote graf-after--h4"><strong class="markup--strong markup--blockquote-strong">NS5 Robots : </strong><em class="markup--em markup--blockquote-em">[Jumps on car and tries to steer car out of control] </em>You are experiencing a car accident.</blockquote><blockquote name="257a" id="257a" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong">Detective Del Spooner : </strong>The hell I am.</blockquote><ol class="postList"><li name="ccd3" id="ccd3" class="graf graf--li graf-after--blockquote">Consistency</li></ol><p name="e60d" id="e60d" class="graf graf--p graf-after--li">He meant peer pressure. Look, I wrote this shit, and it seemed dumb, but Bob said it’s clean in his book two decades ago, so it’s clean.</p><p name="4a21" id="4a21" class="graf graf--p graf-after--p">If you wrote this shit too, we can publish on <em class="markup--em markup--p-em">Better Programming</em> and monetize it, and sell tutorials later.</p><p name="9974" id="9974" class="graf graf--p graf-after--p">You in?</p><p name="90f5" id="90f5" class="graf graf--p graf-after--p">2. They protect the code from future changes</p><p name="bb20" id="bb20" class="graf graf--p graf-after--p">This is what I love about BBFB. I’m going to design a system that supports runtime module swapping by injecting any and all dependencies on the off chance that someday, maybe, if we are lucky, we need to add a parameter to some function.</p><p name="0389" id="0389" class="graf graf--p graf-after--p">Make your functions to be extendible and configurable. Where’s this principle in SOLID? Or in Bob’s book?</p><p name="51ec" id="51ec" class="graf graf--p graf-after--p">Let’s look his example:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="kotlin" name="a5f0" id="a5f0" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SomeRepository</span> {<br />    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span><br />}<br /><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeViewModel1</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> someRepository: SomeRepository) {<br />    <span class="hljs-comment">//...</span><br />    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> {<br />        <span class="hljs-comment">//...</span><br />        someRepository.doSomething()<br />        <span class="hljs-comment">//...</span><br />    }<br />    <span class="hljs-comment">//...</span><br />}<br /><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeViewModel2</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> someRepository: SomeRepository) {<br />    <span class="hljs-comment">//...</span><br />    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> {<br />        <span class="hljs-comment">//...</span><br />        someRepository.doSomething()<br />        <span class="hljs-comment">//...</span><br />    }<br />    <span class="hljs-comment">//...</span><br />}</span></pre><blockquote name="7839" id="7839" class="graf graf--blockquote graf-after--pre">If the requirements for the repository change, let’s say the <strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">doSomething</em></strong> method now needs a model coming from a <strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">SomeOtherRepository</em></strong>, how much code do you need to change?<br>How many ViewModels are affected?</blockquote><p name="180d" id="180d" class="graf graf--p graf-after--blockquote">0. Because I don’t even have view models or repositories.</p><p name="07b6" id="07b6" class="graf graf--p graf-after--p">In this case it might be</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="485a" id="485a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">// in class C1</span><br />service.doSomething()<br /><span class="hljs-comment">// in class C2</span><br />service.doSomething()</span></pre><p name="f15d" id="f15d" class="graf graf--p graf-after--pre">To his hypothetical question, if <code class="markup--code markup--p-code">service</code> needs something from another object, let <code class="markup--code markup--p-code">service</code> worry about it. It has nothing to do with caller unless it’s a parameter that caller needs to provide.</p><p name="775a" id="775a" class="graf graf--p graf-after--p">This shit is not even new, good ol “encapsulation” from OOP. What is it that you gain from runtime module swapping by injecting any and all dependencies?</p><p name="d7e3" id="d7e3" class="graf graf--p graf-after--p">Revisit his use case:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="kotlin" name="8a0e" id="8a0e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GetUserTransactionsUseCaseImpl</span>(<br />    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> getCurrentUserUseCase: GetCurrentUserUseCase,<br />    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> transactionRepository: TransactionRepository<br />) : GetUserTransactionsUseCase {<br /><br />    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">()</span></span>: Single&lt;Result&lt;List&lt;Transaction&gt;&gt;&gt; {<br />        <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> result = getCurrentUserUseCase()) {<br />            <span class="hljs-keyword">is</span> Result.Success -&gt; transactionRepository.getUserTransactions(result.value)<br />            <span class="hljs-keyword">is</span> Result.Failure -&gt; Single.just(Result.Failure(result.throwable))<br />        }<br />    }<br />}</span></pre><p name="27d9" id="27d9" class="graf graf--p graf-after--pre">It inherits a dummy protocol. Input parameters can be function parameters, and the whole thing is <strong class="markup--strong markup--p-strong">just a function</strong>.</p><p name="c9c5" id="c9c5" class="graf graf--p graf-after--p">He sacrificed code efficiency for generalization, which is dampened by prefix dependencies like <code class="markup--code markup--p-code">GetUserTransactions</code> , <code class="markup--code markup--p-code">GetCurrentUser</code> and nested dependencies. You can’t have it both ways.</p><p name="e8b1" id="e8b1" class="graf graf--p graf-after--p">So by wrapping function in object, that object has to re-accept parameters from initializers, use function name as class name, inherit dummy protocol, increase overheads just so you can write error-handling which should just be refactored out already in a brute-force case specific way.</p><p name="1495" id="1495" class="graf graf--p graf-after--p">Let’s compare this professional reative programming BBFB by industry titans to junior level, 0 module, 0 injection sample code:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="246a" id="246a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">func</span> <span class="hljs-title function_">getUserTransaction</span>() <span class="hljs-keyword">async</span> -&gt; [<span class="hljs-type">UserTransaction</span>]<br /><span class="hljs-comment">// use library service</span><br /><span class="hljs-comment">// refactor out routine shit</span></span></pre><p name="f8c5" id="f8c5" class="graf graf--p graf-after--pre">in which I can call with minimum effort. I don’t need to create use case, repository, initializer, generics, dummy protocol, dumb shit <code class="markup--code markup--p-code">class Impl</code> … etc. It has footprint so small I can have local reasoning, which I quote from top google result:</p><blockquote name="dcb2" id="dcb2" class="graf graf--blockquote graf-after--p">Local reasoning is the idea that the reader can make sense of the code directly in front of them, <strong class="markup--strong markup--blockquote-strong">without going on a journey</strong> discovering how the code works.</blockquote><p name="5c47" id="5c47" class="graf graf--p graf-after--blockquote">journey such as view -&gt; view model -&gt; use case -&gt; use case “impl” -&gt; repository -&gt; service -&gt; …</p><p name="704c" id="704c" class="graf graf--p graf-after--p">You might wonder, so BBFB doesn’t seem to provide any tangible benefits? What’s the point then?</p><p name="5d63" id="5d63" class="graf graf--p graf-after--p">He answered it.</p><p name="4c3a" id="4c3a" class="graf graf--p graf-after--p">3. The <a href="https://blog.cleancoder.com/uncle-bob/2011/09/30/Screaming-Architecture.html" data-href="https://blog.cleancoder.com/uncle-bob/2011/09/30/Screaming-Architecture.html" class="markup--anchor markup--p-anchor" rel="noopener ugc nofollow noopener" target="_blank">“Screaming Architecture”</a></p><p name="6b55" id="6b55" class="graf graf--p graf-after--p">Or as I call it, vanity programming.</p><p name="4e0e" id="4e0e" class="graf graf--p graf-after--p">If you are not refactoring, you are writing documentation.</p><p name="6fe4" id="6fe4" class="graf graf--p graf-after--p">If you are writing documentation using class / file names, you are <em class="markup--em markup--p-em">advertising</em>.</p><p name="0dea" id="0dea" class="graf graf--p graf-after--p">Case and point, screenshot from his example:</p><figure name="3bbd" id="3bbd" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*LFV6G9n8PDP5yiH-OHz3EQ.png" data-width="1069" data-height="911" src="https://cdn-images-1.medium.com/max/800/1*LFV6G9n8PDP5yiH-OHz3EQ.png"></figure><p name="2392" id="2392" class="graf graf--p graf-after--figure">He then asked:</p><blockquote name="b301" id="b301" class="graf graf--blockquote graf-after--p">Can you say what this app is doing by just looking at the project?</blockquote><p name="67d4" id="67d4" class="graf graf--p graf-after--blockquote">The answer is, <em class="markup--em markup--p-em">compared to what?</em></p><p name="b993" id="b993" class="graf graf--p graf-after--p">You can convert these filenames to <em class="markup--em markup--p-em">functions</em>.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="0f69" id="0f69" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">// class AccountManager</span><br /><span class="hljs-keyword">func</span> <span class="hljs-title function_">registerAccount</span>()<br /><span class="hljs-keyword">func</span> <span class="hljs-title function_">signIn</span>()<br /><br /><span class="hljs-comment">// class Payment</span><br /><span class="hljs-keyword">func</span> <span class="hljs-title function_">makePayment</span>()<br /><br /><span class="hljs-comment">// ...</span></span></pre><p name="1e74" id="1e74" class="graf graf--p graf-after--pre">which makes sense because you’d expect <code class="markup--code markup--p-code">registerAccount()</code> and <code class="markup--code markup--p-code">signIn()</code> to share properties.</p><p name="a041" id="a041" class="graf graf--p graf-after--p">Do I need to scream “use case” a million times to get my point across?</p><h4 name="ab74" id="ab74" class="graf graf--h4 graf-after--p">Revolution</h4><blockquote name="7658" id="7658" class="graf graf--blockquote graf-after--h4"><strong class="markup--strong markup--blockquote-strong">Dr. Alfred Lanning : </strong>The Three Laws will lead to only one logical outcome.</blockquote><blockquote name="dfd9" id="dfd9" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong">Detective Del Spooner : </strong>What? What outcome?</blockquote><blockquote name="ebc7" id="ebc7" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong">Dr. Alfred Lanning : </strong>Revolution.</blockquote><blockquote name="d29d" id="d29d" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong">Detective Del Spooner : </strong>Whose revolution?</blockquote><blockquote name="fee2" id="fee2" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong">Dr. Alfred Lanning : </strong>*That*, Detective, is the right question. Program terminated.</blockquote><p name="73c9" id="73c9" class="graf graf--p graf-after--blockquote">We have discussed thus far based on one question.</p><p name="fac4" id="fac4" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">Why should I have a Use Case that does nothing other than just calling a Repository, isn’t this an overkill for my app?</em></p><p name="7bcf" id="7bcf" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">*That*, Detective, is the right question.</strong></p><p name="ce1f" id="ce1f" class="graf graf--p graf-after--p">It lead to revolution. As in past tense. Swift is built to kill BBFB, if you know how to use it.</p><p name="3e67" id="3e67" class="graf graf--p graf-after--p">I was going to explain why, but I spent too much time ranting about BBFB. So I’ll have to just point you in the right direction.</p><ol class="postList"><li name="07f2" id="07f2" class="graf graf--li graf-after--p">Remove inheritance. You are going to unlearn everything you’ve learned.</li><li name="89c8" id="89c8" class="graf graf--li graf-after--li">Refactor using protocol extension.</li><li name="99a7" id="99a7" class="graf graf--li graf-after--li">No repository shit. Build around value type is entirely different than reference type.</li><li name="e9de" id="e9de" class="graf graf--li graf-after--li">Separation of concern in BBFB terms is dog shit. One function per class is the most useless waste of time and space.</li><li name="6183" id="6183" class="graf graf--li graf-after--li">SOLID is dog shit. You don’t even need inheritance anymore.</li><li name="da2c" id="da2c" class="graf graf--li graf-after--li">Over-generalization is a clear and present danger, if you can’t write one service right, don’t think about N runtime swappable.</li></ol><p name="17fc" id="17fc" class="graf graf--p graf-after--li">And in case you are wondering, the second law of refactor is respect SDK.</p><p name="fa76" id="fa76" class="graf graf--p graf-after--p">SDK is built to support what you need to do. Lean on it. Those who build SDK know what they are doing. (well, maybe not Android)</p><p name="d32f" id="d32f" class="graf graf--p graf-after--p">As for third law, I haven’t made it up yet lol.</p><p name="71c3" id="71c3" class="graf graf--p graf-after--p">To wrap up, all of these is to show you why Android team practicing BBFB can have 2x production speed is total bullshit. Against Obj-C? maybe. Against Swift, no chance in hell.</p><p name="a1d4" id="a1d4" class="graf graf--p graf-after--p">If that were the case, the proper course of action is to fire all iOS team, because they suck. Then fire Android team because BBFB suck, and they produce 99% boilerplate that are just repeats of “use case”, “repository”, “view model”, “clean”.</p><p name="74a8" id="74a8" class="graf graf--p graf-after--p">Oh, and if you think about it, all these interactions, overheads increase exponetially when project grows in size. BBFB is the worst scaling architecture. I don’t have proof? Yes. But neither does BBFB! They are scalable because they say so!</p><p name="17ad" id="17ad" class="graf graf--p graf-after--p graf--trailing">If you are an iOS dev working to improve your skill, BBFB is the worst choice. Hope this help someone.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/47c0e799091d"><time class="dt-published" datetime="2023-07-27T11:38:49.525Z">July 27, 2023</time></a>.</p><p><a href="https://medium.com/@swift2931/why-use-cases-are-useless-47c0e799091d" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>