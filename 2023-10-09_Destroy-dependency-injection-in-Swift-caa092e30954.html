<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Destroy dependency injection in Swift</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Destroy dependency injection in Swift</h1>
</header>
<section data-field="subtitle" class="p-summary">
Replace dependency with duplication
</section>
<section data-field="body" class="e-content">
<section name="37ef" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="2d20" id="2d20" class="graf graf--h3 graf--leading graf--title">Destroy dependency injection in Swift</h3><h4 name="c19e" id="c19e" class="graf graf--h4 graf-after--h3 graf--subtitle">Replace dependency with duplication</h4><figure name="fe8b" id="fe8b" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*Ea5-Ct-AROa4fPVTUlQXpg.png" data-width="1370" data-height="712" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*Ea5-Ct-AROa4fPVTUlQXpg.png"><figcaption class="imageCaption">A poll on Swift subreddit</figcaption></figure><h4 name="6577" id="6577" class="graf graf--h4 graf-after--figure">Dung injection</h4><p name="ee4c" id="ee4c" class="graf graf--p graf-after--h4">Saw above poll on Swift subreddit. Since I’m about the only person on Internet that criticised Swift DI framework, I want to tell a completely different story.</p><p name="a2af" id="a2af" class="graf graf--p graf-after--p">The approach I’m going to take this time, is to examine it in a different setting altogether. There’s power in naming. The best example is <em class="markup--em markup--p-em">clean architecture</em>. You will believe it is clean because it says it is clean.</p><p name="95dd" id="95dd" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">Dependency</em> is another example. Like the quote from Blade of Glory:</p><figure name="e1b2" id="e1b2" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*I4SRUGHw-tEC7Xmjieb3Gw.jpeg" data-width="580" data-height="500" src="https://cdn-images-1.medium.com/max/800/1*I4SRUGHw-tEC7Xmjieb3Gw.jpeg"></figure><p name="5aff" id="5aff" class="graf graf--p graf-after--figure">In coding <em class="markup--em markup--p-em">dependency</em> has negative meaning because usually you want things <em class="markup--em markup--p-em">decoupled, </em>which unfortunately is also abused.</p><p name="50fd" id="50fd" class="graf graf--p graf-after--p">Let’s get out of this trap. What’s the problem you are solving?</p><p name="3070" id="3070" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Code duplication.</strong></p><p name="e489" id="e489" class="graf graf--p graf-after--p">Let’s compare this line of thinking with a traditional “tutorial” from</p><p name="16f3" id="16f3" class="graf graf--p graf-after--p"><a href="https://www.kodeco.com/14223279-dependency-injection-tutorial-for-ios-getting-started" data-href="https://www.kodeco.com/14223279-dependency-injection-tutorial-for-ios-getting-started" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Dependency Injection Tutorial for iOS: Getting Started</a></p><h4 name="3845" id="3845" class="graf graf--h4 graf-after--p">Solve duplication by more duplication</h4><p name="fbb2" id="fbb2" class="graf graf--p graf-after--h4">Any tutorial would of course cover what IOC, DI is:</p><blockquote name="594a" id="594a" class="graf graf--blockquote graf-after--p"><strong class="markup--strong markup--blockquote-strong">Inversion of Control</strong> is a pattern that lets you invert the flow of control. To achieve this <strong class="markup--strong markup--blockquote-strong">you move all the responsibilities of a class, except its main one, outside, making them its <em class="markup--em markup--blockquote-em">dependencies</em></strong>. Through abstraction you make the dependencies easily <strong class="markup--strong markup--blockquote-strong">interchangeable</strong>.</blockquote><p name="2fa0" id="2fa0" class="graf graf--p graf-after--blockquote">It’s hard to see how this is supposed to solve duplication. In fact it brings more questions than it answers.</p><p name="d056" id="d056" class="graf graf--p graf-after--p">Any professional worth their salt, should ask this question now:</p><p name="38a0" id="38a0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Why does “outside” have to handle your responsibilities?</strong></p><p name="e58b" id="e58b" class="graf graf--p graf-after--p">Breaking encapsulation aside, you are going to have <strong class="markup--strong markup--p-strong">code duplication</strong>. Tutorial has this snippet:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="c822" id="c822" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">EngineProtocol</span> {<br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">start</span>()<br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">stop</span>()<br />}<br /><br /><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">TransmissionProtocol</span> {<br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">changeGear</span>(<span class="hljs-params">gear</span>: <span class="hljs-type">Gear</span>)<br />}<br /><br /><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> {<br />  <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> engine: <span class="hljs-type">EngineProtocol</span><br />  <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> transmission: <span class="hljs-type">TransmissionProtocol</span><br /><br />  <span class="hljs-keyword">init</span>(<span class="hljs-params">engine</span>: <span class="hljs-type">EngineProtocol</span>, <span class="hljs-params">transmission</span>: <span class="hljs-type">TransmissionProtocol</span>) {<br />    <span class="hljs-keyword">self</span>.engine <span class="hljs-operator">=</span> engine<br />    <span class="hljs-keyword">self</span>.transmission <span class="hljs-operator">=</span> transmission<br />  }<br />}</span></pre><p name="5821" id="5821" class="graf graf--p graf-after--pre">You repeat <code class="markup--code markup--p-code">engine: EngineProtocol</code> on top of redundant assignment <code class="markup--code markup--p-code">self.engine = engine</code> and add an extra layer of abstraction <code class="markup--code markup--p-code">protocol EngineProtocol</code> .</p><p name="bad9" id="bad9" class="graf graf--p graf-after--p">Your code should burn in flames and your commits be rejected at this point. Just from <strong class="markup--strong markup--p-strong">code duplication </strong>alone!</p><p name="6152" id="6152" class="graf graf--p graf-after--p">OK. Maybe I set my standards too high. No way you can find 87 idiots that make such basic mistakes. There must be some advantages that justify the costs.</p><p name="3324" id="3324" class="graf graf--p graf-after--p">On the other hand, isn’t this the problem of discussing abstract principles?</p><p name="9253" id="9253" class="graf graf--p graf-after--p">There’s suddenly a need for <em class="markup--em markup--p-em">dependency </em>out of thin air, with very questionable practices of dumping your shit to <strong class="markup--strong markup--p-strong">outside</strong>. I’d be very pissed if I were the <strong class="markup--strong markup--p-strong">outside</strong>.</p><p name="dcc9" id="dcc9" class="graf graf--p graf-after--p">And if you press on this matter, DI would eventually say it is meant to solve… you guessed it, <strong class="markup--strong markup--p-strong">code duplication</strong>.</p><p name="bb98" id="bb98" class="graf graf--p graf-after--p">Like this intellectual colossus I randomly found on Internet:</p><figure name="dbd9" id="dbd9" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ROEaFgTWWBAs1X0GqarMtQ.png" data-width="602" data-height="409" src="https://cdn-images-1.medium.com/max/800/1*ROEaFgTWWBAs1X0GqarMtQ.png"></figure><p name="0c95" id="0c95" class="graf graf--p graf-after--figure">OK. Let’s say DI does it for you. But who does DI? <strong class="markup--strong markup--p-strong">Outside</strong>?</p><p name="1ab6" id="1ab6" class="graf graf--p graf-after--p">Ah, of course. DI framework. I have detailed analysis on why they are dog shit that you can check if interested, but that’s not the main focus here.</p><p name="805d" id="805d" class="graf graf--p graf-after--p">The focus here is to get out of this logic trap. OK. If the problem you want to solve is code duplication, let’s solve duplication.</p><p name="03e2" id="03e2" class="graf graf--p graf-after--p">You don’t need extra mechanism like IOC, dependency. All you need to do is count!</p><p name="e552" id="e552" class="graf graf--p graf-after--p">For example, what is this “change a contructor without DI” that this intellectual colossus is talking about?</p><p name="3102" id="3102" class="graf graf--p graf-after--p">In code snippet above, the constructor is there because of DI! So we went from <code class="markup--code markup--p-code">var engine = Engine()</code> which counts as 1 usage, to multiple occurrences.</p><p name="4421" id="4421" class="graf graf--p graf-after--p">I especially like how creating an object easily can be considered as an achievement in DI. You should be ashamed that you need an external library just so you don’t get crushed by the sheer complexity of objects that you need to create. Oh and that library is likely just a singleton, which adds even more complexity because they may be mutated from anywhere by anyone.</p><p name="8bf3" id="8bf3" class="graf graf--p graf-after--p">There are different duplication situations that require different solutions, I’ll cover it if we meet a specific case. This is another differerce in thinking: there’s no one solution that fits all.</p><p name="bf32" id="bf32" class="graf graf--p graf-after--p">Let’s examine the tutorial by how it solves duplication.</p><h4 name="c174" id="c174" class="graf graf--h4 graf-after--p">Solve duplication before there’s duplication</h4><p name="c5c4" id="c5c4" class="graf graf--p graf-after--h4">The tutorial builds on this snippet:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="2a58" id="2a58" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ProfileView</span>: <span class="hljs-title class_">View</span> {<br />  <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> privacyLevel <span class="hljs-operator">=</span> <span class="hljs-type">PrivacyLevel</span>.friend<br />  <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> user: <span class="hljs-type">User</span> <span class="hljs-operator">=</span> <span class="hljs-type">Mock</span>.user()<br /><br />  <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {<span class="hljs-operator">...</span>}<br />}</span></pre><p name="3ee4" id="3ee4" class="graf graf--p graf-after--pre">Then it raises these problems:</p><blockquote name="4f8c" id="4f8c" class="graf graf--blockquote graf-after--p">Currently, <code class="markup--code markup--blockquote-code">ProfileView</code> decides which views to display depending on the privacy level. This isn’t a proper solution for several reasons:</blockquote><blockquote name="badd" id="badd" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong">It’s not very testable</strong>. While you can cover it with UI tests, they’re more expensive to run than unit or integration tests.</blockquote><blockquote name="d392" id="d392" class="graf graf--blockquote graf-after--blockquote">Every time you decide to <strong class="markup--strong markup--blockquote-strong">expand </strong>or modify your app’s functionality, <code class="markup--code markup--blockquote-code">ProfileView</code> will also require a lot of adaptations. It’s <strong class="markup--strong markup--blockquote-strong">tightly <em class="markup--em markup--blockquote-em">coupled</em></strong> with <code class="markup--code markup--blockquote-code">PrivacyLevel</code> and has more responsibility than needed.</blockquote><blockquote name="6a19" id="6a19" class="graf graf--blockquote graf-after--blockquote">As the app’s complexity and functionality grow it’ll get harder to maintain this code.</blockquote><p name="f848" id="f848" class="graf graf--p graf-after--blockquote">You get all that from a “view” that has 2 properties?</p><p name="7b88" id="7b88" class="graf graf--p graf-after--p">Let’s address these issues one by one.</p><p name="58cf" id="58cf" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">1. Expand</em></p><p name="d9b7" id="d9b7" class="graf graf--p graf-after--p">This is what makes Swift tick. If you need to ask how to expand functionalities in Swift, you are doing it wrong.</p><p name="7b4f" id="7b4f" class="graf graf--p graf-after--p">Because you have <strong class="markup--strong markup--p-strong">extension</strong>. Let me guess, author didn’t use it.</p><p name="c5f3" id="c5f3" class="graf graf--p graf-after--p">Yep. You can check it. But trust me bro.</p><p name="9630" id="9630" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">2. Not very testable</em></p><p name="e04e" id="e04e" class="graf graf--p graf-after--p">We have another TDD titan in the wild. This is the funny part, you will see TDD titans in tutorials, comment sections, stackoverflow… etc.</p><p name="fefd" id="fefd" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">But you never see TDD titans at work.</strong></p><p name="4a40" id="4a40" class="graf graf--p graf-after--p">I know what you are going to say. Just because I don’t see it doesn’t mean it does not exist. Or that’s because I work as a low-tier code farmer.</p><p name="8d58" id="8d58" class="graf graf--p graf-after--p">Look, author didn’t even bother saying what she is testing. If you find it difficult to test a “view” with two properties plus a <code class="markup--code markup--p-code">var body</code> computed property, you might not be as good in testing as you think.</p><p name="c4c3" id="c4c3" class="graf graf--p graf-after--p">Again, I know what you are going to say. There would be logic in <code class="markup--code markup--p-code">var body</code> that can’t be verified unless you refactor it out. But why do you always need extra objects? Where’s protocol extension?</p><p name="f6ed" id="f6ed" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">If you have to have some dedicated named object tailored to test just one thing, at the cost of efficiency of production code, regardless of the function complexity, is it possible that you are not as good in testing as you think?</strong></p><p name="1461" id="1461" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">3. Tightly coupled</em></p><p name="3f8e" id="3f8e" class="graf graf--p graf-after--p">Why?</p><p name="5fee" id="5fee" class="graf graf--p graf-after--p">Quote from tutorial:</p><blockquote name="0fbc" id="0fbc" class="graf graf--blockquote graf-after--p">This is where you start seeing the beauty of the approach. The view is now completely <strong class="markup--strong markup--blockquote-strong">unaware of the business logic </strong>behind the profile contents. You can <strong class="markup--strong markup--blockquote-strong">give any implementation of </strong><code class="markup--code markup--blockquote-code"><strong class="markup--strong markup--blockquote-strong">ProfileContentProviderProtocol</strong></code>, include new privacy levels or <strong class="markup--strong markup--blockquote-strong">even mock the provider without changing a single line of code</strong>!</blockquote><p name="8023" id="8023" class="graf graf--p graf-after--blockquote">This is where you start seeing the beauty of industry titans writing stupid shit.</p><p name="3c9f" id="3c9f" class="graf graf--p graf-after--p">If there’s no duplication, i.e.; you are not going to use functions / properties in a view anywhere else, who gives a shit if the view is “aware” of it?</p><p name="2330" id="2330" class="graf graf--p graf-after--p">For example, if I put all the shit to a sink object:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="762e" id="762e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Model</span>: <span class="hljs-title class_">View</span> {<br />  <span class="hljs-meta">@StateObject</span> <span class="hljs-keyword">var</span> sink <span class="hljs-operator">=</span> <span class="hljs-type">Sink</span>()<br />  <span class="hljs-comment">// ...</span><br />}</span></pre><p name="0530" id="0530" class="graf graf--p graf-after--pre">But if nobody else uses <code class="markup--code markup--p-code">Sink</code> object, then you might as well merge two together. (assume no other refactor reasons)</p><p name="f457" id="f457" class="graf graf--p graf-after--p">Which prompts another question: why can’t you use “view” as model if you do need the functions and properties in a view?</p><p name="622e" id="622e" class="graf graf--p graf-after--p">The “view” part is <code class="markup--code markup--p-code">var body</code> , a computed property. It doesn’t affect the usage of other stored properties.</p><p name="dc53" id="dc53" class="graf graf--p graf-after--p">Next, <strong class="markup--strong markup--p-strong">any implementation </strong>is over-kill. It’s always about specific implementation, i.e.; the things in <strong class="markup--strong markup--p-strong">SPEC</strong>. Tutorial is presenting a solution for <strong class="markup--strong markup--p-strong">ANYTHING </strong>before even knowing what the problem is!</p><p name="e046" id="e046" class="graf graf--p graf-after--p">This gem in <a href="https://softwareengineering.stackexchange.com/questions/388493/is-dependency-injection-always-a-best-practice" data-href="https://softwareengineering.stackexchange.com/questions/388493/is-dependency-injection-always-a-best-practice" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">stackoverflow </a>shows this concept:</p><figure name="8c33" id="8c33" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ypC4pVF_QcPnLnfqol6QkA.png" data-width="956" data-height="86" src="https://cdn-images-1.medium.com/max/800/1*ypC4pVF_QcPnLnfqol6QkA.png"></figure><p name="1d60" id="1d60" class="graf graf--p graf-after--figure">I don’t know what platform / language / drug he is on. But 90% of the problem? Dude, I spent efforts to make sure caller can initialize without parameters if possible.</p><p name="62ec" id="62ec" class="graf graf--p graf-after--p">Look at this example.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="cbee" id="cbee" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">ProfileContentProviderProtocol</span> {<br />  <span class="hljs-keyword">var</span> privacyLevel: <span class="hljs-type">PrivacyLevel</span> { <span class="hljs-keyword">get</span> }<br />  <span class="hljs-keyword">var</span> canSendMessage: <span class="hljs-type">Bool</span> { <span class="hljs-keyword">get</span> }<br />  <span class="hljs-keyword">var</span> canStartVideoChat: <span class="hljs-type">Bool</span> { <span class="hljs-keyword">get</span> }<br />  <span class="hljs-keyword">var</span> photosView: <span class="hljs-type">AnyView</span> { <span class="hljs-keyword">get</span> }<br />  <span class="hljs-keyword">var</span> feedView: <span class="hljs-type">AnyView</span> { <span class="hljs-keyword">get</span> }<br />  <span class="hljs-keyword">var</span> friendsView: <span class="hljs-type">AnyView</span> { <span class="hljs-keyword">get</span> }<br />}<br /><br /><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ProfileView</span>: <span class="hljs-title class_">View</span> {<br />  <span class="hljs-comment">// ...</span><br />  <span class="hljs-keyword">init</span>(<span class="hljs-params">provider</span>: <span class="hljs-type">ProfileContentProviderProtocol</span>, <span class="hljs-params">user</span>: <span class="hljs-type">User</span>) {<br />    <span class="hljs-keyword">self</span>.provider <span class="hljs-operator">=</span> provider<br />    <span class="hljs-keyword">self</span>.user <span class="hljs-operator">=</span> user<br />  }<br />}</span></pre><p name="d77e" id="d77e" class="graf graf--p graf-after--pre">What does this <code class="markup--code markup--p-code">provider</code> give you? So you can build a couple of views similar to <code class="markup--code markup--p-code">ProfileView</code> .</p><p name="a65a" id="a65a" class="graf graf--p graf-after--p">Does that sound like 90% of your problems? 90% of my views don’t require duplication!</p><p name="55cc" id="55cc" class="graf graf--p graf-after--p">As for “<strong class="markup--strong markup--p-strong">without changing one line of code</strong>”, You don’t change <code class="markup--code markup--p-code">ProfileView</code> , but you change the class(es) that conform to <code class="markup--code markup--p-code">ProfileContentProvider</code> . The lines of code that need changing are the same, if not more considering overheads.</p><p name="333a" id="333a" class="graf graf--p graf-after--p">The signature of a TDD titan is that he will destroy code efficiency so he can <strong class="markup--strong markup--p-strong">MOCK</strong> it by <strong class="markup--strong markup--p-strong">RECREATING EVERYTHING</strong>. Look above protocol. If I want to mock <code class="markup--code markup--p-code">privacyLevel</code> , I have to supply <code class="markup--code markup--p-code">photosView</code> ? Who gives a shit? And why is it <code class="markup--code markup--p-code">AnyView</code> ? You can’t do anything useful with it!</p><p name="f9bc" id="f9bc" class="graf graf--p graf-after--p">You know how I’d mock <code class="markup--code markup--p-code">privacyLevel</code> ?</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="43fb" id="43fb" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">var</span> profile <span class="hljs-operator">=</span> <span class="hljs-type">ProfileView</span>()<br />profile.privacyLevel <span class="hljs-operator">=</span> .friend<br /><span class="hljs-comment">// test computed properties</span></span></pre><p name="160d" id="160d" class="graf graf--p graf-after--pre">Because of model-view binding, model and view are two sides of the same coin. Use whatever side most convenient to you.</p><p name="a0d0" id="a0d0" class="graf graf--p graf-after--p">Let’s pause for a moment to admire the accepted answer in above gem.</p><figure name="8fd5" id="8fd5" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*hrutA9yWfgaHg1cTWuwyJA.png" data-width="1114" data-height="318" src="https://cdn-images-1.medium.com/max/800/1*hrutA9yWfgaHg1cTWuwyJA.png"></figure><p name="dfb0" id="dfb0" class="graf graf--p graf-after--figure">I can’t comment on this shit because I don’t have 50 reputation.</p><p name="b5b8" id="b5b8" class="graf graf--p graf-after--p">As I said, DI is where you can see <strong class="markup--strong markup--p-strong">REPUTABLE </strong>TDD titans<strong class="markup--strong markup--p-strong"> </strong>making dumb shit mistakes. At the very least specify the platform / language. The arrogance of DI to work universally is astounding.</p><p name="c50d" id="c50d" class="graf graf--p graf-after--p">Btw, this is why stackoverflow turns to shit. Just a bunch of highly <strong class="markup--strong markup--p-strong">REPUTABLE </strong>people circle-jerking each other or reporting your shit as invalid.</p><p name="30ef" id="30ef" class="graf graf--p graf-after--p">Back to topic at hand, duplication.</p><p name="e1ee" id="e1ee" class="graf graf--p graf-after--p">Let’s assume by spec <code class="markup--code markup--p-code">ProfileView</code> actually needs duplication.</p><h4 name="0152" id="0152" class="graf graf--h4 graf-after--p">Solve duplication by only generalization</h4><p name="6d18" id="6d18" class="graf graf--p graf-after--h4">For simplicity, consider this is <code class="markup--code markup--p-code">ProfileView</code> :</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="less" name="31fb" id="31fb" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">        <span class="hljs-selector-tag">ProfileHeaderView</span>(<br />          <span class="hljs-attribute">user</span>: user,<br />          <span class="hljs-attribute">canSendMessage</span>: provider.canSendMessage,<br />          <span class="hljs-attribute">canStartVideoChat</span>: provider.canStartVideoChat<br />        )<br />        <span class="hljs-selector-tag">provider</span><span class="hljs-selector-class">.friendsView</span><br />        <span class="hljs-selector-tag">provider</span><span class="hljs-selector-class">.photosView</span><br />        <span class="hljs-selector-tag">provider</span><span class="hljs-selector-class">.feedView</span></span></pre><p name="9fc0" id="9fc0" class="graf graf--p graf-after--pre">What if we refactor out computed properties to protocol extension?</p><p name="e840" id="e840" class="graf graf--p graf-after--p">Then assume we need 3 <code class="markup--code markup--p-code">provider</code> for 3 customized views.</p><p name="e413" id="e413" class="graf graf--p graf-after--p">What if we create 3 views instead of 1 customizable view? We can remove <code class="markup--code markup--p-code">provider</code> and conform to protocol directly, or refactor it out to a shared object if needed.</p><p name="b0cd" id="b0cd" class="graf graf--p graf-after--p">But wait, that is duplication!</p><p name="9d4a" id="9d4a" class="graf graf--p graf-after--p">Let’s do some counting. We need to create 3 types, create<code class="markup--code markup--p-code">privacyLevel</code> 3 times, and need to build the view 3 times, which is not trivial.</p><p name="ce1e" id="ce1e" class="graf graf--p graf-after--p">On further inspection, however, we can refactor out common subviews, and each type can freely build its own view. Often in usage like this, there would be minor differences in view layout; so this works in our favor.</p><p name="ac3c" id="ac3c" class="graf graf--p graf-after--p">Note that in this way we are not using protocol for generalization. We use it as mix-in to provide default implementation.</p><p name="6a26" id="6a26" class="graf graf--p graf-after--p">It is plausible that we can argue that pros &gt; cons in the case of 3 views.</p><p name="a7e6" id="a7e6" class="graf graf--p graf-after--p">But what if we have many properties, or we need 30 views?</p><p name="fa38" id="fa38" class="graf graf--p graf-after--p">Let’s do some counting. DI will require at least 30 initializers, 30 <code class="markup--code markup--p-code">providers</code> . And it probably doesn’t have default implementation; On the other hand, I create more simple properties, but still can refactor out common functions and subviews.</p><p name="5f33" id="5f33" class="graf graf--p graf-after--p">The refactor of function and subviews becomes more important as the problem scales. But neither of these techniques are shown in the tutorial.</p><p name="9215" id="9215" class="graf graf--p graf-after--p">You think this can scale?</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="1def" id="1def" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">var</span> photosView: <span class="hljs-type">AnyView</span> {<br />    privacyLevel <span class="hljs-operator">&gt;</span> .everyone <span class="hljs-operator">?</span> <br />      <span class="hljs-type">AnyView</span>(<span class="hljs-type">PhotosView</span>(photos: user.photos)) : <br />      <span class="hljs-type">AnyView</span>(<span class="hljs-type">EmptyView</span>())<br />  }<br /><br />  <span class="hljs-keyword">var</span> feedView: <span class="hljs-type">AnyView</span> {<br />    privacyLevel <span class="hljs-operator">&gt;</span> .everyone <span class="hljs-operator">?</span> <br />      <span class="hljs-type">AnyView</span>(<span class="hljs-type">HistoryFeedView</span>(posts: user.historyFeed)) : <br />      <span class="hljs-type">AnyView</span>(<span class="hljs-type">RestrictedAccessView</span>())<br />  }</span></pre><p name="915f" id="915f" class="graf graf--p graf-after--pre">How many times you have to repeat <code class="markup--code markup--p-code">AnyView</code>? Which is why you shouldn’t have <code class="markup--code markup--p-code">AnyView</code> in the first place!</p><p name="5cf5" id="5cf5" class="graf graf--p graf-after--p">You can at least use <code class="markup--code markup--p-code">some View</code> , which is more specialized than <code class="markup--code markup--p-code">AnyView</code> . Because Swift has such strict type system, it works best if you know the exact type. A good Swift developer would know this, and you can expect his design to favor specialization over generalization.</p><h4 name="1694" id="1694" class="graf graf--h4 graf-after--p">Duplication injection</h4><p name="6f1a" id="6f1a" class="graf graf--p graf-after--h4">Alright, if you are still reading for some reason, you are probably tired.</p><p name="750f" id="750f" class="graf graf--p graf-after--p">Let’s wrap up by making fun of the pinnacle of DI framework: DI container.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="3303" id="3303" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProfileContentProvider</span>: <span class="hljs-title class_">ObservableObject</span> {<br />  <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> store: <span class="hljs-type">Store</span><br />  <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> cancellables: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">AnyCancellable</span>&gt; <span class="hljs-operator">=</span> []<br />  <br />  <span class="hljs-keyword">init</span>(<br />    <span class="hljs-params">privacyLevel</span>: <span class="hljs-type">PrivacyLevel</span> <span class="hljs-operator">=</span> <br />      <span class="hljs-type">DIContainer</span>.shared.resolve(type: <span class="hljs-type">PrivacyLevel</span>.<span class="hljs-keyword">self</span>)<span class="hljs-operator">!</span>,<br />    <span class="hljs-params">user</span>: <span class="hljs-type">User</span> <span class="hljs-operator">=</span> <span class="hljs-type">DIContainer</span>.shared.resolve(type: <span class="hljs-type">User</span>.<span class="hljs-keyword">self</span>)<span class="hljs-operator">!</span>,<br />    <span class="hljs-comment">// 1</span><br />    <span class="hljs-params">store</span>: <span class="hljs-type">Store</span> <span class="hljs-operator">=</span> <span class="hljs-type">DIContainer</span>.shared.resolve(type: <span class="hljs-type">Store</span>.<span class="hljs-keyword">self</span>)<span class="hljs-operator">!</span><br />  ) {<br />    <span class="hljs-keyword">self</span>.privacyLevel <span class="hljs-operator">=</span> privacyLevel<br />    <span class="hljs-keyword">self</span>.user <span class="hljs-operator">=</span> user<br />    <span class="hljs-keyword">self</span>.store <span class="hljs-operator">=</span> store<br />  <br />    <span class="hljs-comment">// 2</span><br />    store.objectWillChange.sink { <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span><br />      <span class="hljs-keyword">self</span>.objectWillChange.send()<br />    }<br />    .store(in: <span class="hljs-operator">&amp;</span>cancellables)<br />  }<br />}</span></pre><p name="5b9e" id="5b9e" class="graf graf--p graf-after--pre">Force unwrap alone means this library is dog shit. Why the F do you inject point of failure (crash!) to <strong class="markup--strong markup--p-strong">production </strong>code?</p><p name="ea84" id="ea84" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">User</code> should be value type and you shouldn’t need to resolve shit. That’s the point of immutable type: you have your own copy. <code class="markup--code markup--p-code">PrivacyLevel</code> too.</p><p name="1204" id="1204" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">What is the duplicate you are trying to solve?</strong></p><p name="4a53" id="4a53" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">Store</code> ? Why? Don’t know. <strong class="markup--strong markup--p-strong">Solve duplicate before there’s duplicate</strong>.</p><p name="3faa" id="3faa" class="graf graf--p graf-after--p">And if you use it in another view, you still need to write all that shit. <strong class="markup--strong markup--p-strong">Solve duplication by more duplication</strong>.</p><p name="e319" id="e319" class="graf graf--p graf-after--p">It can’t even use singleton right.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="78ad" id="78ad" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProfileContentProvider</span>: <span class="hljs-title class_">ObservableObject</span> {<br />  <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> store: <span class="hljs-type">PreferencesStoreProtocol</span> <span class="hljs-operator">=</span> <span class="hljs-type">SpecialStore</span>(<span class="hljs-operator">...</span>)<br />  <span class="hljs-comment">// ...</span><br />}</span></pre><p name="dd0c" id="dd0c" class="graf graf--p graf-after--pre">You know this singleton is used by <code class="markup--code markup--p-code">ProfileContentProvider</code> , its specialization, and its protocol type.</p><p name="6ecd" id="6ecd" class="graf graf--p graf-after--p">You don’t need to resolve shit. Because you know the type in compile time; And since this is a global protocol object, you can swap it at your own risk, which is already high anyway, thus eliminating initializer altogether. At least you can trace it more easily without a library abstraction. It’s not like library does the complex initializing for you, you have to register one yourself anyway. You are essentially making things more difficult by losing information in generalization then <em class="markup--em markup--p-em">resolve </em>it back.</p><p name="11a2" id="11a2" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Specialization over generalization.</strong></p><p name="fd1c" id="fd1c" class="graf graf--p graf-after--p">Btw, singleton is used when you have means to manage risks and can trade it for code efficiency. Even if risks blow up in your face, at least you have efficiency. How the F do you fail at both?</p><p name="6239" id="6239" class="graf graf--p graf-after--p">Now comes the best part.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="78b3" id="78b3" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">store.objectWillChange.sink { <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span><br />      <span class="hljs-keyword">self</span>.objectWillChange.send()<br />    }<br />    .store(in: <span class="hljs-operator">&amp;</span>cancellables)</span></pre><p name="57cf" id="57cf" class="graf graf--p graf-after--pre">This! This is the duplicate you need to solve!</p><p name="36d2" id="36d2" class="graf graf--p graf-after--p">It’s routine shit that has to be repeated! FRP doesn’t mean you don’t need to refactor especially when SwiftUI can do it for you for basic cases.</p><p name="bfff" id="bfff" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Solve duplicate by only generalization</strong>. (on things that don’t need)</p><p name="7cb2" id="7cb2" class="graf graf--p graf-after--p">Finally, the confusion of the word <em class="markup--em markup--p-em">dependency </em>can be shown in this quote:</p><blockquote name="b1ef" id="b1ef" class="graf graf--blockquote graf-after--p">With these changes <code class="markup--code markup--blockquote-code">ProfileView</code> no longer <strong class="markup--strong markup--blockquote-strong">depends </strong>on the <code class="markup--code markup--blockquote-code">privacyLevel</code> variable because it<strong class="markup--strong markup--blockquote-strong"> <em class="markup--em markup--blockquote-em">receives</em> necessary dependencies</strong> via its initializer,</blockquote><p name="f1d2" id="f1d2" class="graf graf--p graf-after--blockquote">It doesn’t depend on one thing, but depend on multiple other things instead? which are obscured by library?</p><p name="ed8e" id="ed8e" class="graf graf--p graf-after--p">No one knows what it means. But it’s provocative, it gets people going.</p><p name="970f" id="970f" class="graf graf--p graf-after--p">I didn’t bother with <em class="markup--em markup--p-em">dependency </em>at all. Replace it with <em class="markup--em markup--p-em">duplicaiton</em>. What duplication are you solving? Then it comes down to basic refactor. (well, basic doesn’t mean easy)</p><p name="a8a5" id="a8a5" class="graf graf--p graf-after--p">With all these in mind, we can look at comments in that reddit poll in a new light.</p><figure name="0318" id="0318" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*3OalytzzUzZnG1l06M7M3A.png" data-width="1244" data-height="195" src="https://cdn-images-1.medium.com/max/800/1*3OalytzzUzZnG1l06M7M3A.png"></figure><p name="2aa6" id="2aa6" class="graf graf--p graf--startsWithDoubleQuote graf-after--figure">“<strong class="markup--strong markup--p-strong">dependencies get propagated</strong>” because <em class="markup--em markup--p-em">dependency </em>creates a <strong class="markup--strong markup--p-strong">recursive </strong>problem. Something is always tightly coupled and has to come from <strong class="markup--strong markup--p-strong">outside, </strong>which again has to come from <strong class="markup--strong markup--p-strong">outside</strong>.</p><p name="c16b" id="c16b" class="graf graf--p graf-after--p">Remove this dumb shit. Then it’s “what is a reasonable way to pass parameters” <strong class="markup--strong markup--p-strong">IF NEEDED AT ALL</strong>. The efforts would be first to make it <strong class="markup--strong markup--p-strong">NOT NEEDED</strong>. Not invent some over-engineered dumb shit to “<em class="markup--em markup--p-em">manage dependency</em>” and write a book about it. Where is shared object like @EnvironmentObject that can help you pass parameters? Do they cover this in DI?</p><p name="1e20" id="1e20" class="graf graf--p graf-after--p">Guys like this, in my opinion,</p><figure name="e950" id="e950" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*miQ14wI-60cvvcJaxeDVQQ.png" data-width="1310" data-height="226" src="https://cdn-images-1.medium.com/max/800/1*miQ14wI-60cvvcJaxeDVQQ.png"></figure><p name="f13a" id="f13a" class="graf graf--p graf-after--figure">should be banned from coding.</p><p name="4de0" id="4de0" class="graf graf--p graf-after--p">A TDD titan who can’t refactor for shit to separate presentation logic. Note how it’s never about function complexity, or whether “business logic” can be reused or not. It’s always some magic pattern or framework that helps testing, decoupling, modularizing… etc.</p><p name="5e63" id="5e63" class="graf graf--p graf-after--p">So what the poll is really telling us?</p><p name="5d2f" id="5d2f" class="graf graf--p graf-after--p">87 people should be fired on spot. TDD titans in comments should be banned from coding. Majority of devs are idiots, which shouldn’t come as a surprise. Some of the titans on <em class="markup--em markup--p-em">Better Programming</em> write the dumbest shit.</p><p name="7500" id="7500" class="graf graf--p graf-after--p graf--trailing">Remove <em class="markup--em markup--p-em">dependency, </em>then you can begin to learn some refactor.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/caa092e30954"><time class="dt-published" datetime="2023-10-09T03:29:20.438Z">October 9, 2023</time></a>.</p><p><a href="https://medium.com/@swift2931/destroy-dependency-injection-in-swift-caa092e30954" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>