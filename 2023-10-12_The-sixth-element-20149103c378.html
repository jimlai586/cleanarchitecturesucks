<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>The sixth element</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">The sixth element</h1>
</header>
<section data-field="subtitle" class="p-summary">
If you think good architecture is expensive, you are doing it wrong
</section>
<section data-field="body" class="e-content">
<section name="08fa" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="7c9f" id="7c9f" class="graf graf--h3 graf--leading graf--title">The sixth element</h3><h4 name="3b33" id="3b33" class="graf graf--h4 graf-after--h3 graf--subtitle">If you think good architecture is expensive, you are doing it wrong</h4><figure name="1dbc" id="1dbc" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*AklKpze9R9e-X9WC_quTUA.png" data-width="1431" data-height="808" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*AklKpze9R9e-X9WC_quTUA.png"><figcaption class="imageCaption">Clean Architecture, recolorized</figcaption></figure><h4 name="0d7d" id="0d7d" class="graf graf--h4 graf-after--figure">Are you classified as good architecture?</h4><p name="d928" id="d928" class="graf graf--p graf-after--h4">Saw this when I’m googling why Android architecture is so shit.</p><p name="d3a1" id="d3a1" class="graf graf--p graf-after--p"><a href="https://betterprogramming.pub/the-real-clean-architecture-in-android-part-1-s-o-l-i-d-6a661b103451" data-href="https://betterprogramming.pub/the-real-clean-architecture-in-android-part-1-s-o-l-i-d-6a661b103451" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">The “Real” Clean Architecture in Android: S.O.L.I.D.</a></p><p name="caee" id="caee" class="graf graf--p graf-after--p">With a quote as subtitle:</p><blockquote name="64c9" id="64c9" class="graf graf--pullquote graf-after--p">If you think good architecture is expensive, try bad architecture. ~ Brian Foote and Joseph Yoder</blockquote><p name="31e6" id="31e6" class="graf graf--p graf-after--pullquote">This is such horse shit. You can use it to justify any boilerplate.</p><p name="2450" id="2450" class="graf graf--p graf-after--p">Use a screenshot from the article for example:</p><figure name="cb3d" id="cb3d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*uAIRg2kHgqcO3JY-7SWmbA.png" data-width="1268" data-height="980" src="https://cdn-images-1.medium.com/max/800/1*uAIRg2kHgqcO3JY-7SWmbA.png"><figcaption class="imageCaption">multi-pass</figcaption></figure><p name="3f99" id="3f99" class="graf graf--p graf-after--figure">What’s the main problem of this design?</p><p name="9e0c" id="9e0c" class="graf graf--p graf-after--p">In OOP you will likely create one object for each box. That’s 13 objects <em class="markup--em markup--p-em">per view.</em></p><p name="c4b6" id="c4b6" class="graf graf--p graf-after--p">This shit won’t scale. If you think good architecture is expensive, this shit is expensive af. But expensive doesn’t mean good.</p><p name="8ab2" id="8ab2" class="graf graf--p graf-after--p">Some people will publish this shit as <em class="markup--em markup--p-em">Real Clean Architecture</em>, or as I call it <strong class="markup--strong markup--p-strong">Bob’s Brute Force Boilerplate (BBFB), </strong>but other people have self-respect.</p><p name="395f" id="395f" class="graf graf--p graf-after--p">Let’s try some ways to improve this just from first glances.</p><h4 name="a79c" id="a79c" class="graf graf--h4 graf-after--p">The little red button</h4><blockquote name="a642" id="a642" class="graf graf--blockquote graf-after--h4">Now a real killer, when he picked up the ZF-1, would’ve immediately asked about the little red button on the bottom of the gun.</blockquote><p name="3095" id="3095" class="graf graf--p graf-after--blockquote">Likewise, a real developer, when he picked up an architecture design, would’ve immediately asked about the overheads and complexity.</p><p name="3ad3" id="3ad3" class="graf graf--p graf-after--p">The little red button in this design is the sheer number of objects required, and they don’t seem reusable (view model? or even repository?). The boilerplate would be immense.</p><p name="7bdb" id="7bdb" class="graf graf--p graf-after--p">Hence the first approach would be to drop the assumption that every box be implemented as an object. Or drop OOP altogether in Swift.</p><p name="2165" id="2165" class="graf graf--p graf-after--p">Second, we may reduce the unnecessary complexity.</p><ol class="postList"><li name="21ad" id="21ad" class="graf graf--li graf-after--p">Too many objects to handle data transfer.</li><li name="e80b" id="e80b" class="graf graf--li graf-after--li">Yet too little control over data transfer. E.g.; you don’t have direct control over networking or database, buried in repository, which in turn is buried in abstraction which is buried in interactor which is buried in another abstraction…</li><li name="a525" id="a525" class="graf graf--li graf-after--li">Abstractions are there so you can swap out repositoty / data mapper / interactor … etc while view stays the same. Instead of swapping out <em class="markup--em markup--li-em">functions</em>, why not swapping out views?</li><li name="7a5b" id="7a5b" class="graf graf--li graf-after--li">Manual binding is tedious, can we combine view and view model via automatic binding?</li><li name="71c1" id="71c1" class="graf graf--li graf-after--li">Why do you need to swap out anything in the first place?</li></ol><p name="d19b" id="d19b" class="graf graf--p graf-after--li">In other words, the design is bad. It has no fire, no energy, no nothing!</p><h4 name="acc7" id="acc7" class="graf graf--h4 graf-after--p">Y’know I got a show to run here, and it must pop POP POP!</h4><p name="e52b" id="e52b" class="graf graf--p graf-after--h4">This is where Protocol Oriented Programming(POP) comes in.</p><p name="da26" id="da26" class="graf graf--p graf-after--p">I don’t mean basic shit like this</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="21d7" id="21d7" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Bird</span> {<br />  <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> { <span class="hljs-keyword">get</span> }<br />  <span class="hljs-keyword">var</span> canFly: <span class="hljs-type">Bool</span> { <span class="hljs-keyword">get</span> }<br />}<br /><br /><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Flyable</span> {<br />  <span class="hljs-keyword">var</span> airspeedVelocity: <span class="hljs-type">Double</span> { <span class="hljs-keyword">get</span> }<br />}</span></pre><p name="876e" id="876e" class="graf graf--p graf-after--pre">It made me sad that this is the best the industry can come up with after almost a decade of Swift as first POP language.</p><p name="c904" id="c904" class="graf graf--p graf-after--p">Look, tools are one thing. How to use tools is another. How to use tools effectively is an art in itself.</p><p name="6f49" id="6f49" class="graf graf--p graf-after--p">What made POP so hard? I speak from experience, because it is all about <strong class="markup--strong markup--p-strong">Control</strong>. Describe your control.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="60ca" id="60ca" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Korben</span> {<br />  <span class="hljs-keyword">var</span> stones: [<span class="hljs-type">Stone</span>] {<span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span>}<br />  <span class="hljs-keyword">var</span> taxi: <span class="hljs-type">TaxiService</span> {<span class="hljs-keyword">get</span>}<br />} <br /><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Korben</span> {<br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">getStones</span>() <span class="hljs-keyword">async</span> -&gt; [<span class="hljs-type">Stone</span>] { <span class="hljs-operator">...</span> }<br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">saveTheWorld</span>() { <span class="hljs-operator">...</span> }<br />}</span></pre><p name="c139" id="c139" class="graf graf--p graf-after--pre">It goes against every abstraction, every view model, every OOP, every SOLID.</p><p name="f0e5" id="f0e5" class="graf graf--p graf-after--p">That’s why it’s going to wok. Recall the scene where Zorg is choking on some cherry in the movie<em class="markup--em markup--p-em"> The Fifth Element</em>.</p><blockquote name="a3ec" id="a3ec" class="graf graf--blockquote graf-after--p">Priest Vito Cornelius: <strong class="markup--strong markup--blockquote-strong">Where’s the robot to pat you in the back? Or the engineer? Or their children, maybe?</strong> <em class="markup--em markup--blockquote-em">[Desk brings out Zorg’s pet Picasso; Zorg motions it to try and help him]</em> There, you see how all your so-called power counts for absolutely nothing? How your entire empire of destruction comes… crashing down. All because of one little… cherry. <em class="markup--em markup--blockquote-em">[Slaps Zorg in the back, causing him to spit the cherry at Picasso]</em></blockquote><p name="383d" id="383d" class="graf graf--p graf-after--blockquote">Where’s the <code class="markup--code markup--p-code">StonesRepository</code> ? Oh it’s worthless because you can just use some general-purpose service. E.g.; <code class="markup--code markup--p-code">TaxiService</code> . Why hard-coding it to a specific model type in the first place?</p><p name="0a99" id="0a99" class="graf graf--p graf-after--p">Or the <code class="markup--code markup--p-code">StonesMapper</code> ? Don’t even bother. Use <code class="markup--code markup--p-code">Codable</code> with generic type inference to chain functions together. Again, <em class="markup--em markup--p-em">function-oriented</em>. Why use class to do function’s job?</p><p name="261d" id="261d" class="graf graf--p graf-after--p">Or their abstraction <code class="markup--code markup--p-code">StonesStoreAbstraction</code> , maybe? What fking over-engineering dumb shit is this?</p><p name="b13f" id="b13f" class="graf graf--p graf-after--p">None of these are needed because the problem, i.e.; Korben Dallas doesn’t need it.</p><figure name="10a8" id="10a8" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*NsDE4of186_hMZ0fDXJwJQ.jpeg" data-width="828" data-height="500" src="https://cdn-images-1.medium.com/max/800/1*NsDE4of186_hMZ0fDXJwJQ.jpeg"></figure><p name="4409" id="4409" class="graf graf--p graf-after--figure">Why is over-generalization not in SOLID? Sounds like SOLID needs a<strong class="markup--strong markup--p-strong"> sixth element</strong>?</p><p name="1c45" id="1c45" class="graf graf--p graf-after--p">Let’s now look at this from reusability.</p><p name="999f" id="999f" class="graf graf--p graf-after--p">What are we reusing? The control flow. The services are, contrary to BBFB, quite fixed. The common ones are 1 networking service, 1 data (database, cache, userdefaults) service and that’s about it. There’s no need for N networking providers; but you do the similar fetch in every view.</p><p name="f277" id="f277" class="graf graf--p graf-after--p">We can swap out model by <code class="markup--code markup--p-code">associatedType</code> if needed. We don’t give a shit about view because it’s determined by binding anyway. Even if SDK doesn’t support automatic binding, all we need is a function <code class="markup--code markup--p-code">updateUI()</code> and attach it to model via property observer. <em class="markup--em markup--p-em">Function over object</em>.</p><p name="eb7e" id="eb7e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Control</strong> is at the center of all these. You need the mythical MVC developers to make POP work. How do you manage control when all you do is to hide it?</p><p name="3ac3" id="3ac3" class="graf graf--p graf-after--p">Another benefits of controlling directly is that you don’t have to propagate parameters. Say user inputs a name, and you need to use it in a <code class="markup--code markup--p-code">URLRequest</code> . Did you seriously propagate it through view model -&gt; interactor -&gt; repository -&gt; repositoryImpl and god knows what?</p><p name="dfc0" id="dfc0" class="graf graf--p graf-after--p">It is important that we don’t apply shit from Java to Swift directly. <strong class="markup--strong markup--p-strong">Swift has extension, </strong>and functions are first class citzens. We build architecture not from abstract principles or Android. We build it on Swift’s features.</p><p name="aa0a" id="aa0a" class="graf graf--p graf-after--p">In terms of control, extension removes most of the need for objects. Because what you actually need from objects… are <em class="markup--em markup--p-em">functions</em>! In practice you identify a couple of core services then extend around it.</p><p name="babe" id="babe" class="graf graf--p graf-after--p">And of course, this goes against BBFB. According to (useless use case) guy:</p><blockquote name="861a" id="861a" class="graf graf--blockquote graf-after--p">This is the easiest principle to follow and yet it is the one that has been more brutally violated by developers.</blockquote><blockquote name="a26b" id="a26b" class="graf graf--blockquote graf-after--blockquote">Somehow developers think that you should have an interface <em class="markup--em markup--blockquote-em">“only in the case of multiple implementations”.</em><br>This couldn’t be more wrong.</blockquote><blockquote name="b590" id="b590" class="graf graf--blockquote graf-after--blockquote">Any modern Software Architecture worth its name (Hexagonal, Onion, Clean) heavily relies on the DIP.<br><em class="markup--em markup--blockquote-em">We do not want our high-level business rules to depend upon low-level details.<br></em>We want the isolation of high-level abstractions from low-level details.</blockquote><p name="2665" id="2665" class="graf graf--p graf-after--blockquote">A lot of things are wrong here.</p><ol class="postList"><li name="eda7" id="eda7" class="graf graf--li graf-after--p">This is the easiest “principle” to sell tutorial.</li></ol><p name="101e" id="101e" class="graf graf--p graf-after--li">2. None of those modern software architecture worth a shit if it heavily relies on the DIP. It comes naturally by basic refactor.</p><p name="023d" id="023d" class="graf graf--p graf-after--p">3. How many levels are there? This creates a <strong class="markup--strong markup--p-strong">recursive </strong>problem right there.</p><p name="6314" id="6314" class="graf graf--p graf-after--p">What if you see your app as two-layer? Wouldn’t that simplify the problem?</p><p name="a4ca" id="a4ca" class="graf graf--p graf-after--p">Why proposed a layer-recursive problem and an architecture with <strong class="markup--strong markup--p-strong">MANY </strong>layers at the same time?</p><p name="67db" id="67db" class="graf graf--p graf-after--p">4. Function API is itself an interface. E.g.; <code class="markup--code markup--p-code">network.get(...)</code> , <code class="markup--code markup--p-code">network.post(...)</code> . You don’t know how they are implemented even when there’s no protocol interface.</p><p name="b77f" id="b77f" class="graf graf--p graf-after--p">I wish I could say <strong class="markup--strong markup--p-strong">he couldn’t be more wrong</strong>. But the fact is that <strong class="markup--strong markup--p-strong">he could</strong>.</p><p name="1bc8" id="1bc8" class="graf graf--p graf-after--p">None of these have anything to do with POP. None of these is about <strong class="markup--strong markup--p-strong">Control</strong>. It’s about satisfying a criteria in an acronym in a commercial tutorial with complete disregards to <strong class="markup--strong markup--p-strong">extension</strong>.</p><p name="e9cf" id="e9cf" class="graf graf--p graf-after--p">Do you see now why I have to fight against MVVM, BBFB, DI, TDD titans and all kinds of dumb shit in order to write some basic POP?</p><p name="c8f5" id="c8f5" class="graf graf--p graf-after--p">I’d provide real world POP example at this point if I were a tutorial channel. But I’m a rant / meme channel… lol</p><p name="3c55" id="3c55" class="graf graf--p graf-after--p">So instead I’ll rant some more about SOLID.</p><h4 name="c0ad" id="c0ad" class="graf graf--h4 graf-after--p">The 5 elements</h4><p name="2cf8" id="2cf8" class="graf graf--p graf-after--h4">S.O.L.I.D.</p><p name="ea8f" id="ea8f" class="graf graf--p graf-after--p">All of these are useless shit.</p><p name="bb8c" id="bb8c" class="graf graf--p graf-after--p">In my previous article <a href="https://swift2931.medium.com/why-use-cases-are-useless-47c0e799091d" data-href="https://swift2931.medium.com/why-use-cases-are-useless-47c0e799091d" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">“why use cases are useless”</a>, I argued why use cases are full of shit in BBFB. It’s no coincidence that the same guy who wrote useless use cases in 2019 is still pumping useless shit on <em class="markup--em markup--p-em">Better Programming</em> in 2022.</p><p name="7faf" id="7faf" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Boilerplate sells.</strong></p><p name="223b" id="223b" class="graf graf--p graf-after--p">What people need is a positive affirmation that they are not writing dumb shit. Look his line-up:</p><figure name="2f05" id="2f05" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*OUSbYL9sBP8858yCaleyaQ.png" data-width="1206" data-height="510" src="https://cdn-images-1.medium.com/max/800/1*OUSbYL9sBP8858yCaleyaQ.png"></figure><p name="d79a" id="d79a" class="graf graf--p graf-after--figure">Your code: worthless. Your sense of accomplishment on the shoulders of giants: priceless.</p><p name="8c72" id="8c72" class="graf graf--p graf-after--p">Recall that from the movie <em class="markup--em markup--p-em">World War Z, </em>there’s a tenth man rule:</p><blockquote name="1f8e" id="1f8e" class="graf graf--blockquote graf-after--p">No matter how improbable it may seem, the tenth man has to start thinking with the assumption that the other nine were wrong.</blockquote><p name="ece8" id="ece8" class="graf graf--p graf-after--blockquote">So I did some googling to find this:</p><p name="c984" id="c984" class="graf graf--p graf-after--p"><a href="https://qntm.org/clean" data-href="https://qntm.org/clean" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">It’s probably time to stop recommending Clean Code</a></p><p name="1cc2" id="1cc2" class="graf graf--p graf-after--p">in which the author commented on the code example from Martin’s book.</p><p name="0638" id="0638" class="graf graf--p graf-after--p">I’ll quote two here. One about Martin’s function having side effects:</p><blockquote name="8379" id="8379" class="graf graf--blockquote graf-after--p">Of the fifteen private methods, fully thirteen of them either have side effects (such as <code class="markup--code markup--blockquote-code">buildIncludeDirective</code>, which has side effects on <code class="markup--code markup--blockquote-code">newPageContent</code>) or call out to other methods which have side effects</blockquote><p name="a571" id="a571" class="graf graf--p graf-after--blockquote">One is Martin being a “promoter” of SOLID:</p><blockquote name="4eea" id="4eea" class="graf graf--blockquote graf-after--p">Martin is a huge proponent of OO, having invented three of the five principles which make up SOLID, and having popularised the term. But the <strong class="markup--strong markup--blockquote-strong">total absence of functional programming techniques</strong> or even simple procedural code was regrettable even then, and has only grown more obvious in the years since.</blockquote><p name="7160" id="7160" class="graf graf--p graf-after--blockquote">Do you think <em class="markup--em markup--p-em">Better Programming</em> will publish this? Or <em class="markup--em markup--p-em">AndroidProDevs</em>?</p><p name="7253" id="7253" class="graf graf--p graf-after--p">So when the dude that wrote useless use cases said this</p><blockquote name="8bc3" id="8bc3" class="graf graf--pullquote graf-after--p"><em class="markup--em markup--pullquote-em">Clean Architecture is the outcome of the S.O.L.I.D. principles.</em></blockquote><p name="b260" id="b260" class="graf graf--p graf-after--pullquote">It’s a conflict of interest. Of course Martin would sell you this shit. He is promoting both.</p><p name="d8e0" id="d8e0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">This is business, not coding.</strong></p><p name="56f1" id="56f1" class="graf graf--p graf-after--p">None of the SOLID is even solid. Again, quoting the guy that wrote useless use cases:</p><blockquote name="8d3a" id="8d3a" class="graf graf--blockquote graf-after--p">99% of the things you want to do with inheritance can be done with composition so you should always <strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">favor</em> <em class="markup--em markup--blockquote-em">composition over inheritance</em></strong>.</blockquote><p name="174d" id="174d" class="graf graf--p graf-after--blockquote">So why is <em class="markup--em markup--p-em">composition</em> not part of SOLID? Why did he even bother with inheritance?</p><p name="9ea5" id="9ea5" class="graf graf--p graf-after--p">Is there a <strong class="markup--strong markup--p-strong">sixth element</strong>?</p><h4 name="bc81" id="bc81" class="graf graf--h4 graf-after--p">The sixth element</h4><figure name="0a3a" id="0a3a" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*qVpwJZKW_tr9wHlEolBQWQ.jpeg" data-width="533" data-height="500" src="https://cdn-images-1.medium.com/max/800/1*qVpwJZKW_tr9wHlEolBQWQ.jpeg"></figure><p name="ef34" id="ef34" class="graf graf--p graf-after--figure">Since POP is about control flow. How do you refactor your control into separate protocols?</p><p name="f4f7" id="f4f7" class="graf graf--p graf-after--p">Enters <strong class="markup--strong markup--p-strong">protocol composition</strong>. While one type can conform to multiple protocols, there’s a limit on human attention and costs of overheads and maintenance.</p><p name="90ed" id="90ed" class="graf graf--p graf-after--p">Usually the goal is to have one protocol that covers everything. Why? Because most of the heavy-lifting are done via extension. There would only be a few core related services and stored properties. The general guideline would be such that each protocol can stand on its own, and you can keep composition simple across the app.</p><p name="0568" id="0568" class="graf graf--p graf-after--p">This wouldn’t be a problem except that it goes against BBFB.</p><figure name="502a" id="502a" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*-A1mE3feDzAVxKIqJ1LC3w.png" data-width="1343" data-height="652" src="https://cdn-images-1.medium.com/max/800/1*-A1mE3feDzAVxKIqJ1LC3w.png"></figure><p name="6c41" id="6c41" class="graf graf--p graf-after--figure">Remember when I say he could be more wrong?</p><p name="5244" id="5244" class="graf graf--p graf-after--p">This is such an epic fail. This is the same technique he used in 2019 useless use cases. He never bothered to ask if there’s a more efficient way to use protocol all the way to 2022.</p><p name="20df" id="20df" class="graf graf--p graf-after--p">If we look control logic from higher composition viewpoint, this is the <strong class="markup--strong markup--p-strong">WORST</strong> protocol composition.</p><p name="1634" id="1634" class="graf graf--p graf-after--p">You can’t write this dumb shit in Swift. I don’t think you should write this even in Java!</p><p name="967c" id="967c" class="graf graf--p graf-after--p">A POP example would be:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="42c5" id="42c5" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Login</span>: <span class="hljs-title class_">class</span> {<br />  <span class="hljs-comment">// requirement</span><br />}<br /><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Login</span> {<br />  <span class="hljs-comment">// implement it!</span><br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">login</span>() { <span class="hljs-operator">...</span> }<br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">logout</span>() { <span class="hljs-operator">...</span> }<br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">createAccount</span>() { <span class="hljs-operator">...</span> }<br />}</span></pre><p name="e8b7" id="e8b7" class="graf graf--p graf-after--pre">Why <code class="markup--code markup--p-code">class</code> ? Because it always invoves state changes, hence has to be conformed by a reference type. And becasue you want a dedicated service to handle credential, it is not meant to be reused. Then why write it as a protocol instead of class? Because you likely will need a protocol to handle networking. I just make it a practice to write protocol first, because often you didn’t know the whole picture yet.</p><p name="64c7" id="64c7" class="graf graf--p graf-after--p">On the other hand, his arguments are nonsense.</p><blockquote name="39e6" id="39e6" class="graf graf--blockquote graf-after--p">Keep interfaces small so that users don’t end up depending on things they don’t need.</blockquote><p name="b620" id="b620" class="graf graf--p graf-after--blockquote">Didn’t he create this protocol so high level doesn’t depend on low level? But in doing so it now depends on protocol itself?</p><blockquote name="9404" id="9404" class="graf graf--blockquote graf-after--p">This means that a change in <code class="markup--code markup--blockquote-code">logout</code> will recompile <code class="markup--code markup--blockquote-code">LoginViewModel</code>.<br>And also adding/removing methods to <code class="markup--code markup--blockquote-code">UserService</code> will cause a recompilation.</blockquote><p name="bed5" id="bed5" class="graf graf--p graf-after--blockquote">I don’t pretend to know how Xcode works. But if RE-COMPILATION is your concern of coding, you are probably doing it wrong. Let compiler optimization worry about that. Worry about dependency, worry about compiler, why aren’t you worrying about refactor?</p><blockquote name="5e32" id="5e32" class="graf graf--blockquote graf-after--p">How do you solve this? Simple, instead of having a big interface you create more and smaller interfaces:</blockquote><p name="3323" id="3323" class="graf graf--p graf-after--blockquote">That is not simple. Not even close. Are you going to conform to 30 member functions as protocols in one class?</p><blockquote name="97b7" id="97b7" class="graf graf--blockquote graf-after--p">After all, which class do you think is more likely to break the SRP?<br>A class with a single method or a class with 100 methods?</blockquote><p name="e4ab" id="e4ab" class="graf graf--p graf-after--blockquote">A class with a single method.</p><p name="ddc1" id="ddc1" class="graf graf--p graf-after--p">Why? Because you can’t do shit without passing in reference type objects, which are mutable. Then you will induce side effects through those reference type objects, like Martin in his book.</p><p name="4450" id="4450" class="graf graf--p graf-after--p">This is why we have value type. This is why we highlight mutable <code class="markup--code markup--p-code">class</code> .</p><p name="9a9b" id="9a9b" class="graf graf--p graf-after--p">Now, ask yourself. Can any of the books in his reference teach you these?</p><figure name="c389" id="c389" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*dpo4Oo5kG0NuTwxwes46yA.png" data-width="694" data-height="353" src="https://cdn-images-1.medium.com/max/800/1*dpo4Oo5kG0NuTwxwes46yA.png"></figure><p name="1078" id="1078" class="graf graf--p graf-after--figure">Modern software architecture my ass. Start with hello world man.</p><p name="0303" id="0303" class="graf graf--p graf-after--p">Answering the question at the beginning, good architecture can be cheap. At the very least don’t write expensive dumb shit!</p><figure name="a0cb" id="a0cb" class="graf graf--figure graf-after--p graf--trailing"><img class="graf-image" data-image-id="1*gvCXGDB9kThKZ1UF57eClg.jpeg" data-width="712" data-height="500" src="https://cdn-images-1.medium.com/max/800/1*gvCXGDB9kThKZ1UF57eClg.jpeg"><figcaption class="imageCaption">The chest that is SOLID.</figcaption></figure></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/20149103c378"><time class="dt-published" datetime="2023-10-12T10:11:05.326Z">October 12, 2023</time></a>.</p><p><a href="https://medium.com/@swift2931/the-sixth-element-20149103c378" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>