<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Stop abusing value type</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Stop abusing value type</h1>
</header>
<section data-field="subtitle" class="p-summary">
How to fail upwards in programming
</section>
<section data-field="body" class="e-content">
<section name="733a" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="8a39" id="8a39" class="graf graf--h3 graf--leading graf--title">Stop abusing value type</h3><h4 name="3832" id="3832" class="graf graf--h4 graf-after--h3 graf--subtitle">How to fail upwards in programming</h4><figure name="67ac" id="67ac" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*K9RvUMq4nOivvGJfZQw0CQ.png" data-width="1498" data-height="1169" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*K9RvUMq4nOivvGJfZQw0CQ.png"><figcaption class="imageCaption">House MD</figcaption></figure><h4 name="c382" id="c382" class="graf graf--h4 graf-after--figure">I love this part</h4><p name="c398" id="c398" class="graf graf--p graf-after--h4">In case you are new, I make fun of industry titans for their dumb shit mistakes here.</p><p name="b98a" id="b98a" class="graf graf--p graf-after--p">It may be hard to believe, but there are titans in <em class="markup--em markup--p-em">Better Programming </em>who made epic mistakes <strong class="markup--strong markup--p-strong">consistently</strong>.</p><p name="af08" id="af08" class="graf graf--p graf-after--p">This titan in particular, wrote this in <a href="https://medium.com/@riccardocipolleschi/stop-using-protocols-cd63744a3261" data-href="https://medium.com/@riccardocipolleschi/stop-using-protocols-cd63744a3261" class="markup--anchor markup--p-anchor" target="_blank">Stop Using Protocols!</a></p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="23d1" id="23d1" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Service</span> {<br />  <span class="hljs-keyword">var</span> getProducts: () -&gt; [<span class="hljs-type">Product</span>]<br />  <span class="hljs-keyword">var</span> getProduct: (<span class="hljs-keyword">_</span> id: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Product</span>?<br />}</span></pre><p name="6595" id="6595" class="graf graf--p graf-after--pre">Isn’t this a balant violation of value type? Because <code class="markup--code markup--p-code">Service</code> is supposed to be <code class="markup--code markup--p-code">mutable</code> ?</p><p name="3708" id="3708" class="graf graf--p graf-after--p">And he had the balls to monetize it? After <strong class="markup--strong markup--p-strong">LECTURING </strong>you on why protocol is bad?</p><p name="9eba" id="9eba" class="graf graf--p graf-after--p">Isn’t this interview question 101 for beginners?</p><p name="0647" id="0647" class="graf graf--p graf-after--p">Who wrote this shit? A Meta engineer with 4K followers?</p><blockquote name="9a1c" id="9a1c" class="graf graf--blockquote graf-after--p">Don’t cry<br>Don’t raise your eye<br>It’s only programmer wasteland</blockquote><p name="a6da" id="a6da" class="graf graf--p graf-after--blockquote">It’s member-only. I read it so you don’t have to.</p><p name="b104" id="b104" class="graf graf--p graf-after--p">(edit: certain R words have been censored to conform to platform TOS, which I think is a POS)</p><p name="a595" id="a595" class="graf graf--p graf-after--p">(edit2: after “careful review”, apparently “Regarded” is a dirty word too. I replaced it “QUESTIONABLE”). If it doesn’t work, then it doesn’t work. I might go out in Baba O’Riley lol)</p><p name="af59" id="af59" class="graf graf--p graf-after--p">Since his conclusion is wrong, let’s review his arguments for entertainment value, and examine how you fail upwards in this field.</p><h4 name="a315" id="a315" class="graf graf--h4 graf-after--p">Out here in the fields</h4><blockquote name="641b" id="641b" class="graf graf--blockquote graf-after--h4">Out here in the fields<br>I fight for my meals<br>I get my back into my living</blockquote><p name="5f46" id="5f46" class="graf graf--p graf-after--blockquote">Oh, you should know the song by now. Go play it on youtube. (Baba O’Riley)</p><p name="f2ac" id="f2ac" class="graf graf--p graf-after--p">Damn, that intro.</p><p name="3835" id="3835" class="graf graf--p graf-after--p">He began with this story:</p><blockquote name="af4b" id="af4b" class="graf graf--blockquote graf-after--p">Four years later, in 2019, Apple stated that it’s not a good idea to always start with a protocol. They suggest starting with concrete types in another session and, eventually, <strong class="markup--strong markup--blockquote-strong">abstract them in a protocol later.</strong></blockquote><blockquote name="1392" id="1392" class="graf graf--blockquote graf-after--blockquote">Recently, I was watching the content of pointfree.co: a video series of Swift programming with a functional approach. In one of their collections, they presented a concept that is really illuminating: Protocol Witnesses. <strong class="markup--strong markup--blockquote-strong">This is practically what the compiler does under the hood and they can simplify a lot our code.</strong></blockquote><p name="590c" id="590c" class="graf graf--p graf-after--blockquote">In two paragraphs, he covered an excuse, a commercial, and a dumb shit brute force disguised as solution. Impressive.</p><p name="95b4" id="95b4" class="graf graf--p graf-after--p">Am I the only one who actually read the article?</p><blockquote name="79be" id="79be" class="graf graf--pullquote graf-after--p"><strong class="markup--strong markup--pullquote-strong">This is practically what the compiler does under the hood</strong></blockquote><p name="b2f0" id="b2f0" class="graf graf--p graf-after--pullquote">So why did you do compiler’s job manually? If it has to be done under the hood, why do you think it will simplify your code above the hood?</p><blockquote name="768a" id="768a" class="graf graf--blockquote graf-after--p">Sally ,take my hand<br>Travel south crossland<br>Put out the fire<br>Don’t look past my compiler</blockquote><p name="448b" id="448b" class="graf graf--p graf-after--blockquote">And he got this idea from a third party who has a conflict of interest because their business is to sell this shit.</p><p name="e9c3" id="e9c3" class="graf graf--p graf-after--p">As for whether you should start with protocol or not, it depends on what you plan to do with the protocol. Let me guess, he is going to use it in an OOP legacy way?</p><blockquote name="7029" id="7029" class="graf graf--blockquote graf-after--p">We mainly use protocols for two reasons:</blockquote><blockquote name="20da" id="20da" class="graf graf--blockquote graf-after--blockquote">To model interfaces and requirements.</blockquote><blockquote name="cda6" id="cda6" class="graf graf--blockquote graf-after--blockquote">To abstract common behaviors and improve generalization.</blockquote><p name="0498" id="0498" class="graf graf--p graf-after--blockquote">Wrong.</p><p name="b473" id="b473" class="graf graf--p graf-after--p">Look, my credential is that I’m one of the 2 people who wrote articles under #Protocol Oriented Programming.</p><p name="800a" id="800a" class="graf graf--p graf-after--p">POP is different. POP with Swift is even more different.</p><p name="db3c" id="db3c" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“We”, as in people who bother to learn what <em class="markup--em markup--p-em">protocol-oriented </em>is, use protocols for these reasons:</p><ol class="postList"><li name="ba9a" id="ba9a" class="graf graf--li graf-after--p">Refactor out <strong class="markup--strong markup--li-strong">CONTROL</strong> flow</li><li name="3272" id="3272" class="graf graf--li graf-after--li">Default implementation</li><li name="38da" id="38da" class="graf graf--li graf-after--li">Extension</li><li name="c974" id="c974" class="graf graf--li graf-after--li">Composition</li><li name="3d5f" id="3d5f" class="graf graf--li graf-after--li">Specialization over generalization</li></ol><p name="1d6b" id="1d6b" class="graf graf--p graf-after--li">Requirement? It helps when compiler generates stubs for you. But we don’t want other devs to re-implement everything. You only fill necessary parameters relevant to your customization.</p><p name="100f" id="100f" class="graf graf--p graf-after--p">Why is <strong class="markup--strong markup--p-strong">CONTROL </strong>is bold face? Because otherwise you pretend everything is harm-less value type model. Like <code class="markup--code markup--p-code">ViewModel</code> , <code class="markup--code markup--p-code">struct Service</code> .</p><p name="5ce7" id="5ce7" class="graf graf--p graf-after--p">POP with Swift plus Control / function oriented. You will never see this elsewhere. This is why I am one of the 2 people who wrote articles under #Protocol Oriented Programming.</p><p name="abff" id="abff" class="graf graf--p graf-after--p">As a comparison, he passed <code class="markup--code markup--p-code">Service</code> protocol as a parameter</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="dc58" id="dc58" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductVC</span>: <span class="hljs-title class_">UIViewController</span> {<br /><br />  <span class="hljs-keyword">let</span> productService: <span class="hljs-type">Service</span><br />  <span class="hljs-keyword">var</span> products: [<span class="hljs-type">Product</span>]<br /><br />  <span class="hljs-keyword">init</span>(<span class="hljs-params">productService</span>: <span class="hljs-type">Service</span>) {<br />    <span class="hljs-keyword">self</span>.productService <span class="hljs-operator">=</span> productService<br />    <span class="hljs-keyword">self</span>.products <span class="hljs-operator">=</span> []<br />    <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(nibName: <span class="hljs-literal">nil</span>, bundle: <span class="hljs-literal">nil</span>)<br />  }<br />  <span class="hljs-comment">// ...</span><br />}</span></pre><p name="dbca" id="dbca" class="graf graf--p graf-after--pre">But described it as</p><blockquote name="7a18" id="7a18" class="graf graf--blockquote graf-after--p">we inject the dependency by passing it to the init</blockquote><p name="7d2c" id="7d2c" class="graf graf--p graf-after--blockquote">Because this way you wouldn’t ask why you should pass <code class="markup--code markup--p-code">Service</code> from outside. This is why he is in Meta and you are not.</p><p name="3ecb" id="3ecb" class="graf graf--p graf-after--p">Ask yourself, what would POP do?</p><p name="12b1" id="12b1" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“We” don’t use it for generalization, at least at first. We use it for composition.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="90eb" id="90eb" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductVC</span>: <span class="hljs-title class_">UIViewController</span>, <span class="hljs-title class_">Service</span> {<br />    <span class="hljs-comment">//...</span><br /> }<br /><br /></span></pre><p name="80ab" id="80ab" class="graf graf--p graf-after--pre">This gives <code class="markup--code markup--p-code">ProductVC</code> the capability to do <code class="markup--code markup--p-code">Service</code> .</p><p name="9d91" id="9d91" class="graf graf--p graf-after--p">This also means you don’t need to <em class="markup--em markup--p-em">inject </em>shit into VC. This is bad, because otherwise how do titans pretend they are better than you? E.g.;</p><blockquote name="18dd" id="18dd" class="graf graf--blockquote graf-after--p">We decided to add an associated type to the <code class="markup--code markup--blockquote-code">Service</code> and… the <code class="markup--code markup--blockquote-code">VC</code> cannot keep a reference to the <strong class="markup--strong markup--blockquote-strong">dependency </strong>anymore!</blockquote><p name="a76a" id="a76a" class="graf graf--p graf-after--blockquote">Note how he has to rub “<strong class="markup--strong markup--p-strong">dependency</strong>” in your face at every opportunity. To show that he is better than you. As if he is not just passing parameters.</p><p name="4b0b" id="4b0b" class="graf graf--p graf-after--p">What would POP do? First we remove this noise. Replace it with “<strong class="markup--strong markup--p-strong">parameter</strong>”. Due to <code class="markup--code markup--p-code">associatedtype</code> , we can’t create a protocol instance. Because <code class="markup--code markup--p-code">associatedType</code> is not exactly like generics <code class="markup--code markup--p-code">&lt;T&gt;</code> . It has to be determined in compile time.</p><p name="4581" id="4581" class="graf graf--p graf-after--p">And he stopped here! If he can’t inject shit, then he won’t even bother. Look at his protocol:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="7273" id="7273" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Service</span> {<br />  <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Entity</span><br /><br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">get</span>() -&gt; [<span class="hljs-type">Entity</span>]<br /><br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">id</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Entity</span>?<br />}</span></pre><p name="18e5" id="18e5" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">Entity</code> is actually a placeholder here. You need to specify concrete type using <code class="markup--code markup--p-code">typealias</code> , which won’t be a problem when you conform to it like <code class="markup--code markup--p-code">class ProductVC: UIViewController, Service .</code> Compiler even generates a stub for you.</p><p name="1bb8" id="1bb8" class="graf graf--p graf-after--p">What he actually needs is this if he likes generalization this much:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="5e2c" id="5e2c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">AbstractEntity</span> { <span class="hljs-operator">...</span> }<br /><br /><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Service</span> {<br /><br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">get</span>() -&gt; [<span class="hljs-type">AbstractEntity</span>]<br /><br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">id</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">AbstractEntity</span>?<br />}</span></pre><p name="c55d" id="c55d" class="graf graf--p graf-after--pre">That seems very abstract? Who told you to improve generalization in the first place?</p><blockquote name="32c9" id="32c9" class="graf graf--blockquote graf-after--p">To abstract common behaviors and improve generalization.</blockquote><p name="fca8" id="fca8" class="graf graf--p graf-after--blockquote">Oh that’s right…</p><p name="a892" id="a892" class="graf graf--p graf-after--p">So he couldn’t get the “way” to work. And the way was too complex anyway:</p><blockquote name="c2e7" id="c2e7" class="graf graf--blockquote graf-after--p">Now, this approach works. <strong class="markup--strong markup--blockquote-strong">This way has nothing wrong </strong>and we are used to model our code like this. However, this creates a hierarchy that can be <strong class="markup--strong markup--blockquote-strong">complex</strong>:</blockquote><p name="738d" id="738d" class="graf graf--p graf-after--blockquote">He is wrong again by saying this way has notthing wrong.</p><p name="fd96" id="fd96" class="graf graf--p graf-after--p">What is the way? You create protocol for everything, inject everything as protocol, so you can mock everything by re-implementing every protocol, e.g.;<code class="markup--code markup--p-code"> class MockedService: Service</code></p><p name="b79d" id="b79d" class="graf graf--p graf-after--p">I call this <strong class="markup--strong markup--p-strong">QUESTIONABLE Brute Force(QBF). </strong>Learn how to use variables. It’s amazing how you can sell literal tutorials on QBF and act like a titan. I have a lot of articles on this topic you can check.</p><p name="5db0" id="5db0" class="graf graf--p graf-after--p">From my perspective, QBF is QUESTIONABLE to begin with, and to make it work with generics you need such a QUESTIONABLE level of generalization that even a Meta engineer can’t get it to work. He got stuck in <code class="markup--code markup--p-code">associatedtype</code> for some reason.</p><p name="a598" id="a598" class="graf graf--p graf-after--p">But that is exactly how you fail upwards. What did he do? Post a complain and monetize it. Moreover, he asked you to stop using protocol!</p><p name="1687" id="1687" class="graf graf--p graf-after--p">He is in Meta, he doesn’t need to prove shit.</p><p name="3c56" id="3c56" class="graf graf--p graf-after--p">But I do.</p><h4 name="5832" id="5832" class="graf graf--h4 graf-after--p">I need to fight</h4><blockquote name="b842" id="b842" class="graf graf--blockquote graf-after--h4">I need to fight<br>To prove I’m right</blockquote><p name="3413" id="3413" class="graf graf--p graf-after--blockquote">He then gave an example on why the <em class="markup--em markup--p-em">approach that works</em> doesn’t really work.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="3ca5" id="3ca5" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Movie</span>: <span class="hljs-title class_">Product</span>, <span class="hljs-title class_">Discountable</span> {<br /><br />  <span class="hljs-keyword">var</span> price: <span class="hljs-type">Decimal</span><br /><br />  <span class="hljs-keyword">var</span> releaseDate: <span class="hljs-type">Date</span><br /><br />  <span class="hljs-keyword">var</span> discount: <span class="hljs-type">Double</span> {<br />    <span class="hljs-keyword">let</span> timePassed <span class="hljs-operator">=</span> <span class="hljs-type">Date</span>().timeIntervalSince(<span class="hljs-keyword">self</span>.releaseDate)<br /><br />    <span class="hljs-keyword">if</span> timePassed <span class="hljs-operator">&gt;</span> <span class="hljs-number">2</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">Self</span>.oneYear {<br />      <span class="hljs-keyword">return</span> <span class="hljs-number">0.5</span><br />    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> timePassed <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">Self</span>.oneYear {<br />      <span class="hljs-keyword">return</span> <span class="hljs-number">0.1</span><br />    }<br /><br />    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br />  }<br />}<br /><br /><span class="hljs-keyword">struct</span> <span class="hljs-title class_">VideoGame</span>: <span class="hljs-title class_">Product</span>, <span class="hljs-title class_">Discountable</span> {<br />  <span class="hljs-keyword">var</span> price: <span class="hljs-type">Decimal</span><br /><br />  <span class="hljs-keyword">var</span> releaseDate: <span class="hljs-type">Date</span><br /><br />  <span class="hljs-keyword">var</span> discount: <span class="hljs-type">Double</span> {<br />    <span class="hljs-keyword">let</span> timePassed <span class="hljs-operator">=</span> <span class="hljs-type">Date</span>().timeIntervalSince(<span class="hljs-keyword">self</span>.releaseDate)<br /><br />    <span class="hljs-keyword">if</span> timePassed <span class="hljs-operator">&gt;</span> <span class="hljs-number">2</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">Self</span>.oneYear {<br />      <span class="hljs-keyword">return</span> <span class="hljs-number">0.9</span><br />    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> timePassed <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">Self</span>.oneYear {<br />      <span class="hljs-keyword">return</span> <span class="hljs-number">0.2</span><br />    }<br /><br />    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br />  }<br />}<br /><br /><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Book</span>: <span class="hljs-title class_">Product</span>, <span class="hljs-title class_">Discountable</span> {<br />  <span class="hljs-keyword">var</span> price: <span class="hljs-type">Decimal</span><br /><br />  <span class="hljs-keyword">var</span> releaseDate: <span class="hljs-type">Date</span><br /><br />  <span class="hljs-keyword">var</span> discount: <span class="hljs-type">Double</span> {<br />    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br />  }<br />}</span></pre><p name="7031" id="7031" class="graf graf--p graf-after--pre">His conclusions are:</p><blockquote name="9cfe" id="9cfe" class="graf graf--blockquote graf-after--p">We have created a hierarchy that we have to handle and maintain: we have the protocols that define the products (2 types) and all the structs that implement them (other 3 types). Moreover, if we add some new products, <strong class="markup--strong markup--blockquote-strong">we have to remember to implement their discounting feature.</strong></blockquote><p name="a127" id="a127" class="graf graf--p graf-after--blockquote">First he didn’t refactor <code class="markup--code markup--p-code">let timePassed = Date().timeIntervalSince(self.releaseDate)</code></p><p name="93de" id="93de" class="graf graf--p graf-after--p">Second, you didn’t need to remember, because otherwise it won’t compile since he didn’t provide defaults.</p><p name="e087" id="e087" class="graf graf--p graf-after--p">Third, why not provide defaults?</p><p name="1169" id="1169" class="graf graf--p graf-after--p">Forth, note his implicit transition:</p><blockquote name="1cb5" id="1cb5" class="graf graf--blockquote graf-after--p">Now, this approach works.</blockquote><p name="bcb9" id="bcb9" class="graf graf--p graf-after--blockquote">=&gt;</p><blockquote name="34e6" id="34e6" class="graf graf--blockquote graf-after--p"><strong class="markup--strong markup--blockquote-strong">This way has nothing wrong </strong>and we are used to model our code like this.</blockquote><p name="bcd6" id="bcd6" class="graf graf--p graf-after--blockquote">=&gt;</p><figure name="85fe" id="85fe" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*SH3QJwdVPjwlLT9LPX5tDQ.jpeg" data-width="500" data-height="562" src="https://cdn-images-1.medium.com/max/800/1*SH3QJwdVPjwlLT9LPX5tDQ.jpeg"></figure><p name="9bdc" id="9bdc" class="graf graf--p graf-after--figure">Nobody told you to use protocol for everything. Well, nobody except QBF.</p><p name="07fc" id="07fc" class="graf graf--p graf-after--p">He used protocol without defaults to require properties in a value type, then complained about it when there are 3 value types. Then he came to a conclusion that it’s not QBF that is QUESTIONABLE, but protocol is bad?</p><p name="0a68" id="0a68" class="graf graf--p graf-after--p">This is such a rigorous deduction process we are witnessing.</p><p name="1e4e" id="1e4e" class="graf graf--p graf-after--p">You know what POP would do? Recall why we use protocol:</p><blockquote name="bf85" id="bf85" class="graf graf--pullquote graf-after--p">1. Refactor out <strong class="markup--strong markup--pullquote-strong">CONTROL</strong> flow</blockquote><p name="40e7" id="40e7" class="graf graf--p graf-after--pullquote">Where’s control flow? Value type is immutable, you can’t have state changes, i.e.; no control.</p><p name="ce3d" id="ce3d" class="graf graf--p graf-after--p">So I probably won’t even bother with protocols, c.f.;</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="2b10" id="2b10" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">ProductType</span> {<br />  <span class="hljs-keyword">case</span> movie, videoGame, book<br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">discount</span>(<span class="hljs-operator">...</span>) -&gt; <span class="hljs-type">Double</span> {<br />    <span class="hljs-comment">// switch cases</span><br />  }<br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">discountByDate</span>(<span class="hljs-operator">...</span>) -&gt; <span class="hljs-type">Double</span> {<br />    <span class="hljs-comment">// default for let timePassed = Date().timeIntervalSince(self.releaseDate) ... </span><br />  }<br />}<br /><br /><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Model</span> {<br />  <span class="hljs-keyword">var</span> releaseDate: <span class="hljs-type">Date</span><br />  <span class="hljs-keyword">var</span> price: <span class="hljs-type">Decimal</span><br />  <span class="hljs-keyword">var</span> type: <span class="hljs-type">ProductType</span><br />  <span class="hljs-keyword">var</span> discount: <span class="hljs-type">Double</span> {<br />    type.disount(<span class="hljs-operator">...</span>)<br />  }<br />}</span></pre><p name="ac8d" id="ac8d" class="graf graf--p graf-after--pre">You may think <code class="markup--code markup--p-code">switch</code> is low-tech, even brute force (won’t use this approach when cases are many). But I want to emphasize the importance of using compile time functions over runtime closures. You may argue that in this case closures are likely non-escaping pure functions, and you may be right. But for us professionals we can’t just generalize it to every use case… right?</p><blockquote name="36b7" id="36b7" class="graf graf--blockquote graf-after--p">Converting a protocol into a struct.</blockquote><blockquote name="b88f" id="b88f" class="graf graf--blockquote graf-after--blockquote">First of all, any protocol can be transformed into a concrete type, following a few conversion rules.</blockquote><blockquote name="f917" id="f917" class="graf graf--blockquote graf-after--blockquote">Whenever there is an associated type, add a generic.</blockquote><blockquote name="45e4" id="45e4" class="graf graf--blockquote graf-after--blockquote">Whenever there is a <code class="markup--code markup--blockquote-code">Self</code>, add a generic.</blockquote><blockquote name="cfec" id="cfec" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong">Whenever the protocol requires a function implementation, use a closure.</strong></blockquote><p name="e79a" id="e79a" class="graf graf--p graf-after--blockquote">…</p><p name="be03" id="be03" class="graf graf--p graf-after--p">Look, I give up. Let’s pump stupid non-sense as best practice.</p><blockquote name="347e" id="347e" class="graf graf--blockquote graf-after--p">The exodus is here<br>The happy ones are near<br>Let’s get together<br>Before we get much older</blockquote><h4 name="43da" id="43da" class="graf graf--h4 graf-after--blockquote">Programmers’ wasteland</h4><blockquote name="6cdf" id="6cdf" class="graf graf--blockquote graf-after--h4">Programmer wasteland<br>It’s only programmerwasteland<br>Programmer wasteland</blockquote><p name="e52d" id="e52d" class="graf graf--p graf-after--blockquote">Or as I call it, <em class="markup--em markup--p-em">Better Programming</em>.</p><p name="6eb4" id="6eb4" class="graf graf--p graf-after--p">All jokes aside, we have to respect his technique to segue from value type <code class="markup--code markup--p-code">Movie</code> to <code class="markup--code markup--p-code">Service</code> .</p><p name="176d" id="176d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">He didn’t even pause for a moment to mention reference type.</strong></p><p name="1c92" id="1c92" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">Movie</code> and <code class="markup--code markup--p-code">Service</code> have completely different semantics.</p><p name="aeb1" id="aeb1" class="graf graf--p graf-after--p">He is just going to apply “conclusion”, which is very questionable in of itself on a very special use case, to everything!</p><p name="aeb9" id="aeb9" class="graf graf--p graf-after--p">I remember this guy because his <a href="https://swift2931.medium.com/aim-for-the-bushes-4045825f4f34" data-href="https://swift2931.medium.com/aim-for-the-bushes-4045825f4f34" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">epic fails of historic porpotion</a> . There’s a lot you can learn just from code-review. If anything, he is <em class="markup--em markup--p-em">consistent</em>.</p><p name="009c" id="009c" class="graf graf--p graf-after--p">He will sacrifice <strong class="markup--strong markup--p-strong">production</strong> code quality, E.g.; add boilerplate like</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="d566" id="d566" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">  <span class="hljs-keyword">init</span>(<span class="hljs-params">productService</span>: <span class="hljs-type">Service</span>&lt;<span class="hljs-type">Product</span>&gt;) {<br />    <span class="hljs-keyword">self</span>.productService <span class="hljs-operator">=</span> productService<br />    <span class="hljs-keyword">self</span>.products <span class="hljs-operator">=</span> []<br />    <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(nibName: <span class="hljs-literal">nil</span>, bundle: <span class="hljs-literal">nil</span>)<br />  }</span></pre><p name="7361" id="7361" class="graf graf--p graf-after--pre">Just so he can claim</p><blockquote name="a817" id="a817" class="graf graf--blockquote graf-after--p">It is now<strong class="markup--strong markup--blockquote-strong"> extremely simple</strong> to test the dependencies: we just have to create a struct with the required closures in the test files:</blockquote><p name="dd61" id="dd61" class="graf graf--p graf-after--blockquote">How extremely simple?</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="d6cd" id="d6cd" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">// Generic version</span><br /><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Service</span>&lt;<span class="hljs-title class_">Entity</span>&gt; {<br />  <span class="hljs-keyword">var</span> getList: () -&gt; [<span class="hljs-type">Entity</span>]<br />  <span class="hljs-keyword">var</span> getDetails: (<span class="hljs-keyword">_</span> id: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Entity</span>?<br />}<br /><br /><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestProductVC</span>: <span class="hljs-title class_">XCTestCase</span> {<br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">testVCInitialized</span>() <span class="hljs-keyword">throws</span> {<br /><br />    <span class="hljs-keyword">let</span> sut <span class="hljs-operator">=</span> <span class="hljs-type">ProductVC</span>(productService: <span class="hljs-type">Service</span>&lt;<span class="hljs-type">Product</span>&gt;(getList: { <span class="hljs-keyword">return</span> [] }, getDetails: { <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> }))<br />    <span class="hljs-type">XCTAssertTrue</span>(sut.products.isEmpty)<br />  }<br />  <span class="hljs-comment">// other tests with other mocks</span><br />}</span></pre><p name="0044" id="0044" class="graf graf--p graf-after--pre">Besically he passed two closures to produce two mock objects if you remove all buzzwords.</p><p name="1b72" id="1b72" class="graf graf--p graf-after--p">Let’s compare to this:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="90c3" id="90c3" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">func</span> <span class="hljs-title function_">testVCInitialized</span>() <span class="hljs-keyword">throws</span> {<br />  <span class="hljs-keyword">let</span> sut <span class="hljs-operator">=</span> <span class="hljs-type">ProductVC</span>()<br /><br />  sut.list <span class="hljs-operator">=</span> []<br />  sut.details <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br />  <span class="hljs-type">XCTAssertTrue</span>(sut.list.isEmpty)<br /><br />}</span></pre><p name="a5d2" id="a5d2" class="graf graf--p graf-after--pre">Then you realize the test is <strong class="markup--strong markup--p-strong">QUESTIONABLE</strong>.</p><p name="c492" id="c492" class="graf graf--p graf-after--p">Of course it will be empty. Wtf are you testing? Didn’t they cover testing in Meta?</p><p name="3a1e" id="3a1e" class="graf graf--p graf-after--p">This? You poke holes in initializers to inject dumb shit so you can test this?</p><p name="0194" id="0194" class="graf graf--p graf-after--p">You don’t need to test if initializers work if you don’t poke holes and use complex injections and extra types.</p><p name="2d18" id="2d18" class="graf graf--p graf-after--p">But, but … generics! You ignored generics! This is too QUESTIONABLE.</p><p name="6809" id="6809" class="graf graf--p graf-after--p">First you don’t even know the problem, but somehow know you need generics.</p><p name="439d" id="439d" class="graf graf--p graf-after--p">Second, we remove generics if possible.</p><p name="b44c" id="b44c" class="graf graf--p graf-after--p">Third, we can use protocol generalization like<code class="markup--code markup--p-code">AbstractEntity</code> . E.g.; <code class="markup--code markup--p-code">var list: AbstractEntity</code> . Then you can pass <code class="markup--code markup--p-code">Product</code> or else which conforms to it.</p><p name="7b00" id="7b00" class="graf graf--p graf-after--p">The point is this, we make <code class="markup--code markup--p-code">ProductVC</code> free of generics and injections, so it is easier to use. What’s the fking point to inject a generic <code class="markup--code markup--p-code">Service</code><em class="markup--em markup--p-em"> &quot;value type&quot; </em>which recursively needs to be injected with two closures that return mock data when you can just… assign mock data?</p><p name="9308" id="9308" class="graf graf--p graf-after--p">Didn’t they cover “<strong class="markup--strong markup--p-strong">Variables</strong>” in school?</p><p name="8f6a" id="8f6a" class="graf graf--p graf-after--p">His failure, is not yet complete. I know it’s hard to believe.</p><p name="8555" id="8555" class="graf graf--p graf-after--p">He showed off this &quot;<em class="markup--em markup--p-em">protocol witness</em>&quot; as a replacement over protocol.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="2f7d" id="2f7d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Discounting</span> <span class="hljs-title class_">where</span> <span class="hljs-title class_">A</span> == <span class="hljs-title class_">Product</span> {<br />  <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> oneDay: <span class="hljs-type">TimeInterval</span> { <span class="hljs-keyword">return</span> <span class="hljs-number">24</span> <span class="hljs-operator">*</span> <span class="hljs-number">3600</span> }<br />  <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> oneYear: <span class="hljs-type">TimeInterval</span> { <span class="hljs-keyword">return</span> <span class="hljs-number">365</span> <span class="hljs-operator">*</span> oneDay }<br /><br />  <span class="hljs-comment">// witness for the movie discount</span><br />  <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> movieWitness <span class="hljs-operator">=</span> <span class="hljs-keyword">Self</span> { product <span class="hljs-keyword">in</span><br />    <span class="hljs-keyword">let</span> timePassed <span class="hljs-operator">=</span> <span class="hljs-type">Date</span>().timeIntervalSince(product.releaseDate)<br /><br />        <span class="hljs-keyword">if</span> timePassed <span class="hljs-operator">&gt;</span> <span class="hljs-number">2</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">Self</span>.oneYear {<br />          <span class="hljs-keyword">return</span> <span class="hljs-number">0.5</span><br />        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> timePassed <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">Self</span>.oneYear {<br />          <span class="hljs-keyword">return</span> <span class="hljs-number">0.1</span><br />        }<br /><br />        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br />  }<br /><br />  <span class="hljs-comment">// witness for the videogame discount</span><br />  <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> videoGameWitness <span class="hljs-operator">=</span> <span class="hljs-keyword">Self</span> { product <span class="hljs-keyword">in</span><br />    <span class="hljs-keyword">let</span> timePassed <span class="hljs-operator">=</span> <span class="hljs-type">Date</span>().timeIntervalSince(product.releaseDate)<br /><br />        <span class="hljs-keyword">if</span> timePassed <span class="hljs-operator">&gt;</span> <span class="hljs-number">2</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">Self</span>.oneYear {<br />          <span class="hljs-keyword">return</span> <span class="hljs-number">0.9</span><br />        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> timePassed <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">Self</span>.oneYear {<br />          <span class="hljs-keyword">return</span> <span class="hljs-number">0.2</span><br />        }<br /><br />        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br />  }<br /><br />  <span class="hljs-comment">// witness for the book discount</span><br />  <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> bookWitness <span class="hljs-operator">=</span> <span class="hljs-keyword">Self</span> { <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> }<br />  <br />  <span class="hljs-comment">// witness for the product discount</span><br />  <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> productWitness <span class="hljs-operator">=</span> <span class="hljs-keyword">Self</span> { product <span class="hljs-keyword">in</span><br />    <span class="hljs-keyword">switch</span> product.kind {<br />    <span class="hljs-keyword">case</span> .movie:<br />      <span class="hljs-keyword">return</span> <span class="hljs-keyword">Self</span>.movieWitness.discount(product)<br />    <span class="hljs-keyword">case</span> .book:<br />      <span class="hljs-keyword">return</span> <span class="hljs-keyword">Self</span>.bookWitness.discount(product)<br />    <span class="hljs-keyword">case</span> .videogame:<br />      <span class="hljs-keyword">return</span> <span class="hljs-keyword">Self</span>.videoGameWitness.discount(product)<br />    }<br />  }<br />}</span></pre><p name="0c8d" id="0c8d" class="graf graf--p graf-after--pre">Let’s code review this. No pressure, just a Meta engineer with 4K followers.</p><ol class="postList"><li name="8684" id="8684" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">static</code></li></ol><p name="ff7e" id="ff7e" class="graf graf--p graf-after--li">Value type is meant to be disposable and everyone has its own copy. By making it <code class="markup--code markup--p-code">static</code> you introduced hidden states. Anyone can overwrite this copy. Can you try to do anything with local variables? There’s nothing here that has to be done via global variable. Yet he promoted it like a benefit.</p><p name="83d0" id="83d0" class="graf graf--p graf-after--p">2. <code class="markup--code markup--p-code">let timePassed = Date().timeIntervalSince(product.releaseDate)</code> still <strong class="markup--strong markup--p-strong">NOT REFACTORED</strong></p><p name="8b1c" id="8b1c" class="graf graf--p graf-after--p">Code duplication here. Is this too much to ask of a Meta engineer? What’s the point of all these fancy techniques if you can’t solve basic duplication?</p><p name="9d3d" id="9d3d" class="graf graf--p graf-after--p">3. <code class="markup--code markup--p-code">switch case</code> and <code class="markup--code markup--p-code">videoWitness</code> , <code class="markup--code markup--p-code">productWitness</code> , <code class="markup--code markup--p-code">movieWitness</code></p><p name="402c" id="402c" class="graf graf--p graf-after--p">He used <code class="markup--code markup--p-code">switch</code> after all. You’d assume by <code class="markup--code markup--p-code">switch</code> you don’t need to create individual types, by a technique called <strong class="markup--strong markup--p-strong">REFACTOR</strong>.</p><p name="929a" id="929a" class="graf graf--p graf-after--p">HIS OWN WORDS:</p><blockquote name="8470" id="8470" class="graf graf--blockquote graf-after--p">We have created a hierarchy that we have to handle and maintain: we have the protocols that define the products (2 types) and all the structs that implement them (other 3 types)</blockquote><p name="9249" id="9249" class="graf graf--p graf-after--blockquote">His 3 witnesses are 3 types already (that he didn’t count). Plus this nested <code class="markup--code markup--p-code">enum</code></p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="csharp" name="87be" id="87be" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> Product {<br />  <span class="hljs-built_in">enum</span> Kind {<br />    <span class="hljs-keyword">case</span> book<br />    <span class="hljs-keyword">case</span> movie<br />    <span class="hljs-keyword">case</span> videogame<br />  }<br /><br />  <span class="hljs-keyword">let</span> price: Decimal<br />  <span class="hljs-keyword">let</span> releaseDate: Date<br />  <span class="hljs-keyword">let</span> kind: Kind<br />}</span></pre><p name="5efe" id="5efe" class="graf graf--p graf-after--pre">5 types, one of which nested, 3 of which closure types like <code class="markup--code markup--p-code">Self { _ in return 0 }</code> . This is way worse. You can’t even say closure type in plain English. Did I mention they are global too?</p><p name="7c43" id="7c43" class="graf graf--p graf-after--p">He has <strong class="markup--strong markup--p-strong">FAILED </strong>everything he set out to solve. Not just regular fail.</p><p name="16f9" id="16f9" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">EPIC FAIL.</strong></p><p name="2b58" id="2b58" class="graf graf--p graf-after--p">This is the work of a Meta engineer based on ideas developed by a commercial group as its tutorial business.</p><p name="a73a" id="a73a" class="graf graf--p graf-after--p">Not one thing is done right.</p><h4 name="22c5" id="22c5" class="graf graf--h4 graf-after--p">Choose Your Tools Wisely</h4><p name="786a" id="786a" class="graf graf--p graf-after--h4">I’m going to wrap up with the exact title of how he wrapped up.</p><p name="24fa" id="24fa" class="graf graf--p graf-after--p">With exact quote too.</p><blockquote name="f4ee" id="f4ee" class="graf graf--blockquote graf-after--p">Hence, the second most important learning of this article:</blockquote><blockquote name="a2b9" id="a2b9" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong">learn your tools and when to use them.</strong></blockquote><p name="ea81" id="ea81" class="graf graf--p graf-after--blockquote">What he didn’t say is this:</p><blockquote name="045a" id="045a" class="graf graf--pullquote graf-after--p">But it’s OK if you didn’t learn shit. It’s all about marketing.</blockquote><p name="6658" id="6658" class="graf graf--p graf-after--pullquote">If you didn’t call <code class="markup--code markup--p-code">struct Service</code> dumb shit the <strong class="markup--strong markup--p-strong">SECOND </strong>you saw it, I don’t think you really learn anything.</p><p name="4896" id="4896" class="graf graf--p graf-after--p">Oh I didn’t even use any POP. I was going to demonstrate some techniques. But his work is too… let’s say it fell apart on inspection.</p><p name="a54f" id="a54f" class="graf graf--p graf-after--p">None of these matter anyway. Let me give you a visual intrepretation.</p><p name="ea0b" id="ea0b" class="graf graf--p graf-after--p">When you are in Meta:</p><figure name="237b" id="237b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*LKkDLb0wjpMzJZ0n8ByG1A.jpeg" data-width="1187" data-height="1522" src="https://cdn-images-1.medium.com/max/800/1*LKkDLb0wjpMzJZ0n8ByG1A.jpeg"></figure><p name="938e" id="938e" class="graf graf--p graf-after--figure">When you work some dead end job:</p><figure name="bc67" id="bc67" class="graf graf--figure graf-after--p graf--trailing"><img class="graf-image" data-image-id="1*Z2vNCQ3rshDq7s6qaMYRlQ.png" data-width="694" data-height="656" src="https://cdn-images-1.medium.com/max/800/1*Z2vNCQ3rshDq7s6qaMYRlQ.png"><figcaption class="imageCaption">I fight for my meals</figcaption></figure></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/7cf4f64f2015"><time class="dt-published" datetime="2023-12-06T09:14:01.783Z">December 6, 2023</time></a>.</p><p><a href="https://medium.com/@swift2931/stop-abusing-value-type-7cf4f64f2015" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>