<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>MVVM without VM with Combine</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">MVVM without VM with Combine</h1>
</header>
<section data-field="subtitle" class="p-summary">
Wait, isn’t it just MVC with Combine?
</section>
<section data-field="body" class="e-content">
<section name="6a07" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="d0f1" id="d0f1" class="graf graf--h3 graf--leading graf--title">MVVM without VM with Combine</h3><p name="0993" id="0993" class="graf graf--p graf-after--h3">Wait, isn’t it just MVC with Combine?</p><figure name="2c0f" id="2c0f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Y4CGQt7WmpQfF38vUpTxXQ.gif" data-width="500" data-height="200" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*Y4CGQt7WmpQfF38vUpTxXQ.gif"><figcaption class="imageCaption">Take a seat, MVVM</figcaption></figure><h4 name="50f7" id="50f7" class="graf graf--h4 graf-after--figure">I’m going to improve MVVM using MVC</h4><p name="66d1" id="66d1" class="graf graf--p graf-after--h4">Wait, that’s illegal.</p><p name="c41b" id="c41b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Isn’t MVVM supposed to be an improvement over MVC?</strong></p><p name="efe8" id="efe8" class="graf graf--p graf-after--p">Not from a Jedi. By Jedi I mean highly skilled iOS developer.</p><h4 name="c284" id="c284" class="graf graf--h4 graf-after--p">MVVM with Combine</h4><p name="05d1" id="05d1" class="graf graf--p graf-after--h4">There’s a <a href="http://raywenderlich.com/4161005-mvvm-with-combine-tutorial-for-ios" data-href="http://raywenderlich.com/4161005-mvvm-with-combine-tutorial-for-ios" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">tutorial</a> on raywenderlich.com, which is a popular iOS learning website. I learned quite a lot from its resources myself.</p><p name="5e4d" id="5e4d" class="graf graf--p graf-after--p">However, with SwiftUI and Combine, the cons of MVVM are exposed. And this tutorial gives an example on why you should avoid MVVM moving forward with new iOS SDK.</p><p name="26d4" id="26d4" class="graf graf--p graf-after--p">Since the tutorial is a well-made one that guides you step by step, I won’t go through nuts and bolts, but only point out where it goes wrong.</p><p name="96d9" id="96d9" class="graf graf--p graf-after--p">Junior developers are encouraged to go through the tutorial first, then reflect upon it. See if you can tell the pros and cons of this MVVM approach. Afterwards you can compare it with my approach, and make your own calls.</p><p name="ec88" id="ec88" class="graf graf--p graf-after--p">I hate to see a new generation of MVVM developers coming out of this tutorial. Let MVVM die, kill it if you have to. I feel I owe it to the world to write this article, so this evil never sees the light of day.</p><h4 name="ec3c" id="ec3c" class="graf graf--h4 graf-after--p">MVVM without VM</h4><p name="6b90" id="6b90" class="graf graf--p graf-after--h4">Here’s what I’m going to do.</p><p name="b308" id="b308" class="graf graf--p graf-after--p">I’m going to remove all ViewModels from this tutorial. If I can do the same thing without them, while having <em class="markup--em markup--p-em">clean </em>codes, then it shows that MVVM is <em class="markup--em markup--p-em">redundant.</em> Of course “clean”is subjective here, I’d leave it to readers to determine.</p><p name="3873" id="3873" class="graf graf--p graf-after--p">For those who want to jump in to codes first,</p><p name="7672" id="7672" class="graf graf--p graf-after--p"><a href="https://github.com/jimlai586/MVC" data-href="https://github.com/jimlai586/MVC" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">repo is here</strong></a></p><p name="b6ca" id="b6ca" class="graf graf--p graf-after--p">Now let’s review this tutorial.</p><figure name="a726" id="a726" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*MTiY9k7aLbSBDrXa8uIJuQ.jpeg" data-width="341" data-height="148" src="https://cdn-images-1.medium.com/max/800/1*MTiY9k7aLbSBDrXa8uIJuQ.jpeg"></figure><h4 name="09f1" id="09f1" class="graf graf--h4 graf-after--figure">struct Model: View {…}</h4><p name="a44e" id="a44e" class="graf graf--p graf-after--h4">If this doesn’t tell you that view model is built-in, I don’t know what could.</p><p name="b3d2" id="b3d2" class="graf graf--p graf-after--p">SwiftUI wants you to map model to view. You can do this before SwiftUI with some property observer setup. SwiftUI takes the next step to build SDK around it.</p><p name="bda5" id="bda5" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">last </strong>thing you want to do is to add a</p><p name="f4da" id="f4da" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">class ViewModelForModel {…}</strong></p><p name="611e" id="611e" class="graf graf--p graf-after--p">then shove it to that model.</p><p name="2639" id="2639" class="graf graf--p graf-after--p">And MVVM would have it be a reference model type instead of value type. Because it always wants to do something extra in view model to justify its overhead costs.</p><p name="7aee" id="7aee" class="graf graf--p graf-after--p">By introducing view models in SwiftUI, you are in fact re-inventing the wheel.</p><h4 name="2107" id="2107" class="graf graf--h4 graf-after--p">Where do you do control?</h4><p name="d367" id="d367" class="graf graf--p graf-after--h4">A pro first encountering SwiftUI would ask this question.</p><p name="80d3" id="80d3" class="graf graf--p graf-after--p">There’s no view controller. Model is value type hence immutable.</p><p name="6362" id="6362" class="graf graf--p graf-after--p">The answer requires a more in-depth discussion, but I can tell you now where you <strong class="markup--strong markup--p-strong">DON’T </strong>do control.</p><p name="653f" id="653f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">You don’t do it in view model.</strong></p><p name="ce72" id="ce72" class="graf graf--p graf-after--p">And that is exactly what MVVM developers would do.</p><p name="ffa7" id="ffa7" class="graf graf--p graf-after--p">When you have immutable model, and inside it a reference type view model, you would inevitably move control logic to it. Because first this tutorial does it, and MVVM does not tell you not to, and you may be inexperienced to both MVVM and SwiftUI.</p><p name="31f3" id="31f3" class="graf graf--p graf-after--p">Not to mention, networking is usually the core part of your app. It affects control, not just view. This is on top of the fact that at no point you are reducing complexity. Moving stored properties somewhere else does not reduce the work to be done, except that you now have more work of managing interactions.</p><h4 name="3e29" id="3e29" class="graf graf--h4 graf-after--p">Networking should be refactored out</h4><p name="c0bb" id="c0bb" class="graf graf--p graf-after--h4">Any developer worth their salt would put networking in dedicated library.</p><p name="a3e1" id="a3e1" class="graf graf--p graf-after--p">You don’t invoke URLSession wherever and whenever you please. All networking activities need to be managed.</p><p name="da84" id="da84" class="graf graf--p graf-after--p">True, tutorial cannot include network library dependency, nevertheless networking can still be refactored out.</p><p name="7558" id="7558" class="graf graf--p graf-after--p">You may wonder, if networking is refactored out of view model, then it’s just a simple model.</p><p name="ac15" id="ac15" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">As all things should be.</strong></p><figure name="a77b" id="a77b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*oaYGZsU3atxvr38ZzLuQ4g.jpeg" data-width="300" data-height="168" src="https://cdn-images-1.medium.com/max/800/1*oaYGZsU3atxvr38ZzLuQ4g.jpeg"></figure><h4 name="599b" id="599b" class="graf graf--h4 graf-after--figure">Implementation</h4><p name="ca92" id="ca92" class="graf graf--p graf-after--h4"><a href="https://github.com/jimlai586/MVC" data-href="https://github.com/jimlai586/MVC" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">repo is here</strong></a></p><p name="e18c" id="e18c" class="graf graf--p graf-after--p">First refactor out networking from view model.</p><p name="85d0" id="85d0" class="graf graf--p graf-after--p">A dedicated network service makes a lot of sense than a view model that does networking for you.</p><p name="8ef7" id="8ef7" class="graf graf--p graf-after--p">There are two network resources in this tutorial, with respect to two API endpoints. Refactor and put them in environment object (used as network service provider for simplicity). @EnvironmentObject is reference type by definition, and is shared between views. There’s no need to pass things around when it can be shared.</p><p name="1e8d" id="1e8d" class="graf graf--p graf-after--p">It also makes sense that this environment object takes the role of “controller”. You can tell from the variable name “store” that a Redux-based control can be done here, but I leave it out for simplicity.</p><p name="b11f" id="b11f" class="graf graf--p graf-after--p">Besides networking, view model prepares data from decoded model to be mapped to the view.</p><p name="492b" id="492b" class="graf graf--p graf-after--p">Now comes the brilliance. Your model that conforms to View can conform to Codable, and hence be used to decode json. Computed properties can be added as extension and refactored out if needed. I put it in same file since it does not affect readability, and it’s convenient to have related things in one place.</p><p name="96ed" id="96ed" class="graf graf--p graf-after--p">Sure you would not use UIView to decode json, but View is protocol in SwiftUI. You are working with model after all.</p><p name="6205" id="6205" class="graf graf--p graf-after--p">With this simplification, and a refactor of OpenWeatherAPI, you eliminate all intermediate model types including view model itself.</p><p name="46fc" id="46fc" class="graf graf--p graf-after--p">The codes are now fewer, simpler, without all the viewModel words flying around. You don’t need middle man to work with your data. Models themselves remain clean. Networking is handled by library. You also have an explicit control role.</p><p name="aa2a" id="aa2a" class="graf graf--p graf-after--p">MVC is now complete. Fewer codes, better quality. Why do you need MVVM again?</p><p name="d1c3" id="d1c3" class="graf graf--p graf-after--p">Some may argue that MVVM is scalable, its advantage would appear when things get massive.</p><p name="fdc0" id="fdc0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Oh sweet summer child</strong></p><p name="421a" id="421a" class="graf graf--p graf-after--p">MVVM is the worst at scale. It would have so many view models that your view model has view model. If any indication, look at the redundant codes produced in this simple tutorial.</p><h4 name="0bdc" id="0bdc" class="graf graf--h4 graf-after--p">The return of MVC</h4><p name="bc1d" id="bc1d" class="graf graf--p graf-after--h4">In fact, it never left.</p><p name="9e32" id="9e32" class="graf graf--p graf-after--p">In old days, MVVM requires some sort of binding mechanism, so its view model is somewhat special.</p><p name="1e5d" id="1e5d" class="graf graf--p graf-after--p">With SwiftUI, any model can serve as view model as long as it conforms to view, whereas Combine provides whatever binding you need.</p><p name="129d" id="129d" class="graf graf--p graf-after--p">SDK has decided that a simple mapping from model to view (mostly one way instead of two way binding) is all you need for a view model.</p><p name="05a6" id="05a6" class="graf graf--p graf-after--p">This is consistent with development in Swift 4. A property observer that maps model to view is all you need.</p><p name="343e" id="343e" class="graf graf--p graf-after--p">MVVM not only couples model and view, it couples with control. You need less coupling not more.</p><p name="0ac4" id="0ac4" class="graf graf--p graf-after--p">There’s no MVVM with Combine. Only MVC with fewer codes and Combine.</p><figure name="6320" id="6320" class="graf graf--figure graf-after--p graf--trailing"><img class="graf-image" data-image-id="1*bCzoCV5_EMXdh78y8F67qg.png" data-width="1280" data-height="800" src="https://cdn-images-1.medium.com/max/800/1*bCzoCV5_EMXdh78y8F67qg.png"><figcaption class="imageCaption">MVC, burning the corpse of MVVM</figcaption></figure></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/b4e0669f7077"><time class="dt-published" datetime="2019-09-29T07:08:42.011Z">September 29, 2019</time></a>.</p><p><a href="https://medium.com/@swift2931/mvvm-without-vm-with-combine-b4e0669f7077" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>