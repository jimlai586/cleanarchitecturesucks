<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Elm architecture in iOS</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Elm architecture in iOS</h1>
</header>
<section data-field="subtitle" class="p-summary">
Why you don’t need shit like RxSwift or MVVM
</section>
<section data-field="body" class="e-content">
<section name="9a8e" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="b92e" id="b92e" class="graf graf--h3 graf--leading graf--title">Elm architecture in iOS</h3><p name="4a3d" id="4a3d" class="graf graf--p graf-after--h3">Why you don’t need shit like RxSwift or MVVM</p><blockquote name="ee45" id="ee45" class="graf graf--pullquote graf-after--p">What were you the god of again?</blockquote><figure name="d1c8" id="d1c8" class="graf graf--figure graf-after--pullquote"><img class="graf-image" data-image-id="1*jfHUhT5DySDGwuYMIamkMQ.jpeg" data-width="1280" data-height="720" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*jfHUhT5DySDGwuYMIamkMQ.jpeg"><figcaption class="imageCaption">When you think you are the god of RxSwift and MVVM</figcaption></figure><h4 name="1dfb" id="1dfb" class="graf graf--h4 graf-after--figure">Let’s get shit out of the way</h4><p name="8d69" id="8d69" class="graf graf--p graf-after--h4">RxSwift is dead, MVVM is dead. Killed by Hela… I mean Swift.</p><blockquote name="87ee" id="87ee" class="graf graf--blockquote graf-after--p"><strong class="markup--strong markup--blockquote-strong">Are you Thor, god of external library, which is a direct port from the implementation of another language, that doesn’t benefit from some of the most powerful and unique Swift features?</strong></blockquote><h4 name="38ca" id="38ca" class="graf graf--h4 graf-after--blockquote">This is what you should do</h4><figure name="4939" id="4939" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*Rk8bp4NtO7kePPiAJh0_SA.jpeg" data-width="1596" data-height="798" src="https://cdn-images-1.medium.com/max/800/1*Rk8bp4NtO7kePPiAJh0_SA.jpeg"><figcaption class="imageCaption">An iOS developer improving his skill using the power of Swift (colorized)</figcaption></figure><h4 name="0dc3" id="0dc3" class="graf graf--h4 graf-after--figure">Aren’t you tired of useless shit thrown at your face?</h4><p name="9fc1" id="9fc1" class="graf graf--p graf-after--h4">Say you are beginning as an iOS developer in early 2019.</p><p name="ce87" id="ce87" class="graf graf--p graf-after--p">Your first project was a mess.</p><p name="a3d0" id="a3d0" class="graf graf--p graf-after--p">So you googled to find best practices in app architecture.</p><p name="1faf" id="1faf" class="graf graf--p graf-after--p">OK. Reactive programming. That seems promising. How should I do the reactive part? KVO? Seems weird since KVO is technically from Objective-C and I’m writing Swift but what do I know. Observable? Stream of events? Flow control? Wow, here I am thinking all I need is some kind of automatic callback mechanism. How foolish of me. It’s called FRP and it sounds cool, alright. Let me try it. Wait, complete SDK replacement? Doesn’t that mean a dependency to third-party library instead of iOS official SDK? I guess it’s that good huh? OK. Let me try a simple example. Wow, string is not just a string, it is not a stream of events, and I could bind it to an observer. MIND-BLOWN. Silly me, using property observer this whole time. Oh, what’s this disposeBag? I have to do manual memory management for every flow? Man, this FRP must be insanely good to be worthy of these overheads. Hmm, where do I add conditional logic? Let me go though all these blogs again, I must have missed something. No? I guess I need to go through documents. Where is it… nevermind, I’ll learn how to work with Observable first, hmm… wait, I have to type cast it every time? Isn’t it against static dispatch in Swift…?</p><figure name="d94e" id="d94e" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*zlwuVWACDzPJiBAkN5V0Bg.jpeg" data-width="680" data-height="536" src="https://cdn-images-1.medium.com/max/800/1*zlwuVWACDzPJiBAkN5V0Bg.jpeg"></figure><p name="18f9" id="18f9" class="graf graf--p graf-after--figure">Then you gave up. Went and watched some internet porn.</p><p name="4ed3" id="4ed3" class="graf graf--p graf-after--p">Then you came… back of course.</p><p name="a3c4" id="a3c4" class="graf graf--p graf-after--p">This time you decided to start with something lighter.</p><p name="0899" id="0899" class="graf graf--p graf-after--p">MVVM. That’s a good trick.</p><p name="aaa7" id="aaa7" class="graf graf--p graf-after--p">OK. Let’s go. Binding? Isn’t property observer… nevermind. Silly me, it must be a shit feature with untold side effects. View model as reference type? I though immutable value type is safer for model type. OK, that is because you need to add networking to view model… wait. What? Why? Uh… but my app is all about displaying networking data, if I move networking out, what should my view controller do? It would be clean now? Sure, but that’s what happens when you create a new class and do things there… I guess that’s the point? But wouldn’t view model become massive as well? Since you are still doing the same amount of work if not more accounting for overheads. Oh! Silly me, that is when you create NESTED or MORE view models and handle interactions. But… but, it looks like you just replaced one big view controller to many smaller ones… oh! Cool. That’s the point. Wait, I though you could do this using protocol extension while maintaining single responsibilty without mataining multiple smaller controllers with their own states and interactions. In fact protocol extension is not used in any meanful sense in MVVM… nevermind. It must be another shit feature with untold side effects.</p><p name="d1c1" id="d1c1" class="graf graf--p graf-after--p">OK. you finally got it. Went and watched some internet porn.</p><p name="e52e" id="e52e" class="graf graf--p graf-after--p">After you took your shot… with MVVM. You added “extensive MVVM experience” to your resume, and thinking it’s fine now. You’ve now matured as an iOS developer.</p><p name="17ab" id="17ab" class="graf graf--p graf-after--p">In the mean time, this is what you look like from my point of view.</p><figure name="b14a" id="b14a" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*qyRK63FIR6Do31cjzTUAsw.jpeg" data-width="1200" data-height="800" src="https://cdn-images-1.medium.com/max/800/1*qyRK63FIR6Do31cjzTUAsw.jpeg"><figcaption class="imageCaption">MVVM developer circa 2019</figcaption></figure><h4 name="d0db" id="d0db" class="graf graf--h4 graf-after--figure">What is the problem</h4><p name="0c5f" id="0c5f" class="graf graf--p graf-after--h4">Swift is an evolving language.</p><p name="d563" id="d563" class="graf graf--p graf-after--p">RxSwift violates static dispatch, which is the heart of Swift. This alone rules it out to be of any use in Swift development. See Combine, type is determined in compile time. I called this 3 years ago.</p><p name="7fbb" id="7fbb" class="graf graf--p graf-after--p">MVVM can be replaced by protocol extension. Because it’s implementation is well-known in other languages for many years, it’s natural to just port it to Swift. But people didn’t realize that there are better ways to do separation of concern now. In fact I’d argue MVVM is not that great for it in the first place.</p><blockquote name="64d5" id="64d5" class="graf graf--blockquote graf-after--p">Let the past die, kill it if you have to.</blockquote><p name="55e5" id="55e5" class="graf graf--p graf-after--blockquote">The last thing you want to do in 2019 is to learn either of both.</p><p name="2647" id="2647" class="graf graf--p graf-after--p">You don’t need useless shit thrown at your face. The power of Swift comes from simplicity. Its power allows you to forge a great weapon, <em class="markup--em markup--p-em">a king’s weapon</em>.</p><figure name="47d9" id="47d9" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*kNGl1gQk3v_zqtUiSd4bMw.png" data-width="952" data-height="597" src="https://cdn-images-1.medium.com/max/800/1*kNGl1gQk3v_zqtUiSd4bMw.png"><figcaption class="imageCaption">Admit it, you opened your palm</figcaption></figure><h4 name="d904" id="d904" class="graf graf--h4 graf-after--figure">Elm architecture</h4><p name="f398" id="f398" class="graf graf--p graf-after--h4">The google top result for “Elm architecture in iOS” is a medium article talking about how to use RxSwift.</p><p name="10fb" id="10fb" class="graf graf--p graf-after--p">That is the reason I write this article. Elm architecture is simple. This is Elm architecture in iOS.</p><pre name="4416" id="4416" class="graf graf--pre graf-after--p">var title: String {</pre><pre name="d98f" id="d98f" class="graf graf--pre graf-after--pre">    didSet {</pre><pre name="2d55" id="2d55" class="graf graf--pre graf-after--pre">        label.text = title<br>    }</pre><pre name="e8d3" id="e8d3" class="graf graf--pre graf-after--pre">}</pre><p name="f77a" id="f77a" class="graf graf--p graf-after--pre">Wait, isn’t it just a property observer?</p><figure name="fbd4" id="fbd4" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*J3DjybHwPuRspHb2uCUPxg.jpeg" data-width="2276" data-height="1280" src="https://cdn-images-1.medium.com/max/800/1*J3DjybHwPuRspHb2uCUPxg.jpeg"><figcaption class="imageCaption">Just a property observer</figcaption></figure><p name="fa02" id="fa02" class="graf graf--p graf-after--figure">Elm architecture can be described as follows:</p><blockquote name="2016" id="2016" class="graf graf--pullquote graf-after--p">msg -&gt; Model -&gt; View -&gt; msg</blockquote><p name="aa20" id="aa20" class="graf graf--p graf-after--pullquote">where msg is used to update model.</p><p name="4497" id="4497" class="graf graf--p graf-after--p">Compare this with above, you can see that</p><ol class="postList"><li name="faca" id="faca" class="graf graf--li graf-after--p">You can use property observer to build view as function of Model which may be a component of overall <em class="markup--em markup--li-em">State</em>.</li><li name="2e29" id="2e29" class="graf graf--li graf-after--li">You have one way binding from model to view. And that is <em class="markup--em markup--li-em">good enough </em>for most use cases. Because user interaction has side effects, hence often cannot be described by binding. Instead view processes user interaction and generates messages to update model. Side effects on view also appear as messages that update model.</li><li name="2f4c" id="2f4c" class="graf graf--li graf-after--li">Network requests produce delayed message to update model. A major design difference with MVVM. Why put networking inside model when you can keep model simple and value-typed? You may argue that networking makes view controller complex which is what motivates MVVM in the first place. But what makes your networking <em class="markup--em markup--li-em">complex</em>? If it is complex, and you move it to view model, doesn’t that make your view model complex? Have you tried making it less complex? By an ancient technique called <em class="markup--em markup--li-em">refactor</em>? What about protocol extension?</li></ol><p name="3253" id="3253" class="graf graf--p graf-after--li">Right out of the box, we have view updates as <em class="markup--em markup--p-em">reaction</em> to model changes.</p><p name="7620" id="7620" class="graf graf--p graf-after--p">FRP would dial this up to 11, and generalize it to Observable and a stream of events. But in practice you rarely need that shit. <em class="markup--em markup--p-em">If you have a hammer, everything looks like a nail. </em>How often do you do <a href="https://developer.apple.com/documentation/swiftui/gestures/composing_swiftui_gestures" data-href="https://developer.apple.com/documentation/swiftui/gestures/composing_swiftui_gestures" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">this</a>?</p><p name="0c03" id="0c03" class="graf graf--p graf-after--p">Most of the time, you just need to observe some event and a callback. You can easily do <em class="markup--em markup--p-em">functional</em> part of FRP without the full package of FRP. It’s just a function to map something to something else, and it’d be particular easy in Swift thanks to static dispatch. You’d know every type in compile time.</p><p name="d589" id="d589" class="graf graf--p graf-after--p">So in this simplest example, we already have the essences of both RxSwift and MVVM.</p><p name="a117" id="a117" class="graf graf--p graf-after--p">Now if you send all messages to a fixed place, and update model from there.</p><pre name="df37" id="df37" class="graf graf--pre graf-after--p">action(.msg) // this function updates model</pre><p name="884c" id="884c" class="graf graf--p graf-after--pre">You have <em class="markup--em markup--p-em">Redux</em>.</p><p name="a962" id="a962" class="graf graf--p graf-after--p">You don’t need external dependencies of RxSwift or ReSwift, and you do better MVVM than MVVM since you don’t need reference type model and incur minimum overheads.</p><p name="8741" id="8741" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">From a property observer.</strong></p><figure name="55db" id="55db" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*IKEbalxHMSkxKew53LjQOg.jpeg" data-width="480" data-height="360" src="https://cdn-images-1.medium.com/max/800/1*IKEbalxHMSkxKew53LjQOg.jpeg"><figcaption class="imageCaption">What were you god of again?</figcaption></figure><p name="a0b3" id="a0b3" class="graf graf--p graf-after--figure">If you’ve played with SwiftUI, you’ll notice SwiftUI <em class="markup--em markup--p-em">builds upon</em> Elm architecture.</p><pre name="0912" id="0912" class="graf graf--pre graf-after--p">struct Model: View {...}</pre><p name="aa33" id="aa33" class="graf graf--p graf-after--pre">Same model to view binding, except SwiftUI re-renders view automatically on model change for you.</p><p name="697e" id="697e" class="graf graf--p graf-after--p">Everything I’ve discussed so far still applies, while RxSwift and MVVM dies.</p><p name="cfdb" id="cfdb" class="graf graf--p graf-after--p">You can even do <a href="https://medium.com/@swift2931/redux-is-a-state-of-mind-ad4f58c032e7" data-href="https://medium.com/@swift2931/redux-is-a-state-of-mind-ad4f58c032e7" class="markup--anchor markup--p-anchor" target="_blank">cooler</a> Redux with it.</p><h4 name="0346" id="0346" class="graf graf--h4 graf-after--p">Ragnarok</h4><p name="c971" id="c971" class="graf graf--p graf-after--h4">Or as I called it, paradigm shift.</p><p name="2328" id="2328" class="graf graf--p graf-after--p">I’ve outlined the Elm architecture that is easily doable in iOS Swift. One can easily build Redux, uni-direction flow or other paradigms upon which.</p><p name="7336" id="7336" class="graf graf--p graf-after--p">But when it is combined with POP (protocol oritented programming) …</p><figure name="b43d" id="b43d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*AEjo3YhCGZ3MVZ20kYEYIQ.jpeg" data-width="640" data-height="361" src="https://cdn-images-1.medium.com/max/800/1*AEjo3YhCGZ3MVZ20kYEYIQ.jpeg"><figcaption class="imageCaption">When Elm meets POP</figcaption></figure><p name="0b30" id="0b30" class="graf graf--p graf-after--figure">I’ve only briefly touch on using protocol extension to replace MVVM. You can’t find much info on it because very few people recognize its potential.</p><p name="e2c1" id="e2c1" class="graf graf--p graf-after--p">Remember, you’ve heard from me first. Protocol extension can replace MVVM.</p><p name="6ccd" id="6ccd" class="graf graf--p graf-after--p graf--trailing">I’d leave it as an exercise for interested readers. Send me a mail if you are interested and we can discuss.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/3e6247a75250"><time class="dt-published" datetime="2019-10-24T06:25:32.866Z">October 24, 2019</time></a>.</p><p><a href="https://medium.com/@swift2931/elm-architecture-in-ios-3e6247a75250" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>