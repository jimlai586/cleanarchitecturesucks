<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>VIPER is not clean, not even close</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">VIPER is not clean, not even close</h1>
</header>
<section data-field="subtitle" class="p-summary">
Let’s destroy the anti-pattern known as VIPER
</section>
<section data-field="body" class="e-content">
<section name="531b" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="846c" id="846c" class="graf graf--h3 graf--leading graf--title">VIPER is not clean, not even close</h3><p name="9306" id="9306" class="graf graf--p graf-after--h3">Let’s destroy the anti-pattern known as VIPER</p><figure name="e760" id="e760" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*D8uf3PoJfl25VUrSQtHCXA.jpeg" data-width="1280" data-height="720" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*D8uf3PoJfl25VUrSQtHCXA.jpeg"><figcaption class="imageCaption">VIPER is not clean, it’s a boilerplate mess</figcaption></figure><h4 name="cae2" id="cae2" class="graf graf--h4 graf-after--figure">Ahh shit, here we go again</h4><p name="bf64" id="bf64" class="graf graf--p graf-after--h4">The year is 2020, and VIPER continues to spread misinformation on how it is supposed to solve massive view controller problem.</p><p name="d51b" id="d51b" class="graf graf--p graf-after--p">First, there’s no massive view controller problem. What we really have is lazy/shit developer problem that doesn’t know how to arch / refactor properly.</p><p name="c84c" id="c84c" class="graf graf--p graf-after--p">Let’s look at some of the 2020 VIPER articles to expose their hypocrisies and contradictions and that what VIPER offers is a <em class="markup--em markup--p-em">proposal </em>rather than a <em class="markup--em markup--p-em">solution</em>.</p><h4 name="c170" id="c170" class="graf graf--h4 graf-after--p">Graphite on the roof</h4><p name="697f" id="697f" class="graf graf--p graf-after--h4">This <a href="https://medium.com/swift-india/viper-architecture-example-in-ios-in-swift-4-6f656a441f7c" data-href="https://medium.com/swift-india/viper-architecture-example-in-ios-in-swift-4-6f656a441f7c" class="markup--anchor markup--p-anchor" target="_blank">article </a>summarizes the pros and cons of VIPER:</p><blockquote name="0e08" id="0e08" class="graf graf--blockquote graf-after--p">Why VIPER?</blockquote><blockquote name="e2a0" id="e2a0" class="graf graf--blockquote graf-after--blockquote">Our traditional MVC and MVM architecture that we are all acquainted with have one primary problem i.e Bulky Controllers. Since all our business logic has been dumped in the controller, in the end, we see a huge and fat controller which becomes difficult to manage if our project is to be scalable. So these are the primary reasons why we need VIPER:</blockquote><blockquote name="03f3" id="03f3" class="graf graf--blockquote graf-after--blockquote">To make the structure more modular.</blockquote><blockquote name="cfd9" id="cfd9" class="graf graf--blockquote graf-after--blockquote">To build the application on the Single Responsibility Principle.</blockquote><blockquote name="f0fe" id="f0fe" class="graf graf--blockquote graf-after--blockquote">To reduce the load and dependency on controllers.</blockquote><blockquote name="6422" id="6422" class="graf graf--blockquote graf-after--blockquote">To build the app on the basis of use cases or behavior-based.</blockquote><p name="c3bf" id="c3bf" class="graf graf--p graf-after--blockquote">On the other hand, it lists the below disadvantages:</p><blockquote name="216a" id="216a" class="graf graf--blockquote graf-after--p">Disadvantages of VIPER</blockquote><blockquote name="3aae" id="3aae" class="graf graf--blockquote graf-after--blockquote">Don’t get away with the modularity of VIPER. There are many disadvantages of VIPER as well:</blockquote><blockquote name="222c" id="222c" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong">We do have lots of code to write down.</strong></blockquote><blockquote name="2e4b" id="2e4b" class="graf graf--blockquote graf-after--blockquote">We have lots of files added to our project.</blockquote><blockquote name="c1d2" id="c1d2" class="graf graf--blockquote graf-after--blockquote">Communication between different file handlers become difficult and needs to be planned before implementation.</blockquote><blockquote name="71ee" id="71ee" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong">VIPER in small projects can be a killer, time consuming and bulgy.</strong></blockquote><p name="0a86" id="0a86" class="graf graf--p graf-after--blockquote">…</p><p name="e136" id="e136" class="graf graf--p graf-after--p">…</p><p name="a659" id="a659" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">…well then by definition VIPER is not CLEAN.</strong></p><figure name="40b2" id="40b2" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*zaxUQhaH3NyjMwDqrUJINg.jpeg" data-width="666" data-height="375" src="https://cdn-images-1.medium.com/max/800/1*zaxUQhaH3NyjMwDqrUJINg.jpeg"><figcaption class="imageCaption">VIPER mentality</figcaption></figure><p name="32e8" id="32e8" class="graf graf--p graf-after--figure">It’s insidious how VIPER devs conveniently downplays one of the most important criteria for clean code, if not the most important, then state without proof or comparison with alternatives that it provides some architectural benefits.</p><p name="ce35" id="ce35" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Anyone can propose an architecture that solves something.</strong></p><p name="739d" id="739d" class="graf graf--p graf-after--p">The problems are:</p><ol class="postList"><li name="8d95" id="8d95" class="graf graf--li graf-after--p">At what cost</li><li name="c9c5" id="c9c5" class="graf graf--li graf-after--li">Prove it</li><li name="ff2d" id="ff2d" class="graf graf--li graf-after--li">How is it better than alternatives, or SDK?</li></ol><p name="ee15" id="ee15" class="graf graf--p graf-after--li">For example, why stops at 5 roles? I propose a COBRA architecture as follows:</p><ol class="postList"><li name="53fb" id="53fb" class="graf graf--li graf-after--p">It has 100 roles, which means creating 100 extra objects manually for each view.</li><li name="ef06" id="ef06" class="graf graf--li graf-after--li">No mercy</li><li name="12e9" id="12e9" class="graf graf--li graf-after--li">COBRA Kai never dies!</li></ol><p name="0fcc" id="0fcc" class="graf graf--p graf-after--li">It solves massive view controller problem with some minor disadvantage like insane amount of codes to write down.</p><p name="ad93" id="ad93" class="graf graf--p graf-after--p">It’s of course very modular, duh. It contains every possible step you would ever encounter in app development.</p><p name="a57c" id="a57c" class="graf graf--p graf-after--p">It conforms to single responsibility principle but there are 100 responsibilities per view.</p><p name="bbdd" id="bbdd" class="graf graf--p graf-after--p">It reduces dependencies and overloads of view controller, which is now only responsible for creating 100 objects. This creates complex interactions between 100 objects, but that’s the price I’m willing to pay.</p><p name="35d7" id="35d7" class="graf graf--p graf-after--p">Not only can you build your app with use cases or behavior-based, you can also build it upside down, left side right, and/or test-driven.</p><p name="ec91" id="ec91" class="graf graf--p graf-after--p">I’ll omit the tutorial in which I create 100 objects for a hello world app. But trust me, this scales well to large projects.</p><p name="21ca" id="21ca" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Do you see the irony?</strong></p><p name="6752" id="6752" class="graf graf--p graf-after--p">Ideas are cheap, and proposals are easy, whereas implementation is hard.</p><p name="1f56" id="1f56" class="graf graf--p graf-after--p">If your implementation is not clean, your architecture has failed. And you should start over. The hardest part of SDK design is so that the rest follows naturally, and compactly without glue codes.</p><p name="db42" id="db42" class="graf graf--p graf-after--p">Or you can be shameless and slap “clean architecture” sticker on your every tutorial to establish your brand despite evidence says otherwise. This appears to be the route that VIPER takes.</p><h4 name="88c1" id="88c1" class="graf graf--h4 graf-after--p">How does an VIPER interactor explode?</h4><p name="c7a4" id="c7a4" class="graf graf--p graf-after--h4">When you create interactor (Controller in MVC sense) outside of SDK view controller hierarchy, incorporate it with presenter which inherits some of worst problems of MVVM in iOS (no binding), and add a useless router on top of it.</p><p name="348e" id="348e" class="graf graf--p graf-after--p">Why is Router useless you ask? It’s dependency injection and shit.</p><p name="724f" id="724f" class="graf graf--p graf-after--p">Because there are far easier ways to do router dependency injection without shoving a Router up your ass for every view. If VIPER devs are at all competent, this is where they should stop and rethink their design. But they are not, and we are flooded with idiotic VIPER tutorials online.</p><p name="f91b" id="f91b" class="graf graf--p graf-after--p">Take RIB, which claims to be an improvement over VIPER for example. It says “you know what, let’s not do things on view basis, e.g.; create presenter for every view, let’s do things on control basis”. Then it went on to re-create an interactor hierarchy to replace SDK view controller hierarchy, which is redundant, useless. Like that of VIPER, the most reliable way to determine the value of an architecture is to see if its <em class="markup--em markup--p-em">clean</em>. As in <em class="markup--em markup--p-em">clean </em>clean, not<em class="markup--em markup--p-em"> “you didn’t see graphite on the roof so it’s clean”</em> clean. RIB failed miserably in that aspect. But as its predecessor, RIB also claims to be a “clean architecture” that solves massive view controller problem. I mean, <em class="markup--em markup--p-em">who doesn’t?</em></p><p name="0c1c" id="0c1c" class="graf graf--p graf-after--p">Look, if there’s any universal criteria determining the <em class="markup--em markup--p-em">cleanness. </em>It’s how clean you can do a hello world<em class="markup--em markup--p-em">. </em>If you need to create 5 files for a hello world<em class="markup--em markup--p-em">, </em>you have failed, and your architecture is worthless. Don’t give me that auto-gen bullshit, you fail even harder if you require so many glue codes that it needs auto-gen. If you think an architecture that requires 5 files and glue codes and maybe auto-gen for a hello-world is easily scalable to large projects, I offer a deal to double whatever bitcoin you send to my wallet.</p><h4 name="416f" id="416f" class="graf graf--h4 graf-after--p">Cost of lies</h4><p name="9b7a" id="9b7a" class="graf graf--p graf-after--h4">There’s one thing in common between MVVM, RxSwift, and VIPER.</p><p name="81b9" id="81b9" class="graf graf--p graf-after--p">They never bother building their architecture around Swift unique language features. In fact I think they didn’t even bother mentioning any of those.</p><p name="1af1" id="1af1" class="graf graf--p graf-after--p">So you would see this funny scenario:</p><ol class="postList"><li name="997a" id="997a" class="graf graf--li graf-after--p">Move things to a external view model object</li><li name="2f32" id="2f32" class="graf graf--li graf-after--li">Create binding via observables and observers from RxSwift.</li><li name="2a37" id="2a37" class="graf graf--li graf-after--li">Depending on one’s ego, throw interactor, router, protocol, generics or other over-generalizations on top of it</li><li name="c991" id="c991" class="graf graf--li graf-after--li">Publish tutorial on how it solves massive view controller problem.</li><li name="8f6a" id="8f6a" class="graf graf--li graf-after--li">Never mention the fact that if you don’t do step 1, you can just use property observer for the same effect, omitting step 2–3.</li><li name="07e8" id="07e8" class="graf graf--li graf-after--li">Any competent devs would choose function over object then use POP to refactor out functions to keep view controller compact.</li><li name="7962" id="7962" class="graf graf--li graf-after--li">But step 6 is equivalent to following SDK, which is bad for selling tutorial. So we are back to step 1.</li></ol><p name="a8c1" id="a8c1" class="graf graf--p graf-after--li">So what is the cost of promoting these shits?</p><p name="7308" id="7308" class="graf graf--p graf-after--p">The real danger is that we no longer recognize powerful Swift language features, so we never archive the maximum efficiency the new language would provide.</p><figure name="5f9d" id="5f9d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*xqrIdbl-UU4LPQRwKIYeOA.jpeg" data-width="720" data-height="405" src="https://cdn-images-1.medium.com/max/800/1*xqrIdbl-UU4LPQRwKIYeOA.jpeg"><figcaption class="imageCaption">We no longer recognize Swift features</figcaption></figure><h4 name="b0d8" id="b0d8" class="graf graf--h4 graf-after--figure">Take a grain of boron and sand</h4><p name="7251" id="7251" class="graf graf--p graf-after--h4">To answer <a href="https://medium.com/swift-coding/the-viper-architecture-1a9dc140c505" data-href="https://medium.com/swift-coding/the-viper-architecture-1a9dc140c505" class="markup--anchor markup--p-anchor" target="_blank">this guy</a>’s title question:</p><blockquote name="eb75" id="eb75" class="graf graf--blockquote graf-after--p">The VIPER architecture</blockquote><blockquote name="d3e4" id="d3e4" class="graf graf--blockquote graf-after--blockquote">Is this the best choice for your needs?</blockquote><p name="afcc" id="afcc" class="graf graf--p graf-after--blockquote">It is NOT.</p><p name="7baa" id="7baa" class="graf graf--p graf-after--p">It is in fact the worst choice you can find. When you take boilerplate mess for granted, what other code smell should you normalize next?</p><p name="3ec6" id="3ec6" class="graf graf--p graf-after--p">If we normalize enough code smells, then we no longer recognize code smells at all.</p><p name="04d5" id="04d5" class="graf graf--p graf-after--p">Don’t take online tutorials of named architecture or design pattern at their face value. Take a grain of boron and sand. Remember that this is a new language, there’s no value type in the ages of MVVM, and there’s still no binding mechanisms in UIKit. I was told it’s an equivalent of one chest X-rays to manually create binding for every view. But it is in fact one million. You should not blindly follow online guides, and you should learn to recognize code smell. Hey, don’t even take my words for it, use your judgement.</p><p name="2c93" id="2c93" class="graf graf--p graf-after--p">Here’s a guideline I find useful: WWSD.</p><p name="1cf4" id="1cf4" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">What would SwiftUI do?</strong></p><p name="0606" id="0606" class="graf graf--p graf-after--p">See how SwiftUI does model-view mapping and binding.</p><p name="75b8" id="75b8" class="graf graf--p graf-after--p">See how SwiftUI eliminates dispose bag and Observable.</p><p name="0190" id="0190" class="graf graf--p graf-after--p">See how SwiftUI removes View Controller, do you see MVC devs cry and insist creating an external Controller object for every model?</p><p name="c76c" id="c76c" class="graf graf--p graf-after--p">See how SwiftUI builds around value type and enhances / generalize property observer.</p><p name="b608" id="b608" class="graf graf--p graf-after--p graf--trailing">Now make your own comparison between implementation of MVVM, RxSwift, VIPER with that of SwiftUI. Can you tell the difference?</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/53e9463ddef9"><time class="dt-published" datetime="2020-10-13T08:59:59.593Z">October 13, 2020</time></a>.</p><p><a href="https://medium.com/@swift2931/viper-is-not-clean-not-even-close-53e9463ddef9" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>