<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>RxSwift does not exist in this dojo, does it?</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">RxSwift does not exist in this dojo, does it?</h1>
</header>
<section data-field="subtitle" class="p-summary">
Why we should NOT use RxSwift
</section>
<section data-field="body" class="e-content">
<section name="913e" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="a460" id="a460" class="graf graf--h3 graf--leading graf--title">RxSwift does not exist in this dojo, does it?</h3><p name="6f1b" id="6f1b" class="graf graf--p graf-after--h3">Why we should NOT use RxSwift</p><figure name="bb15" id="bb15" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*t5AX9oQUcMXAR5oxzPVeXA.jpeg" data-width="300" data-height="168" src="https://cdn-images-1.medium.com/max/800/1*t5AX9oQUcMXAR5oxzPVeXA.jpeg"><figcaption class="imageCaption">No, Sensei!</figcaption></figure><h4 name="689c" id="689c" class="graf graf--h4 graf-after--figure">Strike first</h4><p name="5020" id="5020" class="graf graf--p graf-after--h4">Just watched this article: <a href="https://medium.com/@dylancfe15/why-should-we-use-rxswift-624da73b0ad2" data-href="https://medium.com/@dylancfe15/why-should-we-use-rxswift-624da73b0ad2" class="markup--anchor markup--p-anchor" target="_blank">Why should we use RxSwift</a>, in which several comparisons are made against UIKit.</p><p name="a3ef" id="a3ef" class="graf graf--p graf-after--p">This is good, because most RxSwift tutorials downplayed this part. They never bother considering SDK alternatives because of the agenda they want to push.</p><p name="994e" id="994e" class="graf graf--p graf-after--p">The problem is that, you can never find the other side of story, that is, opinions from those that write clean codes with just official SDK. So for beginners the battle seems to be one-sided, therefore think RxSwift has this huge benefits that all should embrace it.</p><p name="0cd8" id="0cd8" class="graf graf--p graf-after--p">This is why I’m writing this. Yes, there are situations where a Rx library may come handy. But in most cases, you have far simpler alternatives.</p><p name="4bf4" id="4bf4" class="graf graf--p graf-after--p">Let’s provide counter arguments to each of the comparison made in the linked article.</p><h4 name="50f6" id="50f6" class="graf graf--h4 graf-after--p">Strike hard</h4><p name="9edd" id="9edd" class="graf graf--p graf-after--h4">Without RxSwift:</p><pre name="9877" id="9877" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">var</strong> isLiked: Bool = <strong class="markup--strong markup--pre-strong">false</strong> {<br>    <strong class="markup--strong markup--pre-strong">didSet</strong> {<br>       updateUI()<br>    }<br>}</pre><p name="4422" id="4422" class="graf graf--p graf-after--pre">With RxSwift:</p><pre name="2fab" id="2fab" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">let</strong> isLiked = Variable(<strong class="markup--strong markup--pre-strong">false</strong>) isLiked.asObservable().subscribe(onNext: { <br>    updateUI() <br>})</pre><p name="dd74" id="dd74" class="graf graf--p graf-after--pre">Glad he made this comparison first. But he missed out the most important observation:</p><p name="e570" id="e570" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">It’s far simpler without RxSwift. You don’t worry about setting up external observer, subscription, onNext and shit. Use built-in property observer and be done with it.</strong></p><p name="6d52" id="6d52" class="graf graf--p graf-after--p">His argument, of course, is that when <code class="markup--code markup--p-code">updateUI()</code> gets complex, THEN RxSwift provides benefits. This is a rather huge assumption. Because most of the time, <code class="markup--code markup--p-code">updateUI()</code> or other functions triggered by property observer should be simple. So you are introducing a library that solves specifically for what? 5% or 10% of use cases? And because it extends to simpler cases, you use it for everything? This is the most common arrogance that can be observed from RxSwift devs. Remember that as an external patch-work (need black-box for lack of SDK direct support) that had the audacity to override official SDK, RxSwift comes at a complexity cost of its own. You should avoid using it on simple cases as much as possible, rather than applying it mostly on trivial cases like many RxSwift devs do.</p><p name="2e64" id="2e64" class="graf graf--p graf-after--p">As an example, let’s look at the next comparison.</p><p name="6280" id="6280" class="graf graf--p graf-after--p">Without RxSwift:</p><pre name="cd5e" id="cd5e" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">var</strong> isLiked: Bool = <strong class="markup--strong markup--pre-strong">false</strong> {<br>    <strong class="markup--strong markup--pre-strong">didSet</strong> {<br>        <strong class="markup--strong markup--pre-strong">if</strong> isLiked != oldValue {<br>            updateUI()<br>        }<br>    }<br>}</pre><p name="c701" id="c701" class="graf graf--p graf-after--pre">With RxSwift:</p><pre name="171f" id="171f" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">let</strong> isLiked = Variable(<strong class="markup--strong markup--pre-strong">false</strong>)isLiked.asObservable()<br>    .distinctUntilChanged()<br>    .subscribe(onNext: { <br>        updateUI() <br>})</pre><p name="8800" id="8800" class="graf graf--p graf-after--pre">Again, the top one is still simpler. The above, even with a condition check, is still straight-forward and maintains <code class="markup--code markup--p-code">isLike</code> as a value type.</p><p name="521f" id="521f" class="graf graf--p graf-after--p">The bottom one, on the other hand, is a boolean turned reference type <code class="markup--code markup--p-code">Variable</code> then turned as observable, then subscribed. Note that <code class="markup--code markup--p-code">isLiked</code> is a <code class="markup--code markup--p-code">let</code> ! A <code class="markup--code markup--p-code">Variable</code> as <code class="markup--code markup--p-code">let</code> !</p><p name="f746" id="f746" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Do you know why Swift introduces value type in the first place? To avoid reference type abuse such as this! A constant reference doesn’t mean immutable! This is where you know RxSwift serves to push an agenda. It does not have your best interest or language features at heart.</strong></p><h4 name="e710" id="e710" class="graf graf--h4 graf-after--p">No mercy</h4><p name="7520" id="7520" class="graf graf--p graf-after--h4">Now we are entering flow control territory. The comparisons from here on aren’t exactly fair since Rx employs highly specialized observer with built-in state machine. Look at another comparison:</p><p name="c672" id="c672" class="graf graf--p graf-after--p">Without RxSwift:</p><pre name="e851" id="e851" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">var </strong>likedCount<strong class="markup--strong markup--pre-strong"> = 0<br>var</strong> isLiked: Bool = <strong class="markup--strong markup--pre-strong">false</strong> {<br>    <strong class="markup--strong markup--pre-strong">didSet</strong> {<br>        <strong class="markup--strong markup--pre-strong">if</strong> isLiked != oldValue &amp;&amp; likedCount &lt; 5 {<br>            updateUI() <br>            likedCount += 1<br>        }<br>    }<br>}</pre><p name="7132" id="7132" class="graf graf--p graf-after--pre">With RxSwift:</p><pre name="9420" id="9420" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">let</strong> isLiked = Variable(<strong class="markup--strong markup--pre-strong">false</strong>)isLiked.asObservable()<br>    .distinctUntilChanged()<br>    .take(5)<br>    .subscribe(onNext: { <br>        updateUI() <br>})</pre><p name="1a89" id="1a89" class="graf graf--p graf-after--pre">The bottom one may seem to have advantage. Let’s do a further inspection:</p><ol class="postList"><li name="7a6f" id="7a6f" class="graf graf--li graf-after--p">It doesn’t mean state machine is eliminated. State machine is <em class="markup--em markup--li-em">hidden</em>. It is built-in to the specialized observer which monitors the flow. To deliver this form of encapsulation, some assumptions have to be made, such as infinite stream of events, and black-boxes to handle subscription and hidden state machines. Rx theory thinks this is a <em class="markup--em markup--li-em">general </em>form; Some Rx devs think this is a <em class="markup--em markup--li-em">Bible </em>form that should be applied to everything. I think both are wrong, there’s no general form for state machines and there’s nothing that can be applied to everything. Rx only handles states that are flow-related such as <code class="markup--code markup--li-code">debounce()</code>, <code class="markup--code markup--li-code">take(n)</code> , <code class="markup--code markup--li-code">distinct()</code> , <code class="markup--code markup--li-code">retry()</code> … etc.</li><li name="0e4a" id="0e4a" class="graf graf--li graf-after--li">The obvious question is then, how often do you need flow control? <br>I very rarely need it in my use cases. And if I did need it, I built custom state machines for cases that require reuse. Your mileage may vary. But this should be one of deciding factors before you jump on the RxSwift wagon.</li><li name="fe7d" id="fe7d" class="graf graf--li graf-after--li">Function chaining seems appealing. But bear in mind RxSwift requires a reference type observable wrapper to pass along the chain. A reference type means <em class="markup--em markup--li-em">state </em>in Swift. Function chaining does not require the assumption of Rx. For example Promise is a chaining design pattern long in use for networking. So given that you can use reference type, you can implement a similar chaining yourself if needed without it being tied to Rx. The real trick, however, is to pass value type along the chain. Combine seems to be able to do just that. That eliminates the intermediate Observable type in RxSwift and allows static type checking. This means you can either implement function chaining without Rx (no event, observer, subscribe… etc) or use Combine as alternatives.</li></ol><p name="2c64" id="2c64" class="graf graf--p graf-after--li">The summary is this:</p><p name="4839" id="4839" class="graf graf--p graf-after--p">Most of the time you don’t need RxSwift, because it’s either an overkill or has simpler or better alternatives. You most certainly should not use it on everything.</p><p name="8a5a" id="8a5a" class="graf graf--p graf-after--p">Oh, if you think RxSwift is handy in binding for MVVM. First MVVM is shit, second you should not do binding manually, ever, period. Those who fail to realize that are idiots and should not have any business in architecture design.</p><p name="6c3d" id="6c3d" class="graf graf--p graf-after--p">Lastly let’s consider an alternative to his final comparison:</p><p name="af4c" id="af4c" class="graf graf--p graf-after--p">Without RxSwift:</p><pre name="b41c" id="b41c" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">var </strong>likedCount<strong class="markup--strong markup--pre-strong"> = 0<br>var </strong>isLikedEnabled<strong class="markup--strong markup--pre-strong"> = true<br>var</strong> isLiked: Bool = <strong class="markup--strong markup--pre-strong">false</strong> {<br>    <strong class="markup--strong markup--pre-strong">didSet</strong> {<br>        <strong class="markup--strong markup--pre-strong">if</strong> isLiked != oldValue &amp;&amp; likedCount &lt; 5 &amp;&amp; isLikedEnabled {<br>            updateUI() <br>            likedCount += 1<br>            isLikedEnabled = false            Timer.scheduledTimer(withTimeInterval: 1000, repeats: <strong class="markup--strong markup--pre-strong">false</strong>) { _ <strong class="markup--strong markup--pre-strong">in</strong>                isLikedEnabled = <strong class="markup--strong markup--pre-strong">true<br>            </strong>}<br>        }<br>    }<br>}</pre><p name="f5a1" id="f5a1" class="graf graf--p graf-after--pre">With RxSwift:</p><pre name="62b2" id="62b2" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">let</strong> isLiked = Variable(<strong class="markup--strong markup--pre-strong">false</strong>)isLiked.asObservable()<br>    .debounce(1)   <br>    .distinctUntilChanged()<br>    .take(5)<br>    .subscribe(onNext: { <br>        updateUI() <br>})</pre><p name="265b" id="265b" class="graf graf--p graf-after--pre">Without RxSwift, but with improvement:</p><pre name="7a4f" id="7a4f" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong"><br>var</strong> isLiked = [Bool]() {<br>    <strong class="markup--strong markup--pre-strong">didSet</strong> {<br>        if isLiked.count &lt; 5 { updateUI() }<br>    }<br>}</pre><pre name="70f9" id="70f9" class="graf graf--pre graf-after--pre">// on like button pressed <br>@objc func onLiked(_ sender: Any) {<br>    // delay some time<br>    // append to isLiked if distinct<br>    // both can be easily refactored out to functions</pre><pre name="0ecd" id="0ecd" class="graf graf--pre graf-after--pre">} </pre><p name="422d" id="422d" class="graf graf--p graf-after--pre graf--trailing">I would argue that this is cleaner, and more modular. Not as effective as RxSwift functional chaining, but without dependency nor complexity. This also keep the benefits of value type and <strong class="markup--strong markup--p-strong">respects </strong>official SDK.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/9d3e51ba9a96"><time class="dt-published" datetime="2020-10-25T17:02:05.247Z">October 25, 2020</time></a>.</p><p><a href="https://medium.com/@swift2931/rxswift-does-not-exist-in-this-dojo-does-it-9d3e51ba9a96" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>