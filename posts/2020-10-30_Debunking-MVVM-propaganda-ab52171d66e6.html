<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Debunking MVVM propaganda</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Debunking MVVM propaganda</h1>
</header>
<section data-field="subtitle" class="p-summary">
An example of why MVVM sucks shit in iOS
</section>
<section data-field="body" class="e-content">
<section name="06d3" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="964f" id="964f" class="graf graf--h3 graf--leading graf--title">Debunking MVVM propaganda</h3><p name="942f" id="942f" class="graf graf--p graf-after--h3">An example of why MVVM sucks shit in iOS</p><figure name="fb3d" id="fb3d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*vEk_sVejRR9QpzHLYWbzbQ.jpeg" data-width="1280" data-height="720" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*vEk_sVejRR9QpzHLYWbzbQ.jpeg"><figcaption class="imageCaption">Avert thine eyes. This will get ugly.</figcaption></figure><h4 name="89c1" id="89c1" class="graf graf--h4 graf-after--figure">You know you suck when some MVC guy can teach you how to do MVVM</h4><p name="8346" id="8346" class="graf graf--p graf-after--h4">This is what a typical iOS MVVM tutorial would cover:</p><ol class="postList"><li name="c6ea" id="c6ea" class="graf graf--li graf-after--p">Trash Apple MVC</li><li name="99b2" id="99b2" class="graf graf--li graf-after--li">Ignore binding, or worse, try to do it manually like it’s no big deal</li><li name="5948" id="5948" class="graf graf--li graf-after--li">Build around this retarded ambiguous shit called view model, which is nether a view nor model, and can do whatever a controller can do</li><li name="185e" id="185e" class="graf graf--li graf-after--li">Write glue codes and over-generalizations to move shit out of view controller into another sink object</li><li name="3789" id="3789" class="graf graf--li graf-after--li">Claim victory and profit</li></ol><p name="bafb" id="bafb" class="graf graf--p graf-after--li">There’s one thing they will never do. That is to compare it with just regular MVC and show that there are indeed improvements of sorts.</p><p name="27e5" id="27e5" class="graf graf--p graf-after--p">And this is exactly what I would be doing here. We will be looking at this:</p><p name="25e6" id="25e6" class="graf graf--p graf-after--p"><a href="https://stevenpcurtis.medium.com/mvvm-in-swift-19ba3f87ed45" data-href="https://stevenpcurtis.medium.com/mvvm-in-swift-19ba3f87ed45" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">MVVM: A Tutorial and Practical Example in Swift</strong></a></p><p name="135e" id="135e" class="graf graf--p graf-after--p">Note that this is written by some guy with over 1K followers.</p><p name="122d" id="122d" class="graf graf--p graf-after--p">Following the playbook, his first point is:</p><blockquote name="cc72" id="cc72" class="graf graf--blockquote graf-after--p">MVC is often called Massive View Controller. Surely there is a better way?</blockquote><p name="9fa7" id="9fa7" class="graf graf--p graf-after--blockquote">Yeah, it’s called <strong class="markup--strong markup--p-strong">“REFACTOR YOUR SHIT”</strong>.</p><p name="a3c8" id="a3c8" class="graf graf--p graf-after--p">Next up, the mistake every iOS MVVM dev makes:</p><blockquote name="82a7" id="82a7" class="graf graf--blockquote graf-after--p">Data bindings distinguish MVVM from MVC and MVP by binding fields within the view model to a view — this isn’t a concern of this particular article</blockquote><p name="158a" id="158a" class="graf graf--p graf-after--blockquote"><strong class="markup--strong markup--p-strong">Dude, binding should be the most important concern for any MVVM article. Because MVVM is based on binding. If you don’t have binding, you don’t have MVVM. Nobody in their right mind does binding manually for every view regardless the means with which you create binding.</strong></p><p name="3fec" id="3fec" class="graf graf--p graf-after--p">The ironic part is that only those who failed to understand that would think MVVM in iOS is a viable approach. The discussion should stop right here, right now because iOS before SwiftUI has no binding mechanism.</p><p name="13d0" id="13d0" class="graf graf--p graf-after--p">It is a big deal creating binding manually. Because it means overheads, and for what? To trigger view update? You do know you can trigger a view update via regular function call right? Right??? E.g.; <code class="markup--code markup--p-code">updateUI()</code></p><p name="d25f" id="d25f" class="graf graf--p graf-after--p">To give view update a “reactive” flavor, hook up a property observer, e.g.;</p><p name="62b9" id="62b9" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">var model = Model() {didSet {updateUI()}}</code></p><p name="c2c7" id="c2c7" class="graf graf--p graf-after--p">This triggers view update whenever model changes. Isn’t this what you are trying to do with binding?</p><p name="73df" id="73df" class="graf graf--p graf-after--p">I don’t have view model because I don’t need a sink object to sink my shit. And because I’m perfectly capable of refactoring my shit.</p><p name="5600" id="5600" class="graf graf--p graf-after--p">Now look at this guy, because his ignorance of binding, he said he would chooses closure to create binding, but didn’t really create the said binding in his code example, and it didn’t matter because the view update is triggered by <code class="markup--code markup--p-code">updateUI()</code> .</p><p name="0ae1" id="0ae1" class="graf graf--p graf-after--p">So you have a view model without binding to anything, and its only purpose is to serve as a sink object to store an array as datasource for tableview.</p><p name="a46e" id="a46e" class="graf graf--p graf-after--p">Ladies and gentlemen. This is the skill level of a MVVM developer with more than 1K followers.</p><p name="5a7f" id="5a7f" class="graf graf--p graf-after--p">My personal favorite is this part, which shows the lack of critical thinking and form-over-substances, e.g.; use named architecture to show superiority but writes retarded mess under the shell.</p><blockquote name="00b8" id="00b8" class="graf graf--blockquote graf-after--p"><strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">var</em></strong><em class="markup--em markup--blockquote-em"> data = [BreachModel]()</em></blockquote><blockquote name="733d" id="733d" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">func</em></strong><em class="markup--em markup--blockquote-em"> tableView(</em><strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">_</em></strong><em class="markup--em markup--blockquote-em"> tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {</em></blockquote><blockquote name="07ee" id="07ee" class="graf graf--blockquote graf-after--blockquote"><em class="markup--em markup--blockquote-em">return data.count</em></blockquote><blockquote name="ea69" id="ea69" class="graf graf--blockquote graf-after--blockquote"><em class="markup--em markup--blockquote-em">}</em></blockquote><blockquote name="f07d" id="f07d" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong">However, once we have a ViewModel we can use this with the following:</strong></blockquote><blockquote name="35d6" id="35d6" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">func</em></strong><em class="markup--em markup--blockquote-em"> tableView(</em><strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">_</em></strong><em class="markup--em markup--blockquote-em"> tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {</em></blockquote><blockquote name="78e3" id="78e3" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">return</em></strong><em class="markup--em markup--blockquote-em"> breachesViewModel.breaches.count</em></blockquote><blockquote name="755b" id="755b" class="graf graf--blockquote graf-after--blockquote"><em class="markup--em markup--blockquote-em">}</em></blockquote><p name="a4da" id="a4da" class="graf graf--p graf-after--blockquote">Any devs that have more than 2 brain cells would ask:</p><p name="b79b" id="b79b" class="graf graf--p graf-after--p">Why is <code class="markup--code markup--p-code">breachesViewModel.breaches.count</code> better than <code class="markup--code markup--p-code">data.count</code> ?</p><p name="d156" id="d156" class="graf graf--p graf-after--p">In this case, <code class="markup--code markup--p-code">breachesViewModel</code> does not have binding (only implicitly via side effects, more on that later) or other shit. Its only purpose is to store <code class="markup--code markup--p-code">breaches</code> array. So in effect he is making things more difficult for no reason, and acting like this is some ingenious design pattern that <em class="markup--em markup--p-em">“solves”</em> massive view controller problem. And if you think about it, binding does nothing even if you attach them. Because given how tableview works, view update is triggered by function, namely <code class="markup--code markup--p-code">cellForRowAtIndexPath:</code> which may be triggered by <code class="markup--code markup--p-code">reloadData()</code> .</p><p name="457e" id="457e" class="graf graf--p graf-after--p">In a sense, <code class="markup--code markup--p-code">cellForRowAtIndexPath:</code> is where you describe <em class="markup--em markup--p-em">binding </em>(one way) from datasource to cell. So the fact that this dude chose tableview to do an example of MVVM shows how little he understood UIKit. Let’s recall what he said:</p><blockquote name="e014" id="e014" class="graf graf--blockquote graf-after--p">this isn’t a concern of this particular article</blockquote><p name="b9f6" id="b9f6" class="graf graf--p graf-after--blockquote"><strong class="markup--strong markup--p-strong">That… is why you fail.</strong></p><figure name="e216" id="e216" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*PqwZZ1112A4FaHD8rK-vHQ.jpeg" data-width="366" data-height="300" src="https://cdn-images-1.medium.com/max/800/1*PqwZZ1112A4FaHD8rK-vHQ.jpeg"></figure><p name="e78d" id="e78d" class="graf graf--p graf-after--figure">In fact this is exactly why whoever builds view model for tableviewcell is retarded. I don’t know why this is so hard to understand. When porting a design pattern, you need to consider underlying SDK and language features.</p><p name="e6f7" id="e6f7" class="graf graf--p graf-after--p">Without binding, his tutorial is a retarded way to update tableview from a fetch; with binding, his tutorial is a more retarded way to update tableview from a fetch because binding just interferes with SDK.</p><p name="6542" id="6542" class="graf graf--p graf-after--p">OK. Obviously you would argue that this is just a trivial example. With binding attached and model becoming more complex, MVVM would become good right?</p><p name="c912" id="c912" class="graf graf--p graf-after--p">Wrong. Value type and property observer provides far simpler alternatives. MVC-based SDK also prohibits the MVVM usage as shown above. If you pay attention, MVVM in iOS always ended up doing things more complex than it needed to be. What makes you think something that doesn’t work in trivial examples is easily scalable to large projects?</p><p name="8a8d" id="8a8d" class="graf graf--p graf-after--p">Let’s add icing on the cake by code reviewing his <a href="https://github.com/stevencurtis/SimpleMVVMNetwork/blob/master/SimpleMVVMNetwork/BreachesViewController.swift" data-href="https://github.com/stevencurtis/SimpleMVVMNetwork/blob/master/SimpleMVVMNetwork/BreachesViewController.swift" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">tutorial</a>.</p><h4 name="d7d8" id="d7d8" class="graf graf--h4 graf-after--p">Code Review</h4><p name="dd2b" id="dd2b" class="graf graf--p graf-after--h4">1. Avoid auto-layout codes in <code class="markup--code markup--p-code">viewDidLoad</code></p><p name="125d" id="125d" class="graf graf--p graf-after--p">Dude, you serious? Decouple view from view controller man. Recall that</p><blockquote name="64bc" id="64bc" class="graf graf--blockquote graf-after--p">MVC is often called Massive View Controller. Surely there is a better way?</blockquote><p name="4786" id="4786" class="graf graf--p graf-after--blockquote">Well, maybe it’s because you put layout code in view controller!!!</p><p name="0648" id="0648" class="graf graf--p graf-after--p">2. Refactor your networking</p><p name="ac33" id="ac33" class="graf graf--p graf-after--p">I’ll show my <em class="markup--em markup--p-em">“massive view controller”</em> version of networking as follows:</p><pre name="8d85" id="8d85" class="graf graf--pre graf-after--p">var json = JSON() {didSet {updateUI()}}</pre><pre name="0d64" id="0d64" class="graf graf--pre graf-after--pre">var endpoint = Resource(&quot;URL&quot;)</pre><pre name="bcd6" id="bcd6" class="graf graf--pre graf-after--pre">//...<br>//endpoint.get().onSuccess {json in self.data = json}</pre><p name="78c8" id="78c8" class="graf graf--p graf-after--pre">I’d argue that most MVVM devs don’t use MVVM for binding, they use it because they don’t know how to refactor networking. Therefore in order to make view controller look clean, they have to move massive fetch call somewhere else. Think about it, you can rename view model to FetchHandler and the code would make a lot more sense. Look at his view model, 3/4 of which is just fetch codes. Again:</p><blockquote name="2e7c" id="2e7c" class="graf graf--blockquote graf-after--p">MVC is often called Massive View Controller. Surely there is a better way?</blockquote><p name="d3d0" id="d3d0" class="graf graf--p graf-after--blockquote">Yeah, it’s called <strong class="markup--strong markup--p-strong">“REFACTOR YOUR SHIT”</strong>.</p><p name="b968" id="b968" class="graf graf--p graf-after--p">3. <em class="markup--em markup--p-em">“Binding”</em> via side effects</p><p name="e703" id="e703" class="graf graf--p graf-after--p">If you ask 10 MVVM devs how they should do binding in iOS, (this is a trick question, because no one should do binding manually) you would get 11 answers.</p><p name="2155" id="2155" class="graf graf--p graf-after--p">You can often find the most retarded invention from MVVM implementations, e.g.; nested view models.</p><p name="9e7c" id="9e7c" class="graf graf--p graf-after--p">Here we have another prime example. Something that has to be seen to believe.</p><p name="e945" id="e945" class="graf graf--p graf-after--p">Usually a “binding” via closure is like the following:</p><pre name="2344" id="2344" class="graf graf--pre graf-after--p">vm.event.onChange { self in ... }<br>vm.action = { self in ... }</pre><p name="dd39" id="dd39" class="graf graf--p graf-after--pre">This guy went far and beyond.</p><p name="408f" id="408f" class="graf graf--p graf-after--p">He used a view model that is neither a view nor model to do a network fetch that implicitly captures view controller in its callback function which in turn calls <code class="markup--code markup--p-code">updateUI()</code> .</p><p name="6dd4" id="6dd4" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Who’s the Control here in MVC terms? The view model, which may as well be named Controller. Because this is just standard fetch-update flow in Apple MVC. So what exactly does MVVM solve?</strong></p><p name="d539" id="d539" class="graf graf--p graf-after--p">The dude went around a big circle just so he could do things the old MVC way. This is what you get from ignorance such as this:</p><blockquote name="14f7" id="14f7" class="graf graf--blockquote graf-after--p">this isn’t a concern of this particular article</blockquote><p name="3218" id="3218" class="graf graf--p graf-after--blockquote"><strong class="markup--strong markup--p-strong">In the end, this is equivalent to a poor networking refactor in the disguise of view model. If you call it a FetchHandler, then all makes sense and you will realize it’s just MVC with extra steps.</strong></p><h4 name="6750" id="6750" class="graf graf--h4 graf-after--p">Conclusion</h4><p name="8c01" id="8c01" class="graf graf--p graf-after--h4">We can make a ranking of developers based on above discussion:</p><ol class="postList"><li name="66f7" id="66f7" class="graf graf--li graf-after--p">OK tier</li></ol><p name="23ca" id="23ca" class="graf graf--p graf-after--li">Those who refuse to do manual binding in iOS.</p><p name="bccb" id="bccb" class="graf graf--p graf-after--p">2. Junior tier</p><p name="2cda" id="2cda" class="graf graf--p graf-after--p">Those who decide to do manual binding in iOS.</p><p name="b366" id="b366" class="graf graf--p graf-after--p">3. MVVM influencer tier</p><p name="fad9" id="fad9" class="graf graf--p graf-after--p graf--trailing">Those who decide to do manual binding in iOS, don’t have basic understanding of MVC or refactoring skills, push agenda regardless SDK, language, naming, ambiguity to sell tutorials.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/ab52171d66e6"><time class="dt-published" datetime="2020-10-30T11:18:20.358Z">October 30, 2020</time></a>.</p><p><a href="https://medium.com/@swift2931/debunking-mvvm-propaganda-ab52171d66e6" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>