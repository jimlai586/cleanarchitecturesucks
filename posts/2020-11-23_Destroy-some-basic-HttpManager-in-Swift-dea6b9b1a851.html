<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Destroy some basic HttpManager in Swift</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Destroy some basic HttpManager in Swift</h1>
</header>
<section data-field="subtitle" class="p-summary">
You know their codes are shit when the only technical argument a dev can make is to block you
</section>
<section data-field="body" class="e-content">
<section name="a1cf" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="4672" id="4672" class="graf graf--h3 graf--leading graf--title">Destroy some basic HttpManager in Swift</h3><p name="d807" id="d807" class="graf graf--p graf-after--h3">You know their codes are shit when the only technical argument a dev can make is to block you</p><figure name="dde7" id="dde7" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*gy7G0JqbgcBcYjwNT1YvVA.jpeg" data-width="600" data-height="255" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*gy7G0JqbgcBcYjwNT1YvVA.jpeg"></figure><h4 name="50c6" id="50c6" class="graf graf--h4 graf-after--figure">For a guy with 1.1K followers, this guy sure is thin-skinned</h4><p name="f5d7" id="f5d7" class="graf graf--p graf-after--h4">I asked some legit questions in this article: <a href="https://medium.com/better-programming/my-basic-httpmanager-in-swift-db2be1e340c2" data-href="https://medium.com/better-programming/my-basic-httpmanager-in-swift-db2be1e340c2" class="markup--anchor markup--p-anchor" target="_blank">My basic HttpManager in Swift</a></p><p name="d20f" id="d20f" class="graf graf--p graf-after--p">In which the dude claims to make network requests even easier. Instead of answering it like you would in a code review, the dude just blocked me.</p><p name="2bc9" id="2bc9" class="graf graf--p graf-after--p">If there’s anything predicable from a MVVM influencer, you can count on his weak understanding of Swift, lack of respect towards official SDK, and overall poor coding skill.</p><p name="3b6b" id="3b6b" class="graf graf--p graf-after--p">This showcases just that.</p><p name="e8ad" id="e8ad" class="graf graf--p graf-after--p">The common trait of MVVM devs is that they can’t refactor for shit. Before going into hoops and loops of MVVM, you need only observe how they do networking.</p><h4 name="1da7" id="1da7" class="graf graf--h4 graf-after--p">Making network requests even harder</h4><p name="09b7" id="09b7" class="graf graf--p graf-after--h4">Let’s analyze the problem and his approach first.</p><p name="dd77" id="dd77" class="graf graf--p graf-after--p">He wants to build a network manager as a wrapper to URLSession, and he wants mocking capabilities.</p><p name="6c53" id="6c53" class="graf graf--p graf-after--p">His approach is to protocolize URLSession, extracting its common functions like <code class="markup--code markup--p-code">resume</code> , <code class="markup--code markup--p-code">dataTask(...)</code> . Then whoever conforms to this protocol can be used like URLSession.</p><p name="b5f6" id="b5f6" class="graf graf--p graf-after--p">This is not the best idea. Since you have a manager wrapper, and you invoke networking calls, e.g.; <code class="markup--code markup--p-code">get</code> , <code class="markup--code markup--p-code">post</code> via manager, it would be easier to do mocking at manager level. This way you are not restricted by URLSession API. For example <code class="markup--code markup--p-code">resume</code> is state control rather than data source, you shouldn’t need to worry about this in mocking. Every time you create a protocol object, you need to implement <code class="markup--code markup--p-code">resume</code> , which requires understanding of when this would be called during an URLSession. Not to mention it has nothing to do with providing mock data. This is the kind of useless redundancy commonly seen among MVVM devs.</p><p name="186c" id="186c" class="graf graf--p graf-after--p">A better way is to do it at manager level. First, you have total control over it, and it can hide session details. A possible API may look like this:</p><p name="bc8d" id="bc8d" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">manager.get(url, params).onSuccess {json in ...}.onFailure {...}</code></p><p name="3b43" id="3b43" class="graf graf--p graf-after--p">You may argue that why hides URLSession? What if I need to setup a different configuration?</p><p name="1201" id="1201" class="graf graf--p graf-after--p">A design choice aimed to speed up the most frequently used process.</p><p name="61e5" id="61e5" class="graf graf--p graf-after--p">MVVM devs love to pass everything as parameter and call it “modular”. In my projects, one never needs another configuration. URLSession.shared is all I need. And since we are not decoupling URLSession from mocking, we can leave it intact.</p><p name="9a04" id="9a04" class="graf graf--p graf-after--p">Even if we were to support URLSession config capabilities, we can still choose to have a <code class="markup--code markup--p-code">config</code> function instead of mandatory initializer parameter.</p><p name="07fa" id="07fa" class="graf graf--p graf-after--p">Let’s now compare to our beloved MVVM influencer:</p><pre name="c580" id="c580" class="graf graf--pre graf-after--p">func downloadData&lt;T: HTTPManagerProtocol&gt;(_ httpManager: T, completion: @escaping (Result&lt;Data, Error&gt;) -&gt; Void) {        <br>    if let url = URL(string: &quot;url&quot;) {<br>        httpManager.get(url: url, completionBlock: {data in<br>            completion(data)            <br>        })        <br>    }    <br>}</pre><p name="cc9a" id="cc9a" class="graf graf--p graf-after--pre">…</p><p name="9a5a" id="9a5a" class="graf graf--p graf-after--p">It should be immediately obvious that this function should be refactored into <code class="markup--code markup--p-code">httpManager</code> . E.g.; <code class="markup--code markup--p-code">httpManager.downloadData(...).onSuccess(...)</code></p><p name="1ac6" id="1ac6" class="graf graf--p graf-after--p">Otherwise what are you going to do when another view controller needs to download data? Copy this function over?</p><p name="ed6c" id="ed6c" class="graf graf--p graf-after--p">And if you were to use generic, a better usage is to apply it to infer the data type coming out of the <code class="markup--code markup--p-code">dataTask</code> . This way you can refactor out data parsing.</p><p name="4da1" id="4da1" class="graf graf--p graf-after--p">You also want to coalesce optional unwrapping, e.g.; <code class="markup--code markup--p-code">session?</code> , <code class="markup--code markup--p-code">url?</code> in once place. Because it would be routine, and most of the time they have the same error handling. User doesn’t care if your session object is nil. An unexpected network failure shall suffice most of the time.</p><p name="d325" id="d325" class="graf graf--p graf-after--p">An API design like this should tell you the code quality that you can expect from the rest of the implementation. They have to promote MVVM, otherwise they would be obliterated in MVC. A refactor skill like this cannot survive MVC. It’s funny he just straight-up blocked me when I simply code-reviewed him. This tells me that either he cannot survive code review, or there are just too few competent iOS developers.</p><p name="24fb" id="24fb" class="graf graf--p graf-after--p">Let’s code review his implementation shall we?</p><h4 name="1c1d" id="1c1d" class="graf graf--h4 graf-after--p">Inefficient Protocol Design</h4><pre name="412f" id="412f" class="graf graf--pre graf-after--h4">protocol URLSessionProtocol {    <br>    associatedtype dataTaskProtocolType: URLSessionDataTaskProtocol<br>    func dataTask(with url: URL, completionHandler: @escaping<br>       (Data?, URLResponse?, Error?) -&gt; Void) -&gt; <br>        dataTaskProtocolType        <br>    func dataTask(with request: URLRequest, completionHandler:<br>        @escaping (Data?, URLResponse?, Error?) -&gt; Void) -&gt;<br>        dataTaskProtocolType}</pre><p name="4145" id="4145" class="graf graf--p graf-after--pre">Since he chose to couple mocking with URLSession, he had to abstract away URLSession to protocol. One mistake would often lead to another mistake.</p><p name="5224" id="5224" class="graf graf--p graf-after--p">This is usually where you stop and re-evaluate your design. Because from the looks of it, the preparation could be messy once it involves an associatetype of another protocol type. But since MVVM devs accept manual binding and escaping closure as perfectly normal procedures, you would expect them to just brute-force it, and claim victory without proof.</p><p name="8463" id="8463" class="graf graf--p graf-after--p">On the other hand, his manager protocol looks like this:</p><pre name="d3c9" id="d3c9" class="graf graf--pre graf-after--p">protocol HTTPManagerProtocol {    <br>    associatedtype aType    <br>    var session: aType { get }       <br>    init(session: aType)        <br>    func get(url: URL, completionBlock: @escaping (Result&lt;Data,<br>        Error&gt;) -&gt; Void)<br>}</pre><p name="c90b" id="c90b" class="graf graf--p graf-after--pre">Let’s appreciate this.</p><p name="3ba3" id="3ba3" class="graf graf--p graf-after--p">HTTPManagerProtocol is generic on session type, which is generic on protocol type that is the return type of <code class="markup--code markup--p-code">dataTask</code> .</p><p name="2d8c" id="2d8c" class="graf graf--p graf-after--p">Imagine you are his coworker and you start tracing from this protocol.</p><p name="a553" id="a553" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Dude wtf.</strong></p><p name="7de7" id="7de7" class="graf graf--p graf-after--p">There are some improvements that can be made.</p><p name="c191" id="c191" class="graf graf--p graf-after--p">Right off the bat, it should be class protocol. There’s no way a value type can be HttpManager. Let compiler help you by adding restrictions.</p><p name="a8ff" id="a8ff" class="graf graf--p graf-after--p">As mentioned I would use manager to do mocking instead of URLSession, this removes 3 requirements as well associatedtype.</p><p name="0aac" id="0aac" class="graf graf--p graf-after--p">I would further simply <code class="markup--code markup--p-code">Result&lt;Data, Error&gt;</code> , because the handling of which would be routine and can be refactored out. Just get a JSON, and invoke <code class="markup--code markup--p-code">onFailure</code> otherwise. I would remove <code class="markup--code markup--p-code">url</code> parameter as well, but this would require a resource-based rather than a request-based approach so is not covered here.</p><p name="b445" id="b445" class="graf graf--p graf-after--p">What’s the next step from here?</p><p name="a04c" id="a04c" class="graf graf--p graf-after--p">If you are half competent with POP. You should now attempt to implement this protocol in <em class="markup--em markup--p-em">extension</em>. As predicted, our MVVM influencer did the exact opposite:</p><pre name="3205" id="3205" class="graf graf--pre graf-after--p">extension HTTPManager : HTTPManagerProtocol {}</pre><p name="b914" id="b914" class="graf graf--p graf-after--pre">It may seem to be a minor difference. But if you want to kill inheritance, e.g.; <code class="markup--code markup--p-code">final</code> of HttpManager, default implementation becomes important.</p><p name="ffcf" id="ffcf" class="graf graf--p graf-after--p">A rule of thumb is to avoid inheriting things with explicit control state. This comes from experience. You may also want to drop blend protocol naming like <code class="markup--code markup--p-code">HTTPManagerProtocol</code> which is useless, of course it’s a protocol, tell me something I don’t know.</p><p name="acea" id="acea" class="graf graf--p graf-after--p">Last but not least, what a beautiful usage of <code class="markup--code markup--p-code">URLSessionDataTaskProtocol</code></p><pre name="ba43" id="ba43" class="graf graf--pre graf-after--p">protocol URLSessionDataTaskProtocol {    func resume()}</pre><p name="82f4" id="82f4" class="graf graf--p graf-after--pre">You have to give it to this guy.</p><p name="6b68" id="6b68" class="graf graf--p graf-after--p">Naming is both long and pointless. Protocol requires something irrelevant to mock data source. This useless piece of shit causes the requirement of nested associatedtype. You can’t have default implementation in this case, and you need to retroactively make URLSession conform to it.</p><p name="4d46" id="4d46" class="graf graf--p graf-after--p">What a worthless piece of shit.</p><p name="53b0" id="53b0" class="graf graf--p graf-after--p">Let’s recall the immortal claim of its designer:</p><p name="ac7c" id="ac7c" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Making network requests even easier</strong></p><p name="437c" id="437c" class="graf graf--p graf-after--p">Just like every other claim MVVM devs make, false, misleading, shity implementation.</p><h4 name="f152" id="f152" class="graf graf--h4 graf-after--p">Icing on top</h4><p name="9392" id="9392" class="graf graf--p graf-after--h4">This is part of his test of view controller:</p><pre name="b219" id="b219" class="graf graf--pre graf-after--p">let urlSession = URLSessionMock()</pre><pre name="fc68" id="fc68" class="graf graf--pre graf-after--pre">//...</pre><pre name="46c8" id="46c8" class="graf graf--pre graf-after--pre">httpManager = HTTPManagerMock(session: urlSession)</pre><pre name="69c3" id="69c3" class="graf graf--pre graf-after--pre">viewController.downloadData( httpManager!, ...)</pre><p name="bc3f" id="bc3f" class="graf graf--p graf-after--pre">First you should need to worry about optional when working with HTTPManagerMock. It’s fake shit man, how do you fail at creating fake shit.</p><p name="b9be" id="b9be" class="graf graf--p graf-after--p">Force unwrap just wastes your time. You still need to do it for every test.</p><p name="080c" id="080c" class="graf graf--p graf-after--p">Now, do you notice he is actually testing HTTPManagerMock / URLSesisonMock instead of HTTPManager / URLSession.shared?</p><p name="ab46" id="ab46" class="graf graf--p graf-after--p">It basically goes through an entirely different network path from that in production code. And in doing so, you need to pass in extra parameter in <code class="markup--code markup--p-code">downloadData</code> when in fact you probably would only need one singleton manager instance throughout. Over-generalization, extra overheads, false promises, poor refactors. Bad design. Signatures of a true MVVM dev.</p><p name="4396" id="4396" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">And this guy, having 1.1K followers, blocked me straight-up when being code-reviewed.</strong></p><p name="7920" id="7920" class="graf graf--p graf-after--p graf--trailing">If he were the leading guy in MVVM in iOS, what does that tell you about MVVM?</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/dea6b9b1a851"><time class="dt-published" datetime="2020-11-23T10:45:07.862Z">November 23, 2020</time></a>.</p><p><a href="https://medium.com/@swift2931/destroy-some-basic-httpmanager-in-swift-dea6b9b1a851" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>