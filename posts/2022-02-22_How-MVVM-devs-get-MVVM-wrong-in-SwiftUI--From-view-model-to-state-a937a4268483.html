<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>How MVVM devs get MVVM wrong in SwiftUI: From view model to state</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">How MVVM devs get MVVM wrong in SwiftUI: From view model to state</h1>
</header>
<section data-field="subtitle" class="p-summary">
This is going to be a hot take to explain why I think view model is obsolete in SwiftUI and can be replaced by state management.
</section>
<section data-field="body" class="e-content">
<section name="7315" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="c8a5" id="c8a5" class="graf graf--h3 graf--leading graf--title">How MVVM devs get MVVM wrong in SwiftUI: From view model to state</h3><figure name="9d77" id="9d77" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*VNs256FdtdwIB0lQPdufIQ.jpeg" data-width="2560" data-height="1440" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*VNs256FdtdwIB0lQPdufIQ.jpeg"><figcaption class="imageCaption">Do you really know MVVM?</figcaption></figure><p name="e306" id="e306" class="graf graf--p graf-after--figure">This is going to be a hot take to explain why I think view model is obsolete in SwiftUI and can be replaced by state management.</p><p name="b526" id="b526" class="graf graf--p graf-after--p">If you feel legacy MVVM pattern in SwiftUI is awkward or not that useful when implementing, that is because MVVM devs never bother to adapt design pattern to language features. Never write design pattern for the sake of writing design pattern.</p><h4 name="3360" id="3360" class="graf graf--h4 graf-after--p">Let’s start with a typical usage.</h4><pre name="d83f" id="d83f" class="graf graf--pre graf-after--h4">class ViewModel: ObservableObject {<br>    <a href="http://twitter.com/Published" data-href="http://twitter.com/Published" class="markup--anchor markup--pre-anchor" title="Twitter profile for @Published" rel="noopener" target="_blank">@Published</a> var data = Data()<br>} <br>struct Model: View {<br>    <a href="http://twitter.com/StateObject" data-href="http://twitter.com/StateObject" class="markup--anchor markup--pre-anchor" title="Twitter profile for @StateObject" rel="noopener" target="_blank">@StateObject</a> var vm = ViewModel()<br>}</pre><h4 name="7874" id="7874" class="graf graf--h4 graf-after--pre">Q1: Where is the “model” in terms of MVVM?</h4><p name="55a1" id="55a1" class="graf graf--p graf-after--h4"><a href="https://matteomanferdini.com/mvvm-pattern-ios-swift/" data-href="https://matteomanferdini.com/mvvm-pattern-ios-swift/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Conventional MVVM wisdom</a> will tell you that “Data” is the model type, whereas “Model” is the view and fancy marketing terms like “vm decouples view from model”.</p><p name="a1d1" id="a1d1" class="graf graf--p graf-after--p">None of these is true.</p><p name="2ac0" id="2ac0" class="graf graf--p graf-after--p">Like the name suggests, “Model” is the model type. It conforms to View, it is used to render view, but it is NOT View. What happens is vm holding a part of the model that will be used to render view. It doesn’t decouple shit. It is part of the view via binding.</p><p name="f66c" id="f66c" class="graf graf--p graf-after--p">As another example, let’s look at the claim of “Views should be independent of model types”. It sounds good on paper, but the point of data-view binding is to be able to create view from some data type…so what does that even mean in terms of SwiftUI implementation?</p><p name="a209" id="a209" class="graf graf--p graf-after--p">There’s no decoupling shit in the middle of “Binding”. To bind is to pull things together. In UIKit this may make sense, because usually vm itself is the binding process outside of controller. But in this case vm is in the middle of the binding. This brings up the next question.</p><h4 name="d763" id="d763" class="graf graf--h4 graf-after--p">Q2: Where is the binding taking place?</h4><p name="0c66" id="0c66" class="graf graf--p graf-after--h4">Conventional MVVM wisdom will tell you binding occurs by creating a class conforming to “ObservableObject”.</p><p name="7775" id="7775" class="graf graf--p graf-after--p">No, data-view binding occurs at the model type, in this case “Model” instead of “Data”. What “ViewModel” class does is observing “data” and publish events to trigger re-rendering of view.</p><p name="be5b" id="be5b" class="graf graf--p graf-after--p">This vm object only holds partial data for rendering, it cannot render the view by itself. It notifies changes. The binding is described by the “var body” in “Model” which is why it must conform to View. That is why Model conforms to View and ViewModel conforms to ObservableObject and needs ObservedObject annotation.</p><p name="08f6" id="08f6" class="graf graf--p graf-after--p">Also the conformation to ObservableObject is not exclusive. You can name it RequestHandler and nothing would’ve changed. And it will be functionally-equivalent to the so called ViewModel. In fact it makes a lot more sense since most of the view models are just network request handler. What if I told you that you are just doing MVC with extra steps or a rename all this time?</p><p name="8eb6" id="8eb6" class="graf graf--p graf-after--p">So what is it that MVVM actually brings to the table? What is the value of adding a mandatory view model for every view? Whatever you can do to a view model like unit testing, you can do it to a request handler. Legacy MVVM needs a separate view model to handle binding, but that requirement is gone in SwiftUI. Yes there are still guidelines on view logic separation of concerns. Let’s examine how SwiftUI tackle this.</p><h4 name="687e" id="687e" class="graf graf--h4 graf-after--p">Q3: What’s the scope of State and StateObject?</h4><p name="7ed1" id="7ed1" class="graf graf--p graf-after--h4">They are local. Other parts of view hierarchy can’t access it. They represent the state of a particular view. Model is value type, which is immutable, therefore for it to have state (in terms of rendering view) you need to mark it explicitly and conform to appropriate protocols which can be checked by compiler. It has protection of static-time check and access protection.</p><p name="e852" id="e852" class="graf graf--p graf-after--p">These state annotations take place inside of Model that conforms to View so there’s no ambiguity that it refers to View states. So calling it ViewModel is comparatively ambiguous, redundant, misleading. E.g.; what is ViewModel? It’s not a view, it acts like view controller that handles view logic but it also contains data model and devs often pass it around like value type when it actually contains side effects. Not even MVVM devs can agree on what it should do. For some MVVM devs, context is irrelevant. They can make a view model out of vacuum and make another view model inside that view model. 99% of the MVVM tutorials doesn’t mention value type and how it might affect design pattern. I’m here to convince you, it affects a lot.</p><p name="0eaa" id="0eaa" class="graf graf--p graf-after--p">So from context, we can easily identify view states. If there is business logic that is not related to View, then your view won’t observe it.<br>Separation of concern, enforced by SDK design, with an emphasis on value type, without you even realizing.</p><p name="ba6c" id="ba6c" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">That, is SDK design.</strong></p><p name="4f2e" id="4f2e" class="graf graf--p graf-after--p">In the context of Swift, if you are using reference type object, I know you are up to something in terms of state changes and side effects. Because otherwise you should have no problem using value type if your intentions are as pure as you claim.</p><p name="5074" id="5074" class="graf graf--p graf-after--p">In practice you will want to reduce the number and complexity of states in your Model: View, which can be easily observed in code review.</p><p name="15b2" id="15b2" class="graf graf--p graf-after--p">Now look at what MVVM wants you to do in SwiftUI: creating a mandatory reference type object for a narrower scope of view state management. It’s just a special case of normal SDK usage. Again, what is it that MVVM brings to the table that SDK doesn’t already have?</p><h4 name="cddf" id="cddf" class="graf graf--h4 graf-after--p">Q4: What is beyond view model?</h4><p name="12fb" id="12fb" class="graf graf--p graf-after--h4">First try to accept that MVVM may have flaws. It is not some godly bulletproof unambiguous design pattern. Quite the contrary in fact. You know what the first thing VIPER does to improve upon MVVM? By adding an “interactor”, i.e.; a controller, i.e.; state manager.</p><p name="b898" id="b898" class="graf graf--p graf-after--p">With SwiftUI, what MVVM preaches is automatic in a more generalized way. Ironically, of all people, MVVM devs don’t seem to recognize this. (or I may be completely wrong)</p><p name="04e0" id="04e0" class="graf graf--p graf-after--p">I’ve seen posts asking whether you should put business logic in model or view model. What if I told you sometimes view logic is business logic?</p><p name="613d" id="613d" class="graf graf--p graf-after--p">If we put this in the context of SwiftUI, we could generalize this concept to “local state” vs “shared state”, which can be identified by StateObject vs EnvrionmentObject or other shared observables. Devs can easily determine whether something should be shared across view hierarchy or not.<br>Also there are alternatives to refactor control logic than creating handler or sink objects. MVVM remains in the age of “I need a dedicated reference type object to handle logic”. You don’t. Protocol extensions and computed properties simplifies codes a lot, even static functions will do.</p><p name="952c" id="952c" class="graf graf--p graf-after--p">For example, your view logic is often just JSON processing without side effects. You can create a sink object a.k.a request handler a.k.a view model to do it, or you can use dedicated network lib to get a JSON and pass it through pre-defined processing functions as protocol extension. Not only do you not need to create view model object, you rarely create reference type objects in general. If View can be a protocol rather than a reference type object for you to inherit, a mandatory reference type object for every view should probably be considered as anti-pattern. And if you get used to it, you don’t even need inheritance, which makes sense since Swift is advertised to be a POP rather than OOP language.</p><p name="eb00" id="eb00" class="graf graf--p graf-after--p">There are other advanced topics on POP and state management. Other design patterns need to adapt to language features too, e.g.; Redux, not just MVVM. <br>For example, state in SwiftUI is local, which breaks Redux’s global state requirement. But it makes sense in iOS view hierarchy. Maybe a locally state management based on POP? What does it look like?</p><h4 name="6398" id="6398" class="graf graf--h4 graf-after--p">BONUS CONTENT:</h4><p name="d58d" id="d58d" class="graf graf--p graf-after--h4">There are some quick checks to identify the shity MVVM devs.</p><ol class="postList"><li name="38a2" id="38a2" class="graf graf--li graf-after--p">They create view model in SwiftUI.</li></ol><p name="b17f" id="b17f" class="graf graf--p graf-after--li">As explained above. You don’t need it. Good devs can identify MVVM from SDK itself. Shit devs sell tutorial of forcing MVVM in name only to SDK.</p><p name="e387" id="e387" class="graf graf--p graf-after--p">I’m about the only person you can find on Internet who stood up to this bullshit.</p><p name="0bf2" id="0bf2" class="graf graf--p graf-after--p">2. Their view model is almost always functionally equivalent to a RequestHandler.</p><p name="5f2d" id="5f2d" class="graf graf--p graf-after--p">This is a long-time problem for MVVM devs. They always couple networking with view model and binding. Any devs worth their salt refactor out networking as its own service. That is why most MVVM devs are shity. Creating an object called view model is 95% of their knowledge of MVVM. This may work on other platforms, but not on iOS, and they lacked the skill to adapt it to UIKit then and SwiftUI now. You don’t need an object to make an API call, and if you need it, you refactor it out otherwise you just have to duplicate it in most of the view models. None of this is covered in so-called MVVM tutorials. Especially in case of SwiftUI, binding is built-in, there’s nothing special with this view model, which observes and notifies SDK to update binding rather than defines said binding. It doesn’t even cover all model, often just some of the properties with state. They will never you that you should try to separate value type data from reference type state object. They will lump it together in the sink object known as view model like they always do. Change the name of view model to request handler and nothing would’ve changed. Their MVVM only exists in name.</p><p name="dd53" id="dd53" class="graf graf--p graf-after--p">3. They never say anything about @State</p><p name="4789" id="4789" class="graf graf--p graf-after--p">This is your view model. You don’t need to create a new class, and conform it to ObservableObject. It’s a local property and supports value type. So you start with protection without boilerplate code. <strong class="markup--strong markup--p-strong">This, is SDK design.</strong></p><p name="2fa9" id="2fa9" class="graf graf--p graf-after--p">Create an observable object only when this is not viable for some reason. Because you lose protection of immutability by value type. MVVM devs always start with this step. That is why they suck. Understand the SDK you are working with.</p><p name="2f85" id="2f85" class="graf graf--p graf-after--p">Also note that @State can only be declared inside a Model: View (note that it is a Model rather than View) and you can not have mutable property outside of @State and other specific annotations. So naturally you would put view-logic inside the Model, and “business logic” outside in terms of MVVM with the exception of sharing certain states across the view hierarchy. You will soon come to the conclusion that you only need to consider if you want this particular to be shared or not, and if it is to be shared, at what capacity. Without the ambiguous MVVM classification. The choice of using @State, @ObservedObject, @EnvironmentObject depends on a lot of factors like the scope and data origin.</p><p name="96c7" id="96c7" class="graf graf--p graf-after--p">If you follow MVVM tutorial blindly, you will most likely just use @ObservedObject, and only one as a sink object to do everything.</p><figure name="be1e" id="be1e" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*OoXg7ujporoXI-KZqWjagw.jpeg" data-width="500" data-height="597" src="https://cdn-images-1.medium.com/max/800/1*OoXg7ujporoXI-KZqWjagw.jpeg"><figcaption class="imageCaption">A typical MVVM developer</figcaption></figure><h4 name="4618" id="4618" class="graf graf--h4 graf-after--figure">Comparison and Conclusion</h4><p name="8a36" id="8a36" class="graf graf--p graf-after--h4">Let me show you how a chad MVC developer does the same thing with SwiftUI.</p><p name="f8fe" id="f8fe" class="graf graf--p graf-after--p">E.g.;</p><pre name="9fef" id="9fef" class="graf graf--pre graf-after--p">@State var data = JSON()<br>//on button click<br>api.username.get().onSuccess {json in self.data = json}</pre><p name="aeb6" id="aeb6" class="graf graf--p graf-after--pre">I don’t need a request handler pretending to be a view model. I have all the binding and notification on state change. I have api as dedicated networking service whose origin may come from @EnvironmentObject or other means as I deem fit.</p><p name="1341" id="1341" class="graf graf--p graf-after--p">Do I give a shit about <em class="markup--em markup--p-em">“Views should be independent of model types” </em>? No.</p><p name="d486" id="d486" class="graf graf--p graf-after--p">(It is fucking bullshit btw, “View” is a model type that conforms to View protocol in SwiftUI, there’s no independent of. View <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">is</em></strong> model type!)</p><p name="0edd" id="0edd" class="graf graf--p graf-after--p">But it just works. Like discussed above, I’m more MVVM than you with much less effort. <strong class="markup--strong markup--p-strong">All MVVM devs know is create view model.</strong></p><p name="eefd" id="eefd" class="graf graf--p graf-after--p">If your MVVM code is not as compact as this, what does MVVM really bring to the table that is not already built-in?</p><p name="5bc8" id="5bc8" class="graf graf--p graf-after--p">I’m so sick of the non-sense tutorials when you search keyword swiftui + mvvm. Spread this article if you think this makes sense. Help this to be top search result.</p><p name="6cdf" id="6cdf" class="graf graf--p graf-after--p">Oh btw. Props to our <a href="https://matteomanferdini.com/mvvm-pattern-ios-swift/" data-href="https://matteomanferdini.com/mvvm-pattern-ios-swift/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">convetional MVVM wisdom</a> friend. Even he thought coupling networking to view model is dog shit. Quote:</p><blockquote name="7a8c" id="7a8c" class="graf graf--blockquote graf-after--p">This is another long-standing debate about MVVM, where some proponents insist that networking code goes inside a view model?</blockquote><blockquote name="e83c" id="e83c" class="graf graf--blockquote graf-after--blockquote">I beg to differ.</blockquote><blockquote name="c94e" id="c94e" class="graf graf--blockquote graf-after--blockquote">If you look at it from the point of view of reusing code, that’s a mistake. While a view model clearly needs to trigger network requests to fetch data, networking code is filled with boilerplate.</blockquote><p name="4f1c" id="4f1c" class="graf graf--p graf-after--blockquote">But then if you look at his view model:</p><figure name="1d77" id="1d77" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*E4Grd9MS8DL6boIHJdQvYA.png" data-width="628" data-height="363" src="https://cdn-images-1.medium.com/max/800/1*E4Grd9MS8DL6boIHJdQvYA.png"></figure><p name="06dd" id="06dd" class="graf graf--p graf-after--figure">…it is full of networking code. If this is the level of</p><blockquote name="8c98" id="8c98" class="graf graf--blockquote graf-after--p">DECOUPLING OF NETWORKING FROM VIEW MODEL</blockquote><p name="b6b0" id="b6b0" class="graf graf--p graf-after--blockquote">of MVVM devs that think he is good enough to publish a tutorial, you know MVVM is full of shit. Case and point.</p><p name="0e8d" id="0e8d" class="graf graf--p graf-after--p">I leave it as an exercise for you to refactor this into</p><pre name="f577" id="f577" class="graf graf--pre graf-after--p">api.topStories.post().onSuccess { json in ...}</pre><p name="bad8" id="bad8" class="graf graf--p graf-after--pre">It is reusable, single responsibility, low overhead, no confusing design philosophy yet highly refactored.</p><p name="346f" id="346f" class="graf graf--p graf-after--p">Then his view model is just</p><pre name="9d8c" id="9d8c" class="graf graf--pre graf-after--p">class NewsViewModel: ObservableObject {<br>    @Published var stories = [Item?](...)</pre><pre name="a99d" id="a99d" class="graf graf--pre graf-after--pre">}</pre><p name="8ac7" id="8ac7" class="graf graf--p graf-after--pre">which is just</p><pre name="0daa" id="0daa" class="graf graf--pre graf-after--p">@State var stories = [Item?](...)</pre><p name="ad55" id="ad55" class="graf graf--p graf-after--pre graf--trailing">Learn SDK. Learn refactor. This is why MVVM devs get MVVM wrong in SwiftUI.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/a937a4268483"><time class="dt-published" datetime="2022-02-22T08:44:42.026Z">February 22, 2022</time></a>.</p><p><a href="https://medium.com/@swift2931/how-mvvm-devs-get-mvvm-wrong-in-swiftui-a937a4268483" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>