<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>How to fail miserably with RxSwift + MVVM</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">How to fail miserably with RxSwift + MVVM</h1>
</header>
<section data-field="subtitle" class="p-summary">
Ahh… Clean Code, MVVM, RxSwift.
</section>
<section data-field="body" class="e-content">
<section name="4c47" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="d5d6" id="d5d6" class="graf graf--h3 graf--leading graf--title">How to fail miserably with RxSwift + MVVM</h3><p name="9467" id="9467" class="graf graf--p graf-after--h3"><em class="markup--em markup--p-em">Ahh… Clean Code, MVVM, RxSwift.</em></p><p name="7b3f" id="7b3f" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">Wilful traitors, all.</em></p><figure name="22c0" id="22c0" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*CChofTEiXg7yfyLt4GOwiQ.jpeg" data-width="640" data-height="314" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*CChofTEiXg7yfyLt4GOwiQ.jpeg"></figure><h4 name="40a8" id="40a8" class="graf graf--h4 graf-after--figure">This episode of making fun of MVVM</h4><p name="5b22" id="5b22" class="graf graf--p graf-after--h4">I just love how MVVM devs never seem to be able to write something self-contained. In this episode I’m going to show how MVVM used view model to do view controller’s job, then used networking to do view model’s job, and ended up with RxSwift doing both of the jobs.</p><p name="697e" id="697e" class="graf graf--p graf-after--p">Article link goes here. <a href="https://kananabilzada.medium.com/rxswift-usage-with-mvvm-pattern-c7b19af53a7d" data-href="https://kananabilzada.medium.com/rxswift-usage-with-mvvm-pattern-c7b19af53a7d" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">RxSwift usage with MVVM</a></p><h4 name="1cec" id="1cec" class="graf graf--h4 graf-after--p">What you can tell from project structure</h4><figure name="0b8b" id="0b8b" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*FY1188R42tCK2EtubYT00A.png" data-width="649" data-height="653" src="https://cdn-images-1.medium.com/max/800/1*FY1188R42tCK2EtubYT00A.png"></figure><p name="60dc" id="60dc" class="graf graf--p graf-after--figure">Network per view controller is usually a red flag, because networking should be independent of views.</p><p name="cea5" id="cea5" class="graf graf--p graf-after--p">ViewModel is as usual, ambiguous. If it is not model, not view control, not network, then wtf is it? MVVM devs often work in a vacuum. They are too occupied with pretty diagrams on Internet that they just ignore the fact that SDK is built around view controller hierarchy.</p><p name="11b1" id="11b1" class="graf graf--p graf-after--p">Over time, to shove it in the existing controller hierarchy, a compromise is to use view model to handle view update logic involving networking. Remember what I just said? <strong class="markup--strong markup--p-strong">Network per view controller is usually a red flag. </strong>And why does no MVVM dev ever mention this? Because they are too occupied with pretty diagrams on Internet. It’s like poetry they rhyme. And you know who love to talk about what should be independent of views? MVVM devs. And you know who love to build extra folders and structures around views? MVVM devs. You know who also love to talk about re-usability of view model while they have a view model per view controller?</p><p name="1c50" id="1c50" class="graf graf--p graf-after--p">Before going into codes, you can already tell there’s going to be shit load of types. One type for view model per view controller. One type per api endpoint. One type per request/response/parameters. One type for actual model. <strong class="markup--strong markup--p-strong">This is another red flag: your design needs refactor.</strong></p><p name="2870" id="2870" class="graf graf--p graf-after--p">This is why I consider MVVM an anti-pattern (at least in iOS). It blocked you from all the hints and signs of design problems. Change view model folder to something else, what other name can you call it? A request handler? Can’t this be refactored out?</p><h4 name="1c97" id="1c97" class="graf graf--h4 graf-after--p">The concept of side effects</h4><pre name="64e3" id="64e3" class="graf graf--pre graf-after--h4"><strong class="markup--strong markup--pre-strong">class</strong> PhotoListViewModel: PhotoListViewModelActions {<br>    <strong class="markup--strong markup--pre-strong">let</strong> imageLoaderService = StringImageLoader()<br>    // <strong class="markup--strong markup--pre-strong">MARK: - Variables<br>    private</strong> <strong class="markup--strong markup--pre-strong">var</strong> currentPage  = BehaviorRelay(value: 1)<br>    <strong class="markup--strong markup--pre-strong">private</strong> <strong class="markup--strong markup--pre-strong">let</strong> photoService = PhotoService.shared<br>    <strong class="markup--strong markup--pre-strong">private</strong> <strong class="markup--strong markup--pre-strong">let</strong> disposeBag   = DisposeBag()<br>    <strong class="markup--strong markup--pre-strong">var</strong> photoList       = BehaviorRelay&lt;[PhotoListModel]&gt;(value: [])<br>    <strong class="markup--strong markup--pre-strong">var</strong> imageDownloaded = PublishRelay&lt;(Int, UIImage?)&gt;()<br>    <br>    <strong class="markup--strong markup--pre-strong">init</strong>() {<br>        <strong class="markup--strong markup--pre-strong">self</strong>.fetchImages(currentPage: <strong class="markup--strong markup--pre-strong">self</strong>.currentPage.value)<br>    }<br>}</pre><p name="6f7e" id="6f7e" class="graf graf--p graf-after--pre">The hot take is this. This is not clean, which is what RxSwift / MVVM keep advertising about.</p><pre name="4b38" id="4b38" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">private</strong> <strong class="markup--strong markup--pre-strong">let</strong> photoService = PhotoService.shared</pre><p name="7e05" id="7e05" class="graf graf--p graf-after--pre">This is singleton pretending to be private property.</p><pre name="8a74" id="8a74" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">private</strong> <strong class="markup--strong markup--pre-strong">let</strong> disposeBag   = DisposeBag()</pre><p name="252a" id="252a" class="graf graf--p graf-after--pre">This is overhead cost. If a library asks you to manually free memory for every usage, it’s a shit library.</p><pre name="3572" id="3572" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">init</strong>() {<br>        <strong class="markup--strong markup--pre-strong">self</strong>.fetchImages(currentPage: <strong class="markup--strong markup--pre-strong">self</strong>.currentPage.value)<br>    }</pre><p name="9352" id="9352" class="graf graf--p graf-after--pre">This is hidden side effect in initializer. <code class="markup--code markup--p-code">fetchImages</code> itself is also a function with side effects. It has no callback! Where does it save? When does it complete? I call this kind of design pattern <em class="markup--em markup--p-em">shady as fuck</em>.</p><p name="d981" id="d981" class="graf graf--p graf-after--p">Side effects like callback is what a dev should put emphasis on. Not something a dev should hide for clean / decouple or some other excuses (there are a lot of ways to refactor). Not only is this view model full of networking that triggers immediately upon object creation without caller’s explicit action, it hides material details from caller. This is not a feature, this is <em class="markup--em markup--p-em">shady as fuck</em>.</p><p name="34f5" id="34f5" class="graf graf--p graf-after--p">This is particularly important for “view model” because you often have to tell user if an api call resulted in failure by displaying a message. Rx would tell you that you can simply assume a model of an infinite stream on which you can add observables to notify view model at the event of network failure. What we can learn from this is that a. it doesn’t reduce the amount of the work. b. it is more complicated than it needs to be. You can count how many types and objects created already for this api call. And to emphasize, there are implicit interactions and side effects across reference type objects.</p><p name="d8ae" id="d8ae" class="graf graf--p graf-after--p">In usage like this, I would argue that they should be refactored out to a dedicated service object. The protocol is useless in this case, because you have to interconnect it in a specific library-dependent way that may not be obvious from the protocol. In other words, you are basically telling me “these are the variables I used in my implementation, now implement it yourself”. This is also a hint that you may be doing something wrong and probably need to rethink your design.</p><p name="dd40" id="dd40" class="graf graf--p graf-after--p">If you follow this hint, and decide that you want to encapsulate these implementation details into a service. What would it look like?</p><pre name="9017" id="9017" class="graf graf--pre graf-after--p">let photoList = RemotePhotoList()</pre><pre name="8c9e" id="8c9e" class="graf graf--pre graf-after--pre">photoList.fetch(currentPage).onSuccess {self.updateUI()}<br>// all data are in photoList, use it to update view</pre><p name="9698" id="9698" class="graf graf--p graf-after--pre">Clean code? Cleaner than this??? <em class="markup--em markup--p-em">Wilful traitors, all.</em></p><p name="3b3d" id="3b3d" class="graf graf--p graf-after--p">The difference here is that I don’t couple networking with view model (well, don’t even need it), and library code is a service not a conformance. Also a callback is all you need, not an infinite stream of observables that you have to subscribe to.</p><p name="73b3" id="73b3" class="graf graf--p graf-after--p">In usage like this you often need to consider paging and caching. So it would be more complicated than shown above. I usually use Paging as a protocol with default implementation.</p><h4 name="89b4" id="89b4" class="graf graf--h4 graf-after--p">Tell me you don’t know how to work with UIKit without telling me</h4><p name="5f5d" id="5f5d" class="graf graf--p graf-after--h4">Now to one of the big selling points of RxSwift. <em class="markup--em markup--p-em">Binding</em>.</p><pre name="ad34" id="ad34" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">private</strong> <strong class="markup--strong markup--pre-strong">func</strong> bindCollectionView() {<br>    // <strong class="markup--strong markup--pre-strong">MARK: Bind photoList to collectionView</strong><br>    viewModel.photoList<br>       .filter({ !$0.isEmpty })<br>       .bind(to: collectionView.rx<br>          .items(cellIdentifier: PhotoCollectionViewCell.identifier,<br>              cellType: PhotoCollectionViewCell.<strong class="markup--strong markup--pre-strong">self</strong>)) { _, _, _ <strong class="markup--strong markup--pre-strong">in</strong>}<br>       .disposed(by: disposeBag)<br>}</pre><p name="2747" id="2747" class="graf graf--p graf-after--pre">You can’t possibly do this with UIKit right?</p><p name="ef2f" id="ef2f" class="graf graf--p graf-after--p">This is one solution.</p><pre name="58f0" id="58f0" class="graf graf--pre graf-after--p">let photoList = RemotePhotoList()</pre><pre name="4218" id="4218" class="graf graf--pre graf-after--pre">photoList.fetch(currentPage).onSuccess {self.updateUI()}<br>// all data are in photoList, use it to update view</pre><p name="75bc" id="75bc" class="graf graf--p graf-after--pre">Remember when I said all you need is a callback?</p><p name="2601" id="2601" class="graf graf--p graf-after--p">Or if you really want to observe something.</p><pre name="5b98" id="5b98" class="graf graf--pre graf-after--p">var photoList = [RemotePhoto]() { didSet {updateUI()} }</pre><pre name="d343" id="d343" class="graf graf--pre graf-after--pre">// api call<br>api.photoList.post(params).onSuccess {data in self.photoList = process(data)}</pre><p name="7087" id="7087" class="graf graf--p graf-after--pre">Where you can do filter in process function. No need to bind because no view model. But is it Reactive Programming? UI update as a reaction to data change.</p><p name="2382" id="2382" class="graf graf--p graf-after--p">You also have: explicit control of when to initiate request, callback definition and direct handling of different results without Rx.</p><p name="f2de" id="f2de" class="graf graf--p graf-after--p">View update follows standard UIKit.</p><p name="27c1" id="27c1" class="graf graf--p graf-after--p">If a library that replaces UIKit does not do basic tasks better than UIKit, then it’s <em class="markup--em markup--p-em">shady as fuck</em>.</p><h4 name="b872" id="b872" class="graf graf--h4 graf-after--p"><em class="markup--em markup--h4-em">Thy kind are all of a piece. Pillagers. Emboldened by the flame of ambitions.</em></h4><p name="ac13" id="ac13" class="graf graf--p graf-after--h4">Let’s summarize what we’ve learned so far.</p><p name="2213" id="2213" class="graf graf--p graf-after--p">MVVM, no matter how great it sounds on paper, cannot exist without considering context. In iOS this context means view controller hierarchy in UIKit and no native support for binding.</p><p name="d877" id="d877" class="graf graf--p graf-after--p">MVVM also doesn’t prevent you from dumb refactor or design mistakes. It is hidden because of its success on other platforms, so MVVM equals clean architecture automatically. If you write shit networking, you write shit networking in MVVM. RxSwift has its usage, but bear in mind it is built around abstract concepts like infinite stream of bullshit. It is NOT built around unique Swift features. Your stream is immutable? Dude value type is immutable already. Does that stop you from wrapping it in reference type and invoke function with side effect without callback implicitly?</p><p name="19ef" id="19ef" class="graf graf--p graf-after--p">I recently just checked how many articles about POP on google. There are pathetically few. I just showed you a case of questionable usage of protocol.</p><p name="a6a8" id="a6a8" class="graf graf--p graf-after--p graf--trailing">So again, learn Swift, learn SDK. I might write some POP if there are people interested. Meanwhile I’m going to finish my 3rd elden ring run now.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/de5dd66008e"><time class="dt-published" datetime="2022-04-07T10:37:06.659Z">April 7, 2022</time></a>.</p><p><a href="https://medium.com/@swift2931/how-to-fail-miserably-with-rxswift-mvvm-de5dd66008e" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>