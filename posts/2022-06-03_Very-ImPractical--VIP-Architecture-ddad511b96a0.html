<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Very ImPractical (VIP)Architecture</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Very ImPractical (VIP)Architecture</h1>
</header>
<section data-field="subtitle" class="p-summary">
Why clean Swift is not clean
</section>
<section data-field="body" class="e-content">
<section name="ae0a" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="e9b8" id="e9b8" class="graf graf--h3 graf--leading graf--title">Very ImPractical (VIP)Architecture</h3><p name="684c" id="684c" class="graf graf--p graf-after--h3">Why clean Swift is not clean</p><figure name="9875" id="9875" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*mBCrL1gdW1wedD8Volg2NA.jpeg" data-width="577" data-height="433" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*mBCrL1gdW1wedD8Volg2NA.jpeg"></figure><h4 name="4d4c" id="4d4c" class="graf graf--h4 graf-after--figure">This is code smell</h4><pre name="ac64" id="ac64" class="graf graf--pre graf-after--h4">iceCream.displayedCones = viewModel.cones<br>iceCream.displayedFlavors = viewModel.flavors<br>iceCream.displayedToppings = viewModel.toppings</pre><p name="a65f" id="a65f" class="graf graf--p graf-after--pre">A code snippet from <a href="https://www.raywenderlich.com/29416318-getting-started-with-the-vip-clean-architecture-pattern" data-href="https://www.raywenderlich.com/29416318-getting-started-with-the-vip-clean-architecture-pattern" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">Getting Started With the VIP Clean Architecture Pattern</strong></a><strong class="markup--strong markup--p-strong">.</strong></p><p name="dcf1" id="dcf1" class="graf graf--p graf-after--p">This is where you stop and re-think your architecture design. Why?</p><p name="85ba" id="85ba" class="graf graf--p graf-after--p">Because it’s a dumb useless boilerplate. You know from the get-go that it won’t scale. At the very least pass view model as a parameter, and since view model is a value type in this example, it’s just a copy. The last thing you want is to go through individual properties and assign them manually.</p><p name="0615" id="0615" class="graf graf--p graf-after--p">And why do you need to copy view model just so another model(iceCream) can act as view model? Now you need to work to maintain single source of truth, which might explain the shit tons of setup code. And this is supposed to be an improvement over VIPER. This should give you an idea of how shity VIPER really is.</p><p name="8206" id="8206" class="graf graf--p graf-after--p">Now if we dare to ask why bother splitting a view model into two parts. We will get a “fixing massive view controller problem” and a nice diagram in reply. Let’s take a closer look.</p><h4 name="4846" id="4846" class="graf graf--h4 graf-after--p">Massive view controller problem</h4><blockquote name="75e8" id="75e8" class="graf graf--blockquote graf-after--h4">VIP was created as a solution to massive view controllers in <strong class="markup--strong markup--blockquote-strong">UIKit</strong>. It’s meant to make building larger apps and adding new features easier on long-term project</blockquote><figure name="c7a2" id="c7a2" class="graf graf--figure graf-after--blockquote"><img class="graf-image" data-image-id="1*i3kodVmJdURovIE2kuqflg.png" data-width="677" data-height="383" src="https://cdn-images-1.medium.com/max/800/1*i3kodVmJdURovIE2kuqflg.png"><figcaption class="imageCaption">Where is view controller?</figcaption></figure><p name="a1e1" id="a1e1" class="graf graf--p graf-after--figure">You know what is also a solution to massive view controller problem?</p><p name="76dd" id="76dd" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">don’t write a massive view controller</em></strong></p><p name="ff31" id="ff31" class="graf graf--p graf-after--p">I love how each and every MVVM-related pattern thinks every MVC dev is an idiot. You can absolutely write clean MVC codes. But I challenge you to find an article online as to how. Why? Because you can’t sell a tutorial without buzzwords.</p><p name="1aea" id="1aea" class="graf graf--p graf-after--p">I’m about the only person on Internet you can find that talk shit on big name architectures. Because unlike most “clean architecture” pumpers, I know how efficient MVC code can be with Swift language features. My “massive view controller” apparently has higher standards regarding to boilerplate than “clean architecture”.</p><p name="bf53" id="bf53" class="graf graf--p graf-after--p">If the criticism to a clean architecture is “too much boilerplate”, why is it clean in the first place? Shouldn’t the word “clean” be held to the highest standards?</p><p name="6132" id="6132" class="graf graf--p graf-after--p">Now look at the diagram. What is missing?</p><p name="56d2" id="56d2" class="graf graf--p graf-after--p">Where’s view controller? (For SwiftUI, where’s model-view binding)</p><p name="85b9" id="85b9" class="graf graf--p graf-after--p">You are telling me that you have this wonderful arch out of vacuum, without any consideration to SDK, and it somehow integrates to existing SDK flawlessly? Even if somehow you managed to improve upon SDK, you need to show / explain the role SDK plays.</p><p name="2a07" id="2a07" class="graf graf--p graf-after--p">For example, this view -&gt; request -&gt; interactor arrow is questionable. Because in UIKit, UI event is handled in view controller by delegate / dataSource, there’s no way you can skip view controller. If you put view controller in the diagram, it will become a mess. For SwiftUI, it’s built-in. You can do the same thing without explicit request, interactor type, interactions… etc. This should just be the end of “clean architecture” because SDK does the same thing without boilerplate.</p><p name="9beb" id="9beb" class="graf graf--p graf-after--p">Clean Swift thinks you are an idiot who can only write massive view controller. Let me provide some perspective from a guy who knows how to refactor his view controller:</p><p name="c3d0" id="c3d0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Clean Swift is written by a guy who writes massive view controller.</strong></p><p name="1146" id="1146" class="graf graf--p graf-after--p">Let’s look at some of its implementations.</p><h4 name="dd71" id="dd71" class="graf graf--h4 graf-after--p">Atrocious dog shit design</h4><pre name="2838" id="2838" class="graf graf--pre graf-after--h4">enum CreateIceCream {<br>  enum LoadIceCream {<br>    struct Request {}<br><br>    struct Response {<br>      var iceCreamData: IceCream<br>    }<br><br>    struct ViewModel {<br>      var cones: [String]<br>      var flavors: [String]<br>      var toppings: [String]<br>    }<br>  }<br>}</pre><p name="7bdd" id="7bdd" class="graf graf--p graf-after--pre">Use enum as namespace and a nested 3 layer model is atrocious.</p><p name="f827" id="f827" class="graf graf--p graf-after--p">Incurring CreateIceCream.LoadIceCream cost for every property access is dog.</p><p name="130b" id="130b" class="graf graf--p graf-after--p">ViewModel without binding is shit.</p><p name="3aec" id="3aec" class="graf graf--p graf-after--p">This is over-engineering to make the code look clean. It’s <strong class="markup--strong markup--p-strong">impractical</strong>. Even if I were to send request or response, a flat <code class="markup--code markup--p-code">func request(params...)</code> is a better choice than nested <code class="markup--code markup--p-code">struct Request{}</code> .</p><p name="335d" id="335d" class="graf graf--p graf-after--p">Your code would be filled with CreateIceCream prefix to the point it’s hard to find the thing you want. Let’s take a moment to admire this gem.</p><pre name="6a77" id="6a77" class="graf graf--pre graf-after--p">let request = CreateIceCream.LoadIceCream.Request()</pre><p name="7c58" id="7c58" class="graf graf--p graf-after--pre">Compare it to this</p><pre name="0ca8" id="0ca8" class="graf graf--pre graf-after--p">iceCream.request(load: params)</pre><p name="9337" id="9337" class="graf graf--p graf-after--pre">Which is cleaner?</p><p name="43c3" id="43c3" class="graf graf--p graf-after--p">There’s a higher level of descriptive code. Codes that you can <strong class="markup--strong markup--p-strong">infer</strong>. You don’t need constant reminder that this is to CreateIceCream. You can infer it from filename or class name alone.</p><h4 name="47a0" id="47a0" class="graf graf--h4 graf-after--p">Welcome to dollar store MVC</h4><figure name="0424" id="0424" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*C3hzflewTNrd8Tf1zPhHPQ.png" data-width="713" data-height="325" src="https://cdn-images-1.medium.com/max/800/1*C3hzflewTNrd8Tf1zPhHPQ.png"></figure><p name="93e9" id="93e9" class="graf graf--p graf-after--figure">You know the secrets to writing clean MVC?</p><p name="4277" id="4277" class="graf graf--p graf-after--p">Have some single-responsibility library objects to do work. So the only thing new in the interactor-worker design is the name worker.</p><p name="c884" id="c884" class="graf graf--p graf-after--p">The requirement of affix “Worker” seems redundant. Seriously, does clean Swift has nothing better to do than making naming rules? You can infer everything from a name <code class="markup--code markup--p-code">api.post()</code> or <code class="markup--code markup--p-code">coreData.load()</code> . And these most likely are project-wide service objects.</p><p name="001b" id="001b" class="graf graf--p graf-after--p">Why is this dollar store? Because it ignores view controller so wouldn’t touch techniques that build around it. For example you can use extensions to offload view controller. Think about it, what’s stopping you from having a massive interactor? The common problem with clean Swift and VIPER is that it refactors by classifying. You “solve” massive view controller by having interactors, presenters… etc. Then what’s stopping you from having massive interactors, presenters… etc? Clean Swift claims to solve VIPER’s massive presenter problem, but says nothing about massive interactor. Both ignore SDK and boilerplate costs. In the end you still have to rely on refactor techniques that doesn’t involve creating a new object and dump it there. And if you can do that, what’s the point of creating these many objects in the first place?</p><p name="0d5a" id="0d5a" class="graf graf--p graf-after--p">This rigid rule of partitioning is not productive. Nothing stops you from having delegate objects in MVC. In fact UIKit is full of delegate objects. If you put view controller back in clean Swift diagram, these interactors, presenters are delegates of view controller. And it becomes a dollar store MVC with mandatory delegate objects and some view model capability depending on how well it implements view model.</p><h4 name="fc6c" id="fc6c" class="graf graf--h4 graf-after--p">It implements view model badly</h4><pre name="03e0" id="03e0" class="graf graf--pre graf-after--h4">let viewModel = CreateIceCream.LoadIceCream.ViewModel(<br>  cones: response.iceCreamData.cones,<br>  flavors: response.iceCreamData.flavors,<br>  toppings: response.iceCreamData.toppings<br>)<br>view?.displayIceCream(viewModel: viewModel)</pre><p name="0e2c" id="0e2c" class="graf graf--p graf-after--pre">Aren’t you tired of writing this shit? I’m tired of this shit just reading it.</p><p name="ae52" id="ae52" class="graf graf--p graf-after--p">Imagine writing this shit, and instead of getting fired immediately, you get to sell tutorial on <a href="https://www.raywenderlich.com/" data-href="https://www.raywenderlich.com/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">raywenderlich</a>.com.</p><p name="5fde" id="5fde" class="graf graf--p graf-after--p">Remember this? On the top of this article where I call it code smell.</p><pre name="9a29" id="9a29" class="graf graf--pre graf-after--p">iceCream.displayedCones = viewModel.cones<br>iceCream.displayedFlavors = viewModel.flavors<br>iceCream.displayedToppings = viewModel.toppings</pre><p name="472d" id="472d" class="graf graf--p graf-after--pre">How many times you need to pass the same thing over and over again?</p><p name="43ae" id="43ae" class="graf graf--p graf-after--p">Any dev worth their salt refactors this immediately. This kind of shit is at most one and done. No repeat!</p><p name="23e5" id="23e5" class="graf graf--p graf-after--p">This is one way to re-design.</p><pre name="37a0" id="37a0" class="graf graf--pre graf-after--p">view?.displayIceCream(response)</pre><p name="23e3" id="23e3" class="graf graf--p graf-after--pre">Because extracting view model from response can be refactored. You don’t even need to expose intermediate objects like view model.</p><p name="6806" id="6806" class="graf graf--p graf-after--p">If view model changes, which is very frequent, because view changes all the time, this is one fewer place you need to modify. Clean Swift, ladies and gentlemen.</p><h4 name="37b4" id="37b4" class="graf graf--h4 graf-after--p">Presenter is redundant</h4><p name="0289" id="0289" class="graf graf--p graf-after--h4">As an exercise, guess why you don’t need presenter before you read on.</p><p name="2ef7" id="2ef7" class="graf graf--p graf-after--p">Hint: when to use value type and when to use reference type</p><p name="92c9" id="92c9" class="graf graf--p graf-after--p">Presenter is a reference type object, why?</p><p name="ccd8" id="ccd8" class="graf graf--p graf-after--p">That means it can mutate state or introduce side effects.</p><p name="7c04" id="7c04" class="graf graf--p graf-after--p">This distinction does not exist in Java, because there’s no value type in Java. But in Swift you need to justify it. Why would you mutate state or introduce side effects in a presenter? The only case of mutating state is to update view model. But view model is determined in the previous step from response. This implies presenter has its own implicit view model. Why the redundancy? You would want one copy of view model to be single source of truth. If you just do usual view model with binding, the rest of presenter can be replaced by computed properties. Because otherwise there’s no need for it to mutate state.</p><p name="f651" id="f651" class="graf graf--p graf-after--p">So clean Swift doesn’t do MVVM right for redundant view model design, doesn’t do Swift right for lack of computed properties, and it’s not clean shown by easy refactor alternatives above. Tell me at least it tries to do POP right.</p><h4 name="d305" id="d305" class="graf graf--h4 graf-after--p">How not to do POP</h4><pre name="e7b2" id="e7b2" class="graf graf--pre graf-after--h4">protocol CreateIceCreamPresentationLogic {<br>  func presentIceCream(response:   CreateIceCream.LoadIceCream.Response)<br>}<br><br>class CreateIceCreamPresenter {<br>  var view: CreateIceCreamDisplayLogic?<br>}</pre><p name="e0c2" id="e0c2" class="graf graf--p graf-after--pre">Over-generalization. View is not Control. Common problems for MVVM. Because it puts so much emphasis on view control while trying to bypass view controller (ironic).</p><p name="78e1" id="78e1" class="graf graf--p graf-after--p">The most important part is Control (not just view control). This is where MVC shines. Let me provide a perspective outside of MVVM echo chamber.</p><p name="1207" id="1207" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Do not couple view with control logic. It’s MVC not MVV for a reason.</strong></p><p name="1715" id="1715" class="graf graf--p graf-after--p">A view has to implement <code class="markup--code markup--p-code">CreateIceCreamPresentationLogic</code> . Then the view has to know how it presents itself? Wtf is your presenter doing? This is avoiding centralized control to an extreme that even a view has to know how to present itself.</p><p name="9293" id="9293" class="graf graf--p graf-after--p">We have seen clean Swift uses model for request, uses view for DisplayLogic. Dude you have presenter / interactor, use it! Function is control. Not model, not view.</p><h4 name="5a92" id="5a92" class="graf graf--h4 graf-after--p">Wrap Up</h4><p name="7a9b" id="7a9b" class="graf graf--p graf-after--h4">There are tons of other shit that I can write about. But I got to eat now.</p><p name="b719" id="b719" class="graf graf--p graf-after--p">I hope this convinces you that clean Swift is a boilerplate mess written by the kind of guy that writes the most massive view controller. Over-generalization, writing pattern only for the sake of writing pattern, poor understanding of view model and Swift features.</p><p name="e6a8" id="e6a8" class="graf graf--p graf-after--p">The real irony of all this is that you can re-write this tutorial in massive view controller way and it will look cleaner.</p><h4 name="d6c7" id="d6c7" class="graf graf--h4 graf-after--p">Edit</h4><p name="fa3c" id="fa3c" class="graf graf--p graf-after--h4">Forgot to write about Router. This is top entertainment and it would be a shame to miss out.</p><p name="8ad8" id="8ad8" class="graf graf--p graf-after--p">Let’s start with a quote:</p><blockquote name="baa3" id="baa3" class="graf graf--blockquote graf-after--p">In <strong class="markup--strong markup--blockquote-strong">UIKit</strong>, you use segues to navigate and pass data between views. But, in SwiftUI, you use <code class="markup--code markup--blockquote-code">NavigationLink</code> inside the <code class="markup--code markup--blockquote-code">View</code>.</blockquote><blockquote name="803d" id="803d" class="graf graf--blockquote graf-after--blockquote">Do you see an issue here? <strong class="markup--strong markup--blockquote-strong">The view</strong> ends up handling both the navigation and data passing logic. This isn’t the way of clean architecture</blockquote><p name="3ac1" id="3ac1" class="graf graf--p graf-after--blockquote"><strong class="markup--strong markup--p-strong">Do you see an issue here?</strong></p><p name="d0dd" id="d0dd" class="graf graf--p graf-after--p">View is a protocol in SwiftUI.</p><pre name="11b4" id="11b4" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">struct Model: View {}</code></pre><p name="6466" id="6466" class="graf graf--p graf-after--pre">Because of 1 to 1 binding, it is convenient to interchange model and view when context is clear. But real insight occurs when you interpret it as above.</p><p name="3c32" id="3c32" class="graf graf--p graf-after--p">You can put properties in it and bind to whatever view defined in <code class="markup--code markup--p-code">body</code> . There are dedicated SDK supports like @State and @StateObject to help you create model with state. There’s no such support if you put model in observable object. So this is a legit way to interpret it and you lose nothing doing so unlike the case for observable object.</p><p name="717f" id="717f" class="graf graf--p graf-after--p">Sure you can interpret the value type as a view object, which technically is a protocol.</p><pre name="84e2" id="84e2" class="graf graf--pre graf-after--p">struct MyView: View {}</pre><p name="13f9" id="13f9" class="graf graf--p graf-after--pre">Then due to some ritualistic reason, MVVM devs would put model in an observable object and lose all SDK support. <em class="markup--em markup--p-em">“Decouple view from model”</em> , they will say. Which is the dumbest shit I’ve ever heard. Dude, you do realize you have to bind it back right? Doesn’t matter where you move it. To binding is to pull things together. There’s no decoupling in the middle of binding.</p><p name="c4fb" id="c4fb" class="graf graf--p graf-after--p">The point here is that it is an artificial interpretation with no scientific reason. You can eliminate this issue entirely by using an alternative interpretation in which you actually gain back SDK support! Two birds in one stone. You lose nothing! Your code is not clean when a simpler alternative exists that can do the same thing.</p><p name="3f86" id="3f86" class="graf graf--p graf-after--p">As for router in UIKit, I don’t find compelling reason why you couldn’t just have a simple dependency injection to do the same thing. Also I think router should be a service object, not one per view controller, because it needs a larger scope to transition between view controllers. Not to mention the tedious protocol writing. Not every thing needs to be a protocol. Member functions will suffice in a lot of cases.</p><p name="9f64" id="9f64" class="graf graf--p graf-after--p graf--trailing">My advice for beginners. Don’t bother with this shit. What you need is a good networking library including a JSON type. Use property observer for binding so you can have view model without creating extra objects. Use computed properties and value types whenever possible. You will beat most of the “clean architecture” using massive view controller.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/ddad511b96a0"><time class="dt-published" datetime="2022-06-03T12:09:49.518Z">June 3, 2022</time></a>.</p><p><a href="https://medium.com/@swift2931/very-impractical-vip-architecture-ddad511b96a0" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>