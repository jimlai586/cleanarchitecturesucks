<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Massive view controller a.k.a view model in SwiftUI</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Massive view controller a.k.a view model in SwiftUI</h1>
</header>
<section data-field="subtitle" class="p-summary">
There was nothing sane about MVVM. What happened there in SwiftUI, what happened after, even the good we did, all of it…all of it, madness.
</section>
<section data-field="body" class="e-content">
<section name="30d6" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="2b7c" id="2b7c" class="graf graf--h3 graf--leading graf--title">Massive view controller a.k.a view model in SwiftUI</h3><blockquote name="23c1" id="23c1" class="graf graf--blockquote graf-after--h3">There was nothing sane about MVVM. What happened there in SwiftUI, what happened after, even the good we did, all of it…all of it, madness.</blockquote><figure name="43dd" id="43dd" class="graf graf--figure graf--startsWithDoubleQuote graf-after--blockquote"><img class="graf-image" data-image-id="1*3fQzg8dVG2gQTQlhjENfww.jpeg" data-width="1094" data-height="500" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*3fQzg8dVG2gQTQlhjENfww.jpeg"><figcaption class="imageCaption">“It’s not possible, perhaps you saw burnt concrete?”</figcaption></figure><h4 name="93e2" id="93e2" class="graf graf--h4 graf-after--figure">Let’s create a meltdown… I mean massive view controller</h4><p name="efed" id="efed" class="graf graf--p graf-after--h4">Here’s what I’m going to do in this article.</p><p name="ca2b" id="ca2b" class="graf graf--p graf-after--p">I’ll start by intentionally create a massive view controller in SwiftUI. Then I’ll show that it’s functionally equivalent to view model. I’ll then explain why and compare with a couple “clean architectures”.</p><p name="5402" id="5402" class="graf graf--p graf-after--p">Oh, if you haven’t seen Chernobyl, go see it first. Otherwise you’ll miss out on the references, which are half of the fun!</p><h4 name="a07f" id="a07f" class="graf graf--h4 graf-after--p">Safety first, raise the power</h4><pre name="dbc5" id="dbc5" class="graf graf--pre graf-after--h4">struct ReactorView: View {<br>    @State var reactor = Reactor()<br>    @State var graphite = NotThere()<br>    var body: some View {Text(&quot;3.6 roentgen&quot;)}</pre><pre name="445a" id="445a" class="graf graf--pre graf-after--pre">}</pre><p name="e89c" id="e89c" class="graf graf--p graf-after--pre">Obviously I’d want to cram everything into <code class="markup--code markup--p-code">ReactorView</code>. But immutability of value type will force me to mark every property a view @State if I want to mutate it. But some of them might be intermediate variables that do not correspond to view properties.</p><p name="c920" id="c920" class="graf graf--p graf-after--p">How do I avoid this troublesome “immutability” put in place by SDK?</p><p name="2293" id="2293" class="graf graf--p graf-after--p">OK. What if I moved all properties except <code class="markup--code markup--p-code">body</code> to a reference type object? Then I can do whatever I want and only publish selected results. Free of all restrictions. Genius. Let’s call it ViewController for nostalgia.</p><pre name="8998" id="8998" class="graf graf--pre graf-after--p">class ViewController: ObservableObject {...}</pre><p name="9dc8" id="9dc8" class="graf graf--p graf-after--pre">Does it make sense in context? It does. We are refactoring out “Control” from view. A view controller that controls view states. Some may say that we are “decoupling” control from view.</p><p name="9a93" id="9a93" class="graf graf--p graf-after--p">We then obtain</p><pre name="3d5f" id="3d5f" class="graf graf--pre graf-after--p">struct ReactorView: View {<br>    @ObservedObject var vc = ViewController()</pre><pre name="f62a" id="f62a" class="graf graf--pre graf-after--pre">    var body: some View {Text(vc.roentgen)}<br>}</pre><p name="94f7" id="94f7" class="graf graf--p graf-after--pre">We have successfully decoupled Control from View. <code class="markup--code markup--p-code">ReactorView</code> is a lot cleaner. We also have a classic MVC architecture.</p><p name="1f9c" id="1f9c" class="graf graf--p graf-after--p">Now because <code class="markup--code markup--p-code">ViewController</code> is decoupled from View, it is <em class="markup--em markup--p-em">testable</em><strong class="markup--strong markup--p-strong">.</strong></p><p name="f1ac" id="f1ac" class="graf graf--p graf-after--p">I could copy 1000 words describing the benefits of such decoupling from MVVM, but you know where I’m going with this.</p><p name="ad16" id="ad16" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">ViewController</strong></code><strong class="markup--strong markup--p-strong"> is functionally equivalent to </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">ViewModel</strong></code><strong class="markup--strong markup--p-strong"> .</strong></p><p name="7e44" id="7e44" class="graf graf--p graf-after--p">You can easily verify this by renaming every view model to view controller. It still makes sense. Nothing needs to change.</p><p name="f119" id="f119" class="graf graf--p graf-after--p">What happened? <code class="markup--code markup--p-code">vm.roentgen</code>is clean architecture, but<code class="markup--code markup--p-code">vc.roentgen</code> has massive view controller problem?</p><p name="dc81" id="dc81" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">All I did is create a sink object</strong>, and move everything except view there. And we have same usage, same result. How do you get that number from feedwater leaking from a blown tank? You don’t. There’s graphite on the ground.</p><h4 name="c812" id="c812" class="graf graf--h4 graf-after--p">You didn’t see graphite</h4><p name="b47d" id="b47d" class="graf graf--p graf-after--h4">MVVM is the culmination of decades of hard work by <strong class="markup--strong markup--p-strong">industry titans, influencers and skilled veterans.</strong></p><p name="4890" id="4890" class="graf graf--p graf-after--p">You think they will make this dumb shit mistake??? Wtf are you???</p><p name="6211" id="6211" class="graf graf--p graf-after--p">I’m here to tell you that not only did they make this dumb shit mistake, they also profited from the tutorials that they sold you.</p><p name="d6d1" id="d6d1" class="graf graf--p graf-after--p">Here’s why. <strong class="markup--strong markup--p-strong">Binding is automatic.</strong></p><p name="ca27" id="ca27" class="graf graf--p graf-after--p">I’m going to first explain what a Model-View binding is: A mapping that binds model to view. Then whatever changes you made to the model is reflected automatically via binding to view. So you can just work with model and not worry about view.</p><p name="1ea1" id="1ea1" class="graf graf--p graf-after--p">Look at our reactor, can you tell me where the binding is?</p><pre name="d904" id="d904" class="graf graf--pre graf-after--p">struct ReactorView: View {<br>    @State var reactor = Reactor()<br>    @State var graphite = NotThere()<br>    var body: some View {Text(&quot;3.6 roentgen&quot;)}</pre><pre name="9423" id="9423" class="graf graf--pre graf-after--pre">}</pre><p name="9b49" id="9b49" class="graf graf--p graf-after--pre">Binding is a computed property, namely <code class="markup--code markup--p-code">body</code> . The one property required by View protocol.</p><p name="fc32" id="fc32" class="graf graf--p graf-after--p">A model-view binding, by definition, has a model side, and a view side. Now tell me where is model and where is view?</p><p name="7cf2" id="7cf2" class="graf graf--p graf-after--p">You think view is <code class="markup--code markup--p-code">ReactorView</code> ? It is <code class="markup--code markup--p-code">Text(&quot;3.6 roentgen&quot;)</code> .</p><p name="12bd" id="12bd" class="graf graf--p graf-after--p">You think there is no model, the whole thing is just a view? <code class="markup--code markup--p-code">ReactorView</code> is your model. Notice there are no reference type view objects like <code class="markup--code markup--p-code">UIView</code> in SwiftUI. Because you don’t need it! Remember when I say “you can just work with model and not worry about view&quot;? That’s the point of having a binding.</p><p name="e621" id="e621" class="graf graf--p graf-after--p">If you have the model, then you can compute the view. You’ll never get a direct reference type view object so you can’t abuse reference type like you did in UIKit.</p><p name="3763" id="3763" class="graf graf--p graf-after--p">This is easy as shit. Yes.</p><p name="5019" id="5019" class="graf graf--p graf-after--p">This is basic as shit. Yes.</p><p name="4b3a" id="4b3a" class="graf graf--p graf-after--p">Did any of the <strong class="markup--strong markup--p-strong">industry titans, influencers and skilled veterans </strong>tell you this in half of a decade after SwiftUI is released? No.</p><blockquote name="1dc2" id="1dc2" class="graf graf--blockquote graf-after--p">Our power comes from the perception of our power.</blockquote><p name="99d4" id="99d4" class="graf graf--p graf-after--blockquote">Since the binding is defined by <code class="markup--code markup--p-code">var body: some View</code> , it doesn’t matter if your observable is called view model or view controller. Neither of them do any binding. They publish and notify observer. That’s why as far as SDK concerned, they are all observables. Hence they are functionally equivalent.</p><h4 name="ec20" id="ec20" class="graf graf--h4 graf-after--p">It’s not 3 Roentgen it is 15000</h4><p name="dda1" id="dda1" class="graf graf--p graf-after--h4">You can tell SDK has built-in support for <code class="markup--code markup--p-code">ReactorView</code> to work as the model side of a model-view binding, because you have @EnvironmentObject, @State, @StateObject, @ObservedObject… etc there.</p><p name="d26a" id="d26a" class="graf graf--p graf-after--p">You don’t have those in an observable. Then you need to implement your own way to pass variables in, which defeats the purpose of dedicated SDK support. You would also mix local properties with shared properties. Not to mention you lose the protection of immutability. Again, did any of the <strong class="markup--strong markup--p-strong">industry titans, influencers and skilled veterans </strong>ever inform you<strong class="markup--strong markup--p-strong"> </strong>such trade-off anytime in the past 5 years?</p><p name="d7e1" id="d7e1" class="graf graf--p graf-after--p">So which is it? MVVM might not be applicable in SwiftUI or ViewModel = ViewController?</p><h4 name="7a56" id="7a56" class="graf graf--h4 graf-after--p">How does a RBMK reactor explode?</h4><p name="aaaa" id="aaaa" class="graf graf--p graf-after--h4">Let’s examine 3 of the top google results for “swiftui clean architecture‘.</p><p name="46b2" id="46b2" class="graf graf--p graf-after--p">No surprise. All view model-based. Because MVVM doesn’t require proof. Its power comes from the perception of its power. Put ViewModel in your object name, and you don’t need justification, explanation, or comparison.</p><ol class="postList"><li name="bc77" id="bc77" class="graf graf--li graf-after--p"><a href="https://paulallies.medium.com/clean-architecture-in-the-flavour-of-swiftui-5-5-8430786a83" data-href="https://paulallies.medium.com/clean-architecture-in-the-flavour-of-swiftui-5-5-8430786a83" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Clean Architecture in SwiftUI 5.5</a></li></ol><p name="fad1" id="fad1" class="graf graf--p graf-after--li">Rename view model to view controller. No justification as to why creating a sink object.</p><figure name="94ac" id="94ac" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*OjbkxDI9dFWBZN2ugULF2A.png" data-width="380" data-height="454" src="https://cdn-images-1.medium.com/max/800/1*OjbkxDI9dFWBZN2ugULF2A.png"></figure><p name="73af" id="73af" class="graf graf--p graf-after--figure">UseCase is dog shit. <code class="markup--code markup--p-code">CreateUser.swift</code> can be simplified to be a function. Same applies to all other UseCase files. If by clean you mean redundant boilerplate, then yes it is clean.</p><p name="cd31" id="cd31" class="graf graf--p graf-after--p">Networking should be on top level. By the looks of it, networking is not even in it. Clean architecture always focuses on presentation, when in fact you want presentation to be simply a function of state. Then focus on state management. And networking is the top 1 item in state management.</p><p name="f8f2" id="f8f2" class="graf graf--p graf-after--p">I selected this because a TODO example is well-known. Now do you think a TODO “clean architecture” need this many files? Let me guess you need a view model just for a fetch? And you can’t reuse that fetch because it’s coupled with view? This is why networking should be on top level, not subsidiary of a view model.</p><figure name="4cfd" id="4cfd" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*NwktcpzTLiIZIlNNE0wovg.png" data-width="711" data-height="578" src="https://cdn-images-1.medium.com/max/800/1*NwktcpzTLiIZIlNNE0wovg.png"></figure><p name="6a4b" id="6a4b" class="graf graf--p graf-after--figure">Ineffective use of protocol. First you are never going to need another TODO repository. Second it’s not like you can customize it via protocol. All you need is a function that gets you <code class="markup--code markup--p-code">[Todo]</code>. And since it’s async… that’s why networking should be top 1 in your toolbox. Look at these <strong class="markup--strong markup--p-strong">industry titans, influencers and skilled veterans. </strong>Then this function is implemented in value type… you never implement async function in value type because networking is stateful, and should be called from a dedicated reference type network service, which should be top 1 in your…</p><p name="232f" id="232f" class="graf graf--p graf-after--p">Dog shit. Makes no refactor sense. Extreme poor understanding of networking. Clean architecture is not just presentation.</p><p name="a050" id="a050" class="graf graf--p graf-after--p">2. <a href="https://nalexn.github.io/clean-architecture-swiftui/" data-href="https://nalexn.github.io/clean-architecture-swiftui/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Clean architecture for SwiftUI</a></p><p name="e8e3" id="e8e3" class="graf graf--p graf-after--p">All the usual dog shit. In fact I think most of people just copied this. So all the same problems.</p><p name="fab6" id="fab6" class="graf graf--p graf-after--p">But I want to mention this diagram:</p><figure name="7bbc" id="7bbc" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*osQRD8Thi696skEDK0jaLw.png" data-width="887" data-height="293" src="https://cdn-images-1.medium.com/max/800/1*osQRD8Thi696skEDK0jaLw.png"></figure><p name="93e5" id="93e5" class="graf graf--p graf-after--figure">Let me ask you this.</p><p name="2646" id="2646" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">What is the single responsibility of view model?</strong></p><p name="1f5a" id="1f5a" class="graf graf--p graf-after--p">It should be single responsibility, right?</p><p name="be9d" id="be9d" class="graf graf--p graf-after--p">Do you think it would be service wrapper or binding?</p><p name="ab95" id="ab95" class="graf graf--p graf-after--p">If it is service wrapper, then you suck. Rewrite your service.</p><p name="6c13" id="6c13" class="graf graf--p graf-after--p">If it is binding, then since binding is not defined in observable, there’s no point.</p><p name="62a0" id="62a0" class="graf graf--p graf-after--p">Either way, you can remove view model from this.</p><p name="fcc1" id="fcc1" class="graf graf--p graf-after--p">Redux is another topic on its own. But I’ll say centralized AppState is useless in iOS. You need <em class="markup--em markup--p-em">localized </em>AppState.</p><p name="dd30" id="dd30" class="graf graf--p graf-after--p">This diagram shows how much emphasis “clean architecture” have on presentation. Let me show you what it should be:</p><figure name="5698" id="5698" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*HJtc5oDpyhXnCOJRiAyHUg.png" data-width="510" data-height="402" src="https://cdn-images-1.medium.com/max/800/1*HJtc5oDpyhXnCOJRiAyHUg.png"><figcaption class="imageCaption">Cleaner architecture</figcaption></figure><p name="c9cf" id="c9cf" class="graf graf--p graf-after--figure">Model-view are two sides of the same coin. It may seem confusing first. Think of it as light, which is both particle and wave. But you only get to access model side because view side is a computed property.</p><p name="1216" id="1216" class="graf graf--p graf-after--p">Control, or state management, is the name of the game, with dedicated networking service.</p><p name="0fe9" id="0fe9" class="graf graf--p graf-after--p">Presentation? Who gives a shit. That’s right. The whole SDK is built around presentation already. Get your binding right, get your state right, then your view is right. Most of the presentation should be computed properties anyway.</p><p name="9c48" id="9c48" class="graf graf--p graf-after--p">Repository? Who gives a shit. That’s right. If you know how to construct a highly refactored network service, you know how to construct the rest. And it will be a lot simpler than what these <strong class="markup--strong markup--p-strong">industry titans, influencers and skilled veterans </strong>told you in tutorials. That’s why networking should be top 1 in your…</p><p name="5983" id="5983" class="graf graf--p graf-after--p">I’d even go so far as to say, you build around networking, not presentation, which is fixed by SDK. There are two things you won’t find in any MVVM tutorial: why view model is not a sink object without SDK support; and why not refactor out functions instead of model. For example, instead of moving model to an external sink object, you can refactor out <code class="markup--code markup--p-code">var body: some View</code>, just open a new file and add View conformance in it.</p><h4 name="c779" id="c779" class="graf graf--h4 graf-after--p">What is the cost of lies?</h4><p name="1c4e" id="1c4e" class="graf graf--p graf-after--h4">I’m going to wrap up with the third example that I want to talk about.</p><p name="afa6" id="afa6" class="graf graf--p graf-after--p">3. <a href="https://github.com/nalexn/clean-architecture-swiftui" data-href="https://github.com/nalexn/clean-architecture-swiftui" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Clean architecture for SwiftUI + Combine</a></p><p name="0194" id="0194" class="graf graf--p graf-after--p">This is a github link. I infer from the name of the contributor that the author is the same guy as example 2. It contains a similar diagram:</p><figure name="c780" id="c780" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*_Olvsar3fRXQ9vpTGBkylw.png" data-width="879" data-height="432" src="https://cdn-images-1.medium.com/max/800/1*_Olvsar3fRXQ9vpTGBkylw.png"></figure><p name="eec9" id="eec9" class="graf graf--p graf-after--figure">View model is gone! The last update is June 2022.</p><p name="1534" id="1534" class="graf graf--p graf-after--p">This is purely a speculation, but my guess is that <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">he knew</em></strong>.</p><p name="0559" id="0559" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">You don’t need view model. Because you can’t and don’t need to define binding there.</strong></p><p name="0481" id="0481" class="graf graf--p graf-after--p">(or you can ask why it is view that holds reference to view model, not the other way around)</p><p name="d427" id="d427" class="graf graf--p graf-after--p">This diagram from left to right: model with view state, state control, model with state. You think SwiftUI is built on view model? I see it as MVC with binding. Does MVVM ever tell you anything about state management?</p><p name="26cd" id="26cd" class="graf graf--p graf-after--p">I’m going to close with this quote, explaining why I bother to write this shit</p><blockquote name="92bc" id="92bc" class="graf graf--blockquote graf-after--p graf--trailing"><strong class="markup--strong markup--blockquote-strong">You’ll do it because it must be done. You’ll do it because nobody else can. And if you don’t, millions will write dumb shit. If you tell me that’s not enough, I won’t believe you.</strong></blockquote></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/2dc8f23eb7ed"><time class="dt-published" datetime="2022-08-20T17:20:46.291Z">August 20, 2022</time></a>.</p><p><a href="https://medium.com/@swift2931/massive-view-controller-a-k-a-view-model-in-swiftui-2dc8f23eb7ed" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>