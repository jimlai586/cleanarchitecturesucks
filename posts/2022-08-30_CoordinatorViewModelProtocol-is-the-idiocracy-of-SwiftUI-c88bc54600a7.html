<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>CoordinatorViewModelProtocol is the idiocracy of SwiftUI</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">CoordinatorViewModelProtocol is the idiocracy of SwiftUI</h1>
</header>
<section data-field="subtitle" class="p-summary">
Mastering the art of over-generalization
</section>
<section data-field="body" class="e-content">
<section name="b7fb" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="31cd" id="31cd" class="graf graf--h3 graf--leading graf--title">CoordinatorViewModelProtocol is the idiocracy of SwiftUI</h3><p name="1058" id="1058" class="graf graf--p graf-after--h3">Mastering the art of over-generalization</p><figure name="3f95" id="3f95" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Jy-vS4ln686VyAv28ctcEQ.jpeg" data-width="691" data-height="389" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*Jy-vS4ln686VyAv28ctcEQ.jpeg"></figure><h4 name="c442" id="c442" class="graf graf--h4 graf-after--figure">The idiocracy</h4><p name="7b9b" id="7b9b" class="graf graf--p graf-after--h4">If I tell people that I write MVC, people think I write massive view controller.</p><p name="1beb" id="1beb" class="graf graf--p graf-after--p">But if I tell people I write clean architecture + MVVM + Coordinator…</p><figure name="5344" id="5344" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*BBkRLawr8fXTtdGv4Mo55g.jpeg" data-width="400" data-height="276" src="https://cdn-images-1.medium.com/max/800/1*BBkRLawr8fXTtdGv4Mo55g.jpeg"></figure><p name="e5e0" id="e5e0" class="graf graf--p graf-after--figure">The iOS developer road map in 2022 is as follows:</p><p name="f9e8" id="f9e8" class="graf graf--p graf-after--p">Day1: hello world</p><p name="318a" id="318a" class="graf graf--p graf-after--p">Day2: google MVVM</p><p name="e2bf" id="e2bf" class="graf graf--p graf-after--p">Day3: google clean architecture</p><p name="a1bc" id="a1bc" class="graf graf--p graf-after--p">Day4: google MVVM+C</p><p name="45aa" id="45aa" class="graf graf--p graf-after--p">Day5: publish tutorials on applying MVVM+C to SwiftUI, not because of refactor reasons, but just for the sake of writing design pattern</p><p name="a8bb" id="a8bb" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">(Days spent on learning SwiftUI and refactor: 0)</em></p><p name="575a" id="575a" class="graf graf--p graf-after--p">This article <a href="https://pedroalvarez-29395.medium.com/swiftui-coordinators-a27c2c9d701f" data-href="https://pedroalvarez-29395.medium.com/swiftui-coordinators-a27c2c9d701f" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">SwiftUI Coordinators</a> published under <strong class="markup--strong markup--p-strong">“better programming” </strong>demonstrates this process. It’s full of anti-patterns, nonsensical and redundant designs, over-generalization and boilerplate.</p><p name="cf46" id="cf46" class="graf graf--p graf-after--p">The only reason it can be published under <strong class="markup--strong markup--p-strong">“better programming” </strong>is because it has the word MVVC+C in it. Obviously this guy isn’t the only one. I’m using this one to showcase the<strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em"> </em></strong><em class="markup--em markup--p-em">idiotic Swift</em> that is common in the industry.</p><h4 name="cead" id="cead" class="graf graf--h4 graf-after--p">What’s the refactor reason?</h4><blockquote name="e185" id="e185" class="graf graf--blockquote graf-after--h4">We desire to do the same with SwiftUI, but problem is that in this framework everything regarding UI is declarative and we deal with value types(structs). So <strong class="markup--strong markup--blockquote-strong">we cannot have a reference that we can directly ask to change context</strong></blockquote><p name="7d9a" id="7d9a" class="graf graf--p graf-after--blockquote">This implies MVVM+C has a reference that you can directly ask to change context. Isn’t this the kind of abuse we want to avoid by introducing a value-type based SDK? And now he desires to do the same.</p><p name="95c2" id="95c2" class="graf graf--p graf-after--p">This alone should raise alerts. The underlying tone should not be “going around this obstacle”, because it almost guarantees a shady solution in which you implicitly trigger side effects without view owner knowing it.</p><p name="b3c5" id="b3c5" class="graf graf--p graf-after--p">What you should do, if your intention is not pumping buzzwords, is to rephrase your requirement in the context of SwiftUI. E.g.;</p><ol class="postList"><li name="13f0" id="13f0" class="graf graf--li graf-after--p">I need a centralized navigation control, which is stateful, which means it needs to be shared across some part of view hierarchy.</li><li name="a072" id="a072" class="graf graf--li graf-after--li">Must be @ObservedObject, more likely an @EnvironmentObject.</li><li name="6641" id="6641" class="graf graf--li graf-after--li">Design views that <strong class="markup--strong markup--li-strong">explicitly </strong>observes it.</li></ol><p name="8a75" id="8a75" class="graf graf--p graf-after--li">Now think about what a shady solution might look like?</p><p name="0903" id="0903" class="graf graf--p graf-after--p">Views won’t know they are observing a coordinator. Then obviously there’s going to be a middle man. This middle man has to publish again whatever coordinator has to publish. If SwiftUI automatically does this for you, you risk implicit nested publisher if not redundant wrapper, if SwiftUI does not do this for you, you write boilerplate and nested publisher. On top of that, you have to justify it not violating single responsibility principle.</p><p name="9530" id="9530" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">You should prefer explicit reference and flat structure</strong>. These are the refactor reasons you want to discuss first and foremost.</p><p name="02fc" id="02fc" class="graf graf--p graf-after--p">Obviously the author forego all these discussions. His focus is to build a MVVM+C in SwiftUI. All MVVM pumpers ignore refactor reasons. Because if you do, you will realize there’s no reason creating view model at all in SwiftUI. Building design patterns on view models that have no reasons to exist is like building a house on sand.</p><h4 name="c924" id="c924" class="graf graf--h4 graf-after--p">House built on sand</h4><blockquote name="ff7c" id="ff7c" class="graf graf--blockquote graf-after--h4">And everyone who hears these words of mine and does not do them will be like a foolish man who built his house on the sand. Matthew 7:24</blockquote><figure name="37d2" id="37d2" class="graf graf--figure graf-after--blockquote"><img class="graf-image" data-image-id="1*Q3M1JMyTwAFz5gX5jKgoZw.png" data-width="775" data-height="493" src="https://cdn-images-1.medium.com/max/800/1*Q3M1JMyTwAFz5gX5jKgoZw.png"></figure><p name="b934" id="b934" class="graf graf--p graf-after--figure">This structure is for <strong class="markup--strong markup--p-strong">every view</strong>. This design makes no sense because it defeats the purpose of having a <strong class="markup--strong markup--p-strong">centralized </strong>coordinator. Oh shit, MVVM+C in UIKit has a coordinator per view controller isn’t it? God damn that is some dumb shit. Coordinator has be on the scope above views, so it can coordinate between views. In UIKit you can kind of get away with it because you can get <code class="markup--code markup--p-code">UINavigationController</code>reference from <code class="markup--code markup--p-code">UIViewController</code> .</p><p name="73cb" id="73cb" class="graf graf--p graf-after--p">So instead of creating a shared coordinator, the dude injects <code class="markup--code markup--p-code">CoordinatorViewModel</code> to every view. Wait, why is it a view model? This creates a coupling between coordinator and a view that doesn’t need to be there! Even in UIKit, coordinator doesn’t have its own view, because it doesn’t need to. It manages controllers which have their own view. The key word is <em class="markup--em markup--p-em">manage</em>, not view.</p><p name="a7bc" id="a7bc" class="graf graf--p graf-after--p">This highlights a common problem of <em class="markup--em markup--p-em">idiotic Swift</em>. You can’t have regular shared service and state machines anymore. You can only have view model which implies you need to have a view.</p><p name="df35" id="df35" class="graf graf--p graf-after--p">In this case, if you observe <code class="markup--code markup--p-code">Coordinator</code> directly,</p><pre name="fb09" id="fb09" class="graf graf--pre graf-after--p">@EnvironmentObject var coo: Coordinator<br>@ObservedObject var vm = ViewModel()</pre><p name="311d" id="311d" class="graf graf--p graf-after--pre">Then people will ask if you can put properties outside of view model, what’s the point of putting everything in view model? Especially you get to use @EnvironmentObject outside but not inside of an observable. Then the Ponzi collapses, because there is no point of putting everything in a sink object in the first place. View model does everything including networking, coordinating… except binding, the one thing it is supposed to do.</p><p name="eab1" id="eab1" class="graf graf--p graf-after--p">So somehow the dude turned a service design into view design. The <code class="markup--code markup--p-code">Coordinator</code> is dead at this point. It is way easier to just navigate using SDK since a view has to handle its own navigation anyway. You might as well use specific type instead of type-erased <code class="markup--code markup--p-code">some View</code> to gain benefits of static type checks.</p><p name="b6fe" id="b6fe" class="graf graf--p graf-after--p">Not to mention, you are now writing 2 view models per view!</p><p name="344f" id="344f" class="graf graf--p graf-after--p">Any dev with self-respect will stop at this point. Something must be wrong besides being a dog shit design.</p><p name="e3bb" id="e3bb" class="graf graf--p graf-after--p">But no, MVVM got electrolytes. It’s what plants crave.</p><p name="0094" id="0094" class="graf graf--p graf-after--p">Do the opposite of what is right, this is <strong class="markup--strong markup--p-strong">“better programming”</strong>. So instead of fixing these design problems, the dude is going to focus on generalizing the view model which has nothing to do with functionalities of <code class="markup--code markup--p-code">Coordinator</code>.</p><h4 name="4f90" id="4f90" class="graf graf--h4 graf-after--p">The art of over-generalization</h4><figure name="253f" id="253f" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*sA2qsb7tUuVvwRlmFev0qA.png" data-width="653" data-height="175" src="https://cdn-images-1.medium.com/max/800/1*sA2qsb7tUuVvwRlmFev0qA.png"></figure><p name="4a90" id="4a90" class="graf graf--p graf-after--figure">Let’s take a moment to appreciate this gem. This is art.</p><p name="7a09" id="7a09" class="graf graf--p graf-after--p">First you need to create a <code class="markup--code markup--p-code">coordinator</code> which is a view model that conforms to <code class="markup--code markup--p-code">Scene1CoordinatorViewModelProtocol</code>.</p><p name="a6c9" id="a6c9" class="graf graf--p graf-after--p">Then you pass it to initialize another view model.</p><p name="fbc2" id="fbc2" class="graf graf--p graf-after--p">Then you pass this view model as a generic parameter to initialize a view.</p><p name="1ac0" id="1ac0" class="graf graf--p graf-after--p">The process is so tedious you have to build a factory to generate it. And to build this factory you need a <code class="markup--code markup--p-code">enum</code> type first.</p><p name="2a42" id="2a42" class="graf graf--p graf-after--p">Now consider that you want to use a different view model which uses a different network service.</p><p name="8f4a" id="8f4a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">None of this shit works.</strong></p><p name="21ce" id="21ce" class="graf graf--p graf-after--p">And notice the <code class="markup--code markup--p-code">Scene1</code> prefix. This static factory function is dependent on a particular view, for a particular view, and should be static function for that view. You are now writing 2 view models and n factory methods plus 1 enum type for<strong class="markup--strong markup--p-strong"> every view</strong>. And none of that shit works unless you write more view model types(e.g.; <code class="markup--code markup--p-code">Scene1ViewModel2</code>) and factory methods.</p><p name="e73b" id="e73b" class="graf graf--p graf-after--p">Are you ever going to swap out for a different coordinator? Unlikely.</p><p name="5890" id="5890" class="graf graf--p graf-after--p">How often do you swap out for a different view model? Rarely. You should at least try to design view model to be somewhat configurable.</p><p name="81e1" id="81e1" class="graf graf--p graf-after--p">All this generalization for something you rarely need, and when you need it, you have to hard-coded it in view-specific factory method anyway!</p><p name="5d82" id="5d82" class="graf graf--p graf-after--p">Let me get this straight, not only did this dude write such anti-pattern, he gets to publish it in <strong class="markup--strong markup--p-strong">“better programming” </strong>as tutorial, and he gets you to think this is a good idea?</p><p name="4831" id="4831" class="graf graf--p graf-after--p">Oh shit, I haven’t even got to the good part.</p><h4 name="b7f8" id="b7f8" class="graf graf--h4 graf-after--p">Idiotic Swift</h4><p name="1085" id="1085" class="graf graf--p graf-after--h4">As in whatever complete opposite of idiomatic Swift.</p><p name="ebf4" id="ebf4" class="graf graf--p graf-after--p">Exhibit A:</p><figure name="1602" id="1602" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*rY1zwZJk1bcGeqMT2dEMIg.png" data-width="453" data-height="156" src="https://cdn-images-1.medium.com/max/800/1*rY1zwZJk1bcGeqMT2dEMIg.png"></figure><p name="31f3" id="31f3" class="graf graf--p graf-after--figure">This is your house built on sand. This is the culmination of anti-patterns.</p><p name="9979" id="9979" class="graf graf--p graf-after--p">These things have to happen for you to arrive at this:</p><ol class="postList"><li name="d0ff" id="d0ff" class="graf graf--li graf-after--p">You lack of basic understanding of SwiftUI, model-view binding in particular, you work with model side of a model-view binding. View side is computed property, so every diagram is wrong.</li><li name="40ce" id="40ce" class="graf graf--li graf-after--li">You need to buy in that dumping everything into a sink object is a good idea</li><li name="0429" id="0429" class="graf graf--li graf-after--li">You fail to see putting model in reference type defeats the purpose of value type based view hierarchy</li><li name="ffc3" id="ffc3" class="graf graf--li graf-after--li">You tried to re-create MVVM+C in SwiftUI for buzzwords.</li><li name="a50c" id="a50c" class="graf graf--li graf-after--li">Somehow you decided a coordinator coupled with view on per-view basis is the best way to do this</li><li name="9fab" id="9fab" class="graf graf--li graf-after--li">You fell into the trap of over-generalization. So your view has generic parameters complete with hard-coded factory methods.</li><li name="ae9c" id="ae9c" class="graf graf--li graf-after--li">None of these shit fix any design problems of Coordinator</li><li name="603f" id="603f" class="graf graf--li graf-after--li">Finally you need type-erased protocol otherwise generics won’t compile; You have to have a view model, and to pass it as generic parameter you need type-erased protocol. In other words, you have no choice, not because this is a protocol-oriented design choice.</li></ol><p name="7b38" id="7b38" class="graf graf--p graf-after--li">Form over substance.</p><p name="dbee" id="dbee" class="graf graf--p graf-after--p">View model protocol is dumb shit because view model is dumb shit. And the fact that you need such a protocol suggests you are over-generalizing, which is dumb shit.</p><p name="cb32" id="cb32" class="graf graf--p graf-after--p graf--trailing">The idiotic Swift.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/c88bc54600a7"><time class="dt-published" datetime="2022-08-30T05:16:55.623Z">August 30, 2022</time></a>.</p><p><a href="https://medium.com/@swift2931/coordinatorviewmodelprotocol-is-the-idiocracy-of-swiftui-c88bc54600a7" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>