<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Mission Impossible: A MVC SwiftUI</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Mission Impossible: A MVC SwiftUI</h1>
</header>
<section data-field="subtitle" class="p-summary">
Your mission, should you choose to accept it
</section>
<section data-field="body" class="e-content">
<section name="77e3" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="c746" id="c746" class="graf graf--h3 graf--leading graf--title">Mission Impossible: A MVC SwiftUI</h3><figure name="47d4" id="47d4" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*B5Eba4HYCzBzwvMsDWx_aQ.jpeg" data-width="337" data-height="500" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*B5Eba4HYCzBzwvMsDWx_aQ.jpeg"><figcaption class="imageCaption">Ghost protocol poster on IMDB</figcaption></figure><h4 name="7882" id="7882" class="graf graf--h4 graf-after--figure">Your mission, should you choose to accept it</h4><blockquote name="73f3" id="73f3" class="graf graf--blockquote graf-after--h4"><strong class="markup--strong markup--blockquote-strong">We proved that this architecture is</strong> <strong class="markup--strong markup--blockquote-strong">impossible </strong>to be implemented in SwiftUI due to its declarative nature relying totally on value types. If any of you readers can prove I am wrong and there is actually a way of designing an <strong class="markup--strong markup--blockquote-strong">MVC</strong> across SwiftUI just comment on this article and I will be happy to learn something new.</blockquote><p name="8a42" id="8a42" class="graf graf--p graf-after--blockquote">A quote from <a href="https://betterprogramming.pub/swiftui-why-mvc-architecture-became-totally-inviable-aeeab4570d79" data-href="https://betterprogramming.pub/swiftui-why-mvc-architecture-became-totally-inviable-aeeab4570d79" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Why the MVC Architecture is Impossible to Implement in SwiftUI?</a></p><p name="48d0" id="48d0" class="graf graf--p graf-after--p">Well, lucky for him. I happen to be an IMF (Impossible MVC Force) agent.</p><p name="1b1d" id="1b1d" class="graf graf--p graf-after--p">But why leave a comment that he can delete and block me when I can post an article meme-ing about it?</p><p name="f395" id="f395" class="graf graf--p graf-after--p">I remember this guy, because I wrote a code review about his work before.</p><p name="e183" id="e183" class="graf graf--p graf-after--p"><a href="https://swift2931.medium.com/coordinatorviewmodelprotocol-is-the-idiocracy-of-swiftui-c88bc54600a7" data-href="https://swift2931.medium.com/coordinatorviewmodelprotocol-is-the-idiocracy-of-swiftui-c88bc54600a7" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">CoordinatorViewModelPorotocol is the idiotcracy of SwiftUI</a>.</p><p name="8ad4" id="8ad4" class="graf graf--p graf-after--p">I guess he never got to read to it otherwise I’ll be blocked by now. Usually the larger following a MVVM dev have, the faster he blocks me. I once got blocked for commenting why he thinks it’s OK to have fetch code in view model. That should give you hints on the dog-shit-ness of MVVM with which we are about to uncover.</p><p name="9d30" id="9d30" class="graf graf--p graf-after--p">As the last surviving memeber of IMF, disowned by my agency, I’ll accept this mission impossible.</p><h4 name="7e3b" id="7e3b" class="graf graf--h4 graf-after--p">The president has invoked protocol Ghost</h4><figure name="007d" id="007d" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*C0jazGl4GJdHiaRRWUX8bw.png" data-width="693" data-height="187" src="https://cdn-images-1.medium.com/max/800/1*C0jazGl4GJdHiaRRWUX8bw.png"></figure><p name="08c7" id="08c7" class="graf graf--p graf-after--figure">Let’s use his interpretation of MVC as a starting point.</p><p name="750e" id="750e" class="graf graf--p graf-after--p">Note the arrow &lt;- from Model to Controller.</p><p name="dadf" id="dadf" class="graf graf--p graf-after--p">Model is passive, there’s no event to send. If you define an “event” and give it a callback, it becomes a delegate object, which might induce state, which in turn shifts it from value type model object to reference type delegate object.</p><p name="bb4c" id="bb4c" class="graf graf--p graf-after--p">The simplest you can do with a value type model is to attach a property observer; Model doesn’t know anything about it. This diagram does not consider the distinction between value type and reference type.</p><p name="1bbf" id="1bbf" class="graf graf--p graf-after--p">For a MVC dev, the diagram can be described as</p><pre name="f2a5" id="f2a5" class="graf graf--pre graf-after--p">// set up view delegate, dataSource<br>// which will mutate model</pre><pre name="f7dd" id="f7dd" class="graf graf--pre graf-after--pre">var model = Model() { didSet {updateUI()}}</pre><p name="0145" id="0145" class="graf graf--p graf-after--pre">Note that this effectively establishes a model -&gt; view binding.</p><p name="a291" id="a291" class="graf graf--p graf-after--p">Whenever model changes, view changes.</p><p name="e72c" id="e72c" class="graf graf--p graf-after--p">This binding is important, because SwiftUI introduces model-view binding support. As usual, none of these are shown in the diagram. This is the reason why every MVVM tutorial comes with colorful diagrams yet fail spectacularly.</p><p name="4a03" id="4a03" class="graf graf--p graf-after--p">So what might a MVC SwiftUI look like?</p><p name="c549" id="c549" class="graf graf--p graf-after--p">I will say SwiftUI is already MVC; MVC doesn’t mean you must have objects called “controller”. This is a hard concept for MVVM devs to understand, because of their ritualistic worship of the word “view model”; hence their insistance on having an object called view model under any circumstances. If you can accept that you don’t need an object called “controller” to be qualified as MVC, then you can accept that you don’t need an object called “view model” to be qualified as MVVM. Only then can you start to appreciate the fact that you don’t do design pattern for the sake of doing design pattern. You do it for the refactor directions implied by the design pattern.</p><p name="a84c" id="a84c" class="graf graf--p graf-after--p">Note that this dude manually added view model, yet pretended they are built-in by the SDK. The vanilla SDK comes with observable support, namely <code class="markup--code markup--p-code">ObservableObject</code> ; but SDK didn’t require you to put everything in one observable. In fact, SDK wants you to use @State, @EnvironmentObject … etc for different use cases.</p><p name="3469" id="3469" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Control, is not an object. State can be described by object. State mutation is done by <em class="markup--em markup--p-em">functions</em>. Control is the combination of function and state.</strong></p><p name="1759" id="1759" class="graf graf--p graf-after--p">With this in mind, let’s examine vanilla SwiftUI. Where’s control?</p><p name="1a32" id="1a32" class="graf graf--p graf-after--p">Do you have state? Yes. Marked by the big red keyword @State.</p><p name="e344" id="e344" class="graf graf--p graf-after--p">Do you have functions, or <em class="markup--em markup--p-em">state mutations</em>? Of course.</p><p name="5254" id="5254" class="graf graf--p graf-after--p">Then you have MVC!</p><figure name="7183" id="7183" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*l6NDqDyG6-70VP6kd3mKNw.jpeg" data-width="228" data-height="221" src="https://cdn-images-1.medium.com/max/800/1*l6NDqDyG6-70VP6kd3mKNw.jpeg"><figcaption class="imageCaption">Control is not an object</figcaption></figure><p name="1040" id="1040" class="graf graf--p graf-after--figure">MVC represents a <em class="markup--em markup--p-em">refactor</em>. View is special enough, you want to refactor it out. Use model as state, then build control via functions.</p><p name="22e1" id="22e1" class="graf graf--p graf-after--p">Obviously by this definition, everything will be MVC. Well, yes, that’s why it’s a fundamental design pattern. Does MVVM not have Control? Of course it has. It hides under view model. Over time MVVM devs just treat Control as &quot;view model&quot;, an object, which is later refactored out to be “interactor”, still an object.</p><p name="1016" id="1016" class="graf graf--p graf-after--p">But where’s the fun in that? Let’s say you need a <em class="markup--em markup--p-em">Controller </em>object.</p><h4 name="4eb8" id="4eb8" class="graf graf--h4 graf-after--p">Light the fuse</h4><p name="b9d6" id="b9d6" class="graf graf--p graf-after--h4">Since SwiftUI has binding support. I’m going to use binding support. There’s no rule that binding as a language feature is exclusive to MVVM, right?</p><pre name="3aa7" id="3aa7" class="graf graf--pre graf-after--p">class ViewController {<br>    var model = Model()<br>}</pre><p name="41e2" id="41e2" class="graf graf--p graf-after--pre">Now we need to handle UI events from view and update view from model changes.</p><p name="6c5a" id="6c5a" class="graf graf--p graf-after--p">Let’s say this view controller has views A, B. In the same way we set <code class="markup--code markup--p-code">tableView.delegate = viewController</code> , we set the delegate in A, B like</p><pre name="73ea" id="73ea" class="graf graf--pre graf-after--p">struct A: View {<br>    @EnvironmentObject var vc: ViewController<br>}</pre><p name="3579" id="3579" class="graf graf--p graf-after--pre">where <code class="markup--code markup--p-code">ViewController</code> instance is created and owned by some top level object and is passed down as an environment object. I don’t want to waste time creating initializers and pass it down level by level when you have SDK support to simplify the process.</p><p name="ff69" id="ff69" class="graf graf--p graf-after--p">But since A is a value type, that means <code class="markup--code markup--p-code">viewController</code> cannot have a reference to this view! It can only have a copy!</p><p name="af96" id="af96" class="graf graf--p graf-after--p">This is where publisher-observer pattern kicks in. SDK only allows you to publish stuff to whoever observes it. So you can’t abuse a view reference; you can only communicate using a pre-defined path, without knowing who is observing. So view controller becomes</p><pre name="0a20" id="0a20" class="graf graf--pre graf-after--p">class ViewController: ObservableObject {<br>    @Published var model = Model()<br>}</pre><p name="67cf" id="67cf" class="graf graf--p graf-after--pre">You have no choice. <em class="markup--em markup--p-em">No plan, no back up, no choice.</em></p><p name="3857" id="3857" class="graf graf--p graf-after--p">Yet … <em class="markup--em markup--p-em">mission accomplished</em>.</p><p name="36db" id="36db" class="graf graf--p graf-after--p">We’ve setup view event observing and @Published doubles as view updater and property observer. This is the diagram right here in case you forgot:</p><figure name="3783" id="3783" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*C0jazGl4GJdHiaRRWUX8bw.png" data-width="693" data-height="187" src="https://cdn-images-1.medium.com/max/800/1*C0jazGl4GJdHiaRRWUX8bw.png"></figure><p name="9492" id="9492" class="graf graf--p graf-after--figure">So what’s the problem? Seems like a mission <em class="markup--em markup--p-em">plausible </em>to me.</p><h4 name="2179" id="2179" class="graf graf--h4 graf-after--p">You mind telling me what you were doing in a Russian prison?</h4><p name="51bd" id="51bd" class="graf graf--p graf-after--h4">Let’s compare what we’ve done so far to that of … well, Russian prison.</p><figure name="c43b" id="c43b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*kXTPUScV0ZVMsrliq22X7Q.png" data-width="700" data-height="530" src="https://cdn-images-1.medium.com/max/800/1*kXTPUScV0ZVMsrliq22X7Q.png"></figure><p name="8329" id="8329" class="graf graf--p graf-after--figure">He is trying to replicate a <code class="markup--code markup--p-code">viewController</code> in UIKit to SwiftUI.</p><p name="0aaf" id="0aaf" class="graf graf--p graf-after--p">He uses Binding to get around value type, which should raise red flag.</p><p name="c08d" id="c08d" class="graf graf--p graf-after--p">And since <code class="markup--code markup--p-code">ContentView</code>is value type, <code class="markup--code markup--p-code">view</code> is a local copy. This binding won’t update the actual “view”.</p><p name="d2bc" id="d2bc" class="graf graf--p graf-after--p">You can predict his conclusions miles away just from this snippet:</p><blockquote name="e4e3" id="e4e3" class="graf graf--blockquote graf-after--p">As you can see, the two labels are not being updated and there is a simple reason for that: The views we are “referencing” inside our Controller are not reference types</blockquote><p name="9906" id="9906" class="graf graf--p graf-after--blockquote">Duh. Because you ignore mechanisms of SwiftUI to make a UIKit view controller. Technically he isn’t wrong in this statement, except possibly the fact that he passes <code class="markup--code markup--p-code">.constant</code> as binding in</p><figure name="dbd4" id="dbd4" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*5hfzUsDrs8ZNIEjAnjOr-g.png" data-width="444" data-height="39" src="https://cdn-images-1.medium.com/max/800/1*5hfzUsDrs8ZNIEjAnjOr-g.png"></figure><p name="c1db" id="c1db" class="graf graf--p graf-after--figure">which would make this binding… constant. Double whammy. You would think <em class="markup--em markup--p-em">better programming</em> should have an editor or something so they don’t publish something with this kind of mistakes.</p><p name="9813" id="9813" class="graf graf--p graf-after--p">That which is wrong is what he draws from this statement.</p><blockquote name="46cd" id="46cd" class="graf graf--blockquote graf-after--p">We proved that this architecture is <strong class="markup--strong markup--blockquote-strong">impossible </strong>to be implemented in SwiftUI due to its declarative nature relying totally on value types.</blockquote><p name="eacd" id="eacd" class="graf graf--p graf-after--blockquote">Well, I just did it. Super Easy, Barely an Inconvenience.</p><p name="6e25" id="6e25" class="graf graf--p graf-after--p">Now it’s my turn to draw some conclusions.</p><h4 name="661e" id="661e" class="graf graf--h4 graf-after--p">The four of us and the contents of this car are all that remains of the IMF</h4><p name="7e97" id="7e97" class="graf graf--p graf-after--h4">In my design, views A, B share a controller.</p><p name="ac2d" id="ac2d" class="graf graf--p graf-after--p">If we make a special case, and let each view has its own view controller. Instead of @EnvironmentObject, we use @ObservedObject; and we put everything in respective view controller for no reason. Guess what we have?</p><p name="2d11" id="2d11" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">MVVM.</strong></p><p name="f51a" id="f51a" class="graf graf--p graf-after--p">This is what happens when you rely on colorful diagrams without SDK context, instead of building around SDK features.</p><p name="d83a" id="d83a" class="graf graf--p graf-after--p">This also echoes the previou discussion that SwiftUI is MVC, with or without controller. In fact, you should notice the similarities between what I do with property observer and @Published in SwiftUI. SwiftUI is a syntax sugar of the same process in UIKit (Swift, not Objc).</p><p name="5ea9" id="5ea9" class="graf graf--p graf-after--p">Remember the discussion that for a MVX pattern, you don’t actually need objects M, V, and X?</p><p name="706c" id="706c" class="graf graf--p graf-after--p">SwiftUI is a working example. You can have functionalities of a view model without ritualistically creating a view model for every view. SDK gives you better flexibility, the same way you can have functionalities of a view controller without creating a view controller for every view. It generalizes and extends beyond these concepts over a decade long of experiences. MVVM is not new. I’ve seen the same shit a decade ago. After a language change followed by a SDK re-design from scratch, don’t you think it’s time for some new shit?</p><p name="3b61" id="3b61" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Perhaps the most ironic part of all. MVVM in SwiftUI does exactly like what you do with a massive view controller: create a sink object, and dump everything to it, for every view. I write better MVVM codes without view model, and MVVM devs write dog shit MVC codes disguised as view model.</strong></p><p name="230b" id="230b" class="graf graf--p graf-after--p">Speaking of dog shit, let’s look at an example.</p><figure name="9d0a" id="9d0a" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*YpMacYdyoMGJLhJ3uCCy4Q.png" data-width="729" data-height="243" src="https://cdn-images-1.medium.com/max/800/1*YpMacYdyoMGJLhJ3uCCy4Q.png"></figure><p name="5678" id="5678" class="graf graf--p graf-after--figure">This is dog shit in MVC standards. (he did it in MVVM too)</p><p name="45e3" id="45e3" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">build</code> is global, you can call it from anywhere. It may start as a refactor since the setup is too tedious, which should raise all red flags. That means you risk over-generalization or breaking of encapsulation.</p><p name="4102" id="4102" class="graf graf--p graf-after--p">But being a MVVM dev, design pattern &gt;&gt;&gt;&gt; refactor. If you pay attention, this is actually GMVC. G stands for Global, or God. So named because there’s a global scope, or God, governing the creation of MVC. <code class="markup--code markup--p-code">ContentController</code> here is being controlled! By God! It doesn’t control shit!</p><p name="0cc1" id="0cc1" class="graf graf--p graf-after--p">Everything has to be injected, nobody has knowledge of anything. So God has to orchestrate everything. The real controller is <code class="markup--code markup--p-code">build</code> , a function! Over-generalization is dog shit. There’s no reason for him to do this because there are no type-erase protocols, which is dog shit too because most of the time you are not going to pass in another type except mocking, which is dog shit too because mocking should be designed as light-weight as possible not something you have to declare a whole set of types that require further generalization of production code on top of being orchestrated by God.</p><p name="cde6" id="cde6" class="graf graf--p graf-after--p">In this case <code class="markup--code markup--p-code">controller</code> is local, but somehow its view got returned. So why do you need this <code class="markup--code markup--p-code">controller</code> ? Either this is not production code or there could be side effects from <code class="markup--code markup--p-code">controller.view = view</code> via property observer. This is some dog shit. No caller other than him knows how to initialize these shit properly.</p><p name="81de" id="81de" class="graf graf--p graf-after--p">I could go on, but I think I’ve made my point. There are more than 100 claps for this article, which I hope they are all from his friends, and are not from serious iOS developers.</p><p name="7a3e" id="7a3e" class="graf graf--p graf-after--p">Oh shit, speaking of which. There’s a VIP in comment section with over 10K followers and decades of experiences. Quote:</p><blockquote name="d1da" id="d1da" class="graf graf--blockquote graf-after--p">You&#39;re not wrong, but you went an awfully long way to get there.</blockquote><blockquote name="a9e4" id="a9e4" class="graf graf--blockquote graf-after--blockquote">Bottom line is that MVC-style delegation won&#39;t work in SwiftUI not because &quot;views&quot; are not reference types, but because in SwiftUI &quot;views&quot; are not views in the way we used to think of them in UIKit</blockquote><p name="268f" id="268f" class="graf graf--p graf-after--blockquote">Obviously he is wrong for saying <em class="markup--em markup--p-em">“you’re not wrong”</em>. But his reasoning seems right, while my arguments seem right too. So who is right?</p><p name="2089" id="2089" class="graf graf--p graf-after--p">We could both be right. Because I didn’t use <em class="markup--em markup--p-em">UIKit-style delegation</em>. I use <em class="markup--em markup--p-em">SwiftUI-style delegation</em>. Like I said, I’ll use binding support by SDK. They are there for a reason.</p><p name="9f92" id="9f92" class="graf graf--p graf-after--p">I don’t use the word <em class="markup--em markup--p-em">MVC-style delegation</em> becasue what? You don’t need <em class="markup--em markup--p-em">MVC-style delegation</em> for MVVM in UIKit which has no binding support? MVC can’t use KVO in UIKit?</p><p name="e634" id="e634" class="graf graf--p graf-after--p">This is what I called a MVVM echo chamber, which might explain why this shit could be recoginized as <em class="markup--em markup--p-em">“you are not wrong” </em>by<em class="markup--em markup--p-em"> </em><strong class="markup--strong markup--p-strong">industry titans</strong><em class="markup--em markup--p-em">.</em></p><p name="ea55" id="ea55" class="graf graf--p graf-after--p">This is why MVVM is stagnant. You can get away with Order(n) solution where n is the number of views; when the point of refactor is to design something of Order(1) so you don’t have to write the same shit every time.</p><p name="fbef" id="fbef" class="graf graf--p graf-after--p">Oh btw, as far as I know, the VIP still thinks <code class="markup--code markup--p-code">struct SomeView: View</code> is a view rather than <code class="markup--code markup--p-code">struct Model: View</code> as a model-view binding. Who is right? You decide.</p><p name="c3ac" id="c3ac" class="graf graf--p graf-after--p">If you think I’m right, then the two of us and the contents of this car are all that remains of the <strong class="markup--strong markup--p-strong">Impossible MVC Force</strong>.</p><p name="38f6" id="38f6" class="graf graf--p graf-after--p graf--trailing"><em class="markup--em markup--p-em">Your mission … should you choose to accept it?</em></p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/73cd055bcb3c"><time class="dt-published" datetime="2022-09-24T16:00:46.657Z">September 24, 2022</time></a>.</p><p><a href="https://medium.com/@swift2931/mission-impossible-a-mvc-swiftui-73cd055bcb3c" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>