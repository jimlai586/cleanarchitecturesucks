<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>MVVM but without view model, and without view!</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">MVVM but without view model, and without view!</h1>
</header>
<section data-field="subtitle" class="p-summary">
How binding and refactor changes MVVM as you know it
</section>
<section data-field="body" class="e-content">
<section name="a263" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="0fda" id="0fda" class="graf graf--h3 graf--leading graf--title">MVVM but without view model, and without view!</h3><p name="bfd3" id="bfd3" class="graf graf--p graf-after--h3">How binding and refactor changes MVVM as you know it</p><figure name="a4f8" id="a4f8" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*JpTL045ZIkjBwelxel7CRw.jpeg" data-width="617" data-height="470" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*JpTL045ZIkjBwelxel7CRw.jpeg"></figure><h4 name="5834" id="5834" class="graf graf--h4 graf-after--figure">You want the impossible</h4><p name="f1eb" id="f1eb" class="graf graf--p graf-after--h4">People find it hard to believe that you can do MVVM without view model. But if you read SwiftUI as I did, not only you don’t need view model, you don’t even need view.</p><p name="33ea" id="33ea" class="graf graf--p graf-after--p">This is going to be unlike any MVVM you ever saw, or will ever see. I’ll start with a refactor problem in UIKit, and work towards a SDK re-design to solve that problem that will end up being SwiftUI.</p><p name="5ca8" id="5ca8" class="graf graf--p graf-after--p">I won’t start by using some MVVM diagram that has been on Internet for over a decade and ignore all the context of SDK and language. I won’t say it is somehow better than MVC because all MVC devs are idiots that can’t create sink / wrapper / delegate objects.</p><p name="ba84" id="ba84" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Design pattern is the result of refactor.</strong></p><p name="cd2a" id="cd2a" class="graf graf--p graf-after--p">In case of MVVM, the core problem is how you do binding.</p><h4 name="1d41" id="1d41" class="graf graf--h4 graf-after--p">Its energy surrounds us and binds us</h4><p name="0cfb" id="0cfb" class="graf graf--p graf-after--h4">Say we have a user info page.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="9cd3" id="9cd3" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserInfoView</span>: <span class="hljs-title class_">UIView</span> {<br />  <span class="hljs-keyword">let</span> username <span class="hljs-operator">=</span> <span class="hljs-type">UILabel</span>()<br />  <span class="hljs-keyword">let</span> address <span class="hljs-operator">=</span> <span class="hljs-type">UILabel</span>()<br />  <span class="hljs-comment">// layout ... </span><br />}</span></pre><p name="f47b" id="f47b" class="graf graf--p graf-after--pre">We call a fetch to load user info on callback when view appears.</p><p name="2dbb" id="2dbb" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">api.userInfo.get().onSuccess { info in self.apiUpdateUI(info) }</code></p><p name="f89d" id="f89d" class="graf graf--p graf-after--p">User can of course update his info via UI.</p><p name="5aa7" id="5aa7" class="graf graf--p graf-after--p">So you handle touch event, key input, validation… etc before eventually do another UI update.</p><p name="5577" id="5577" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">keyEventUpdateUI(info)</code></p><p name="a998" id="a998" class="graf graf--p graf-after--p">In this simple case, <code class="markup--code markup--p-code">apiUpdateUI(info)</code> will be identical to <code class="markup--code markup--p-code">keyEventUpdateUI(info)</code> , hence we have code duplication, and need refactor. The idea is then to describe this model-view mapping, i.e; binding once, and reuse this mapping whenever possible.</p><p name="69fc" id="69fc" class="graf graf--p graf-after--p">A simple implementation of this idea is to use property observer:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="9860" id="9860" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">var</span> model <span class="hljs-operator">=</span> <span class="hljs-type">UserInfo</span>() { <span class="hljs-keyword">didSet</span> { updateUI() }}</span></pre><p name="e2f6" id="e2f6" class="graf graf--p graf-after--pre">Whenever model changes, UI changes.</p><p name="94c3" id="94c3" class="graf graf--p graf-after--p">For api callback or event handler, they don’t even need to know they are updating UI. All they see and interact with is model. Isn’t this the kind of effect you want with MVVM?</p><p name="bf99" id="bf99" class="graf graf--p graf-after--p">But this way of binding very much depends on the view controller. You’d expect a model-view mapping to exist without view controller, e.g.;</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="9ded" id="9ded" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">UserInfoBinding</span>: <span class="hljs-title class_">class</span> {<br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">updateUI</span>(<span class="hljs-params">info</span>: <span class="hljs-type">UserInfo</span>)<br />}<br /><br /><span class="hljs-keyword">extension</span> <span class="hljs-title class_">UserInfoView</span>: <span class="hljs-title class_">UserInfoBinding</span> {<br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">updateUI</span>(<span class="hljs-params">info</span>: <span class="hljs-type">UserInfo</span>) {<br />    username.text <span class="hljs-operator">=</span> info.username<br />    address.text <span class="hljs-operator">=</span> info.address<br />  }<br />}</span></pre><p name="c6a1" id="c6a1" class="graf graf--p graf-after--pre">That is, a view can be extended to define binding without view controller.</p><p name="80fb" id="80fb" class="graf graf--p graf-after--p">First major problem is that this will be on a per-view basis. It uses extension so not every view has to be a custom view, but it still requires a protocol for every view. Contrary to usual MVVM where creating object(s) for every view is considered best practice, we have a much higher refactor standard here.</p><p name="9079" id="9079" class="graf graf--p graf-after--p">Second, it’s not reactive on its own. A property obsever still needs to be set up.</p><p name="0b0a" id="0b0a" class="graf graf--p graf-after--p">Third, you can expect most of the codes are just boilerplate assignments. Things get worse if the view wants to support binding from differnt types of models, e.g.;</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="631b" id="631b" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">func</span> <span class="hljs-title function_">updateUI</span>(<span class="hljs-params">info</span>: <span class="hljs-type">DBUserInfo</span>) {<br />    username.text <span class="hljs-operator">=</span> info.username<br />    address.text <span class="hljs-operator">=</span> info.address<br /> }</span></pre><p name="4f9f" id="4f9f" class="graf graf--p graf-after--pre">where the model type <code class="markup--code markup--p-code">DBUserInfo</code>represents data coming from a database.</p><p name="278b" id="278b" class="graf graf--p graf-after--p">Again, code duplication. Needs refactor. This is the point where you need SDK support otherwise you write boilerplate.</p><p name="c0bf" id="c0bf" class="graf graf--p graf-after--p">We need a design that can define binding and be reactive without view controller; in the meantime minimizing boilerplate. What will you do if you were given the chance to re-design the SDK from ground up?</p><h4 name="b3b0" id="b3b0" class="graf graf--h4 graf-after--p">Boilerplate does not make one great</h4><p name="ef26" id="ef26" class="graf graf--p graf-after--h4">Observe that the above duplication is caused by <code class="markup--code markup--p-code">updateUI</code> having dependency on model type when it actually only depends on properties. E.g.;</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="javascript" name="a7d9" id="a7d9" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">func <span class="hljs-title function_">updateUI</span>(<span class="hljs-params">username: <span class="hljs-built_in">String</span>, address: <span class="hljs-built_in">String</span></span>) {<br />    username.<span class="hljs-property">text</span> = username<br />    address.<span class="hljs-property">text</span> = address<br /> }</span></pre><p name="ccd7" id="ccd7" class="graf graf--p graf-after--pre">But then this does not scale to the number of properties. This suggests we start with model instead:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="41d2" id="41d2" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UserInfo</span> {<br />  <span class="hljs-keyword">let</span> username: <span class="hljs-type">String</span><br />  <span class="hljs-keyword">let</span> address: <span class="hljs-type">String</span><br />  <br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">updateUI</span>(<span class="hljs-params">view</span>: <span class="hljs-type">UserInfoView</span>) {<br />    view.username.text <span class="hljs-operator">=</span> username<br />    view.address.text <span class="hljs-operator">=</span> address<br />  }<br />}</span></pre><p name="04c1" id="04c1" class="graf graf--p graf-after--pre">We can remove protocol as well since we don’t need extension to existing class.</p><p name="6874" id="6874" class="graf graf--p graf-after--p">But a value type that induces side effetcs on a view… is <em class="markup--em markup--p-em">unatural</em>. Consider that we want a model-view mapping, which is basically a function, we’d expect a function that returns view instead of accepting view, which would suggest we contruct a partial view and return it instead of acceting a full view then modifies it.</p><p name="0d62" id="0d62" class="graf graf--p graf-after--p">The obvious question is then there’s no such a thing as a partial view, at least not yet.</p><p name="cfa9" id="cfa9" class="graf graf--p graf-after--p">We know username maps to a label, and address also maps to a label. Can we build a partial view with two labels? E.g.;</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="bc7e" id="bc7e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UserInfo</span> {<br />  <span class="hljs-keyword">let</span> username: <span class="hljs-type">String</span><br />  <span class="hljs-keyword">let</span> address: <span class="hljs-type">String</span><br />  <br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">getView</span>() -&gt; <span class="hljs-type">PartialView</span> {<br />    <span class="hljs-type">PartialView</span>(<span class="hljs-type">UILabel</span>(text: username), <span class="hljs-type">UILabel</span>(text: address))<br />  }<br />}</span></pre><p name="02be" id="02be" class="graf graf--p graf-after--pre">This seems promising. It’s not too far-fetched to imagine <code class="markup--code markup--p-code">PartialView</code> to be a <code class="markup--code markup--p-code">StackView</code> with syntax sugar and from UIKit experience one can build a full view using <code class="markup--code markup--p-code">StackView</code> as building blocks, while system takes care of layout details.</p><p name="bfba" id="bfba" class="graf graf--p graf-after--p">How does this play out from caller’s perspective?</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="ac2e" id="ac2e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">let</span> view1 <span class="hljs-operator">=</span> model1.getView()<br /><span class="hljs-comment">// view1.color = ... </span><br /><span class="hljs-keyword">let</span> view2 <span class="hljs-operator">=</span> model2.getView()<br /><span class="hljs-comment">// view2.color = ...</span><br /><span class="hljs-keyword">let</span> view3 <span class="hljs-operator">=</span> <span class="hljs-type">PartialView</span>(view1, view2)<br /><span class="hljs-comment">// customize view3</span></span></pre><p name="9326" id="9326" class="graf graf--p graf-after--pre">Observe that <code class="markup--code markup--p-code">getView()</code> becomes a routine boilerplate. I want a syntax sugar like <code class="markup--code markup--p-code">PartialView(model1, model2)</code> , then it calls <code class="markup--code markup--p-code">getView()</code> automatically. I want to be able to the same view-related operations directly to all possible model types. This calls for protocol objects.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="0bc9" id="0bc9" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UserInfo</span>: <span class="hljs-title class_">View</span> {<br />  <span class="hljs-keyword">let</span> username: <span class="hljs-type">String</span><br />  <span class="hljs-keyword">let</span> address: <span class="hljs-type">String</span><br />  <span class="hljs-keyword">var</span> body: <span class="hljs-type">PartialView</span> {<span class="hljs-operator">...</span>}<br />}</span></pre><p name="a8e8" id="a8e8" class="graf graf--p graf-after--pre">in which <code class="markup--code markup--p-code">getView()</code> becomes a computed property <code class="markup--code markup--p-code">body</code>, required by protocol View. A property <code class="markup--code markup--p-code">view</code> required by protocol <code class="markup--code markup--p-code">View</code> would be confusing, hence the rename.</p><p name="735f" id="735f" class="graf graf--p graf-after--p">But what about <code class="markup--code markup--p-code">PartialView</code> ? It has to conform to <code class="markup--code markup--p-code">View</code> , right? Since we want a mix-match like</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="0aa1" id="0aa1" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-type">PartialView</span>(model1, <span class="hljs-type">PartialView</span>(model2, model3), model4, view5)</span></pre><p name="eed3" id="eed3" class="graf graf--p graf-after--pre">That wouldn’t make sense because there’s no binding to be defined in <code class="markup--code markup--p-code">PartialView</code> … yet. Hmm… how about we try…</p><h4 name="5d10" id="5d10" class="graf graf--h4 graf-after--p">Do or do not. There’s no try.</h4><p name="4225" id="4225" class="graf graf--p graf-after--h4">Up to this point, we treat model and view as separate entities. But a model-view binding makes them two sides of the same coin.</p><p name="40e1" id="40e1" class="graf graf--p graf-after--p">A model can be used like a view as long as it defines a binding. The protocol requirement on <code class="markup--code markup--p-code">PartialView</code> suggests that every view can be seen as a model with binding. This means a re-design of <code class="markup--code markup--p-code">UIView</code> as we know it.</p><p name="e6fb" id="e6fb" class="graf graf--p graf-after--p">If we were to define a view as a model with binding, the first problem is then we can’t just have a model with all the usual view properties, e.g.; color, alignment… etc. For example, a binding that requires 2 properties has to meet the additional requirement of 20 view properties:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="rust" name="f797" id="f797" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UserInfo</span>: View {<br />  <span class="hljs-keyword">let</span> <span class="hljs-variable">username</span>: <span class="hljs-type">String</span><br />  <span class="hljs-keyword">let</span> <span class="hljs-variable">address</span>: <span class="hljs-type">String</span> <br />  <span class="hljs-keyword">let</span> <span class="hljs-variable">color</span>: Color <br />  <span class="hljs-keyword">let</span> <span class="hljs-variable">alignment</span>: Alignment<br />  <span class="hljs-comment">// ... many more</span><br />}</span></pre><p name="cc3e" id="cc3e" class="graf graf--p graf-after--pre">These view properties are not involved in binding, and cannot be inherited since we are working inside a value type. It would be like carrying a dead horse for every binding.</p><p name="5a7f" id="5a7f" class="graf graf--p graf-after--p">So the first major design decision: <strong class="markup--strong markup--p-strong">a view is a model with binding without view properties.</strong></p><p name="26c0" id="26c0" class="graf graf--p graf-after--p">Then what kind of view is that??? You scream.</p><blockquote name="892b" id="892b" class="graf graf--blockquote graf-after--p">That boy is our only hope…</blockquote><blockquote name="6c09" id="6c09" class="graf graf--blockquote graf-after--blockquote">No. There’s another.</blockquote><p name="e176" id="e176" class="graf graf--p graf-after--blockquote">Recall that we are working with protocol objects that conform to <code class="markup--code markup--p-code">View</code> . Instead of having <code class="markup--code markup--p-code">color</code> as a stored property, we make it a <em class="markup--em markup--p-em">function, which takes a </em><code class="markup--code markup--p-code"><em class="markup--em markup--p-em">View</em></code><em class="markup--em markup--p-em"> object and returns another </em><code class="markup--code markup--p-code"><em class="markup--em markup--p-em">View</em></code><em class="markup--em markup--p-em"> object.</em></p><p name="74bd" id="74bd" class="graf graf--p graf-after--p">The key here is to let compiler know how to render it. This function can return a intermediate type like</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="8696" id="8696" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ColoredView</span>: <span class="hljs-title class_">View</span> {<br />  <span class="hljs-keyword">let</span> color: <span class="hljs-type">Color</span> <br />  <span class="hljs-keyword">var</span> body: <span class="hljs-type">PartialView</span> {<span class="hljs-operator">...</span>}<br />}</span></pre><p name="18be" id="18be" class="graf graf--p graf-after--pre">where <code class="markup--code markup--p-code">body</code> is the same as that view passed in as parameter.</p><p name="ae77" id="ae77" class="graf graf--p graf-after--p">These types can be internal only and not open to public in SDK. But this would need a lot of types for every kind of view property combination. It’s plausible that compiler can use some kind of implementation to do this though.</p><p name="4988" id="4988" class="graf graf--p graf-after--p">The trade-off, of course, is that this color information is lost somewhere along the way. (to caller, not compiler) Because all he sees is a <code class="markup--code markup--p-code">View</code> object without color property.</p><p name="7cbd" id="7cbd" class="graf graf--p graf-after--p">This creates a problem. Because if <code class="markup--code markup--p-code">View</code> object were a reference type, people can modify it without you knowing. So we are not using value type model because it looks cool, we have to. As with everything alone the way.</p><p name="833c" id="833c" class="graf graf--p graf-after--p">View becomes value type model with binding. View properties become functions. With these in mind, we replace <code class="markup--code markup--p-code">PartialView</code> with <code class="markup--code markup--p-code">some View</code> , highlighting that even though you may not know the exact type, the compiler does. Otherwise it loses too much info to render a view using just a protocol type object.</p><p name="353a" id="353a" class="graf graf--p graf-after--p">We then no longer distinguish between a model with binding and a view. Hence we don’t need to worry about constantly changing model to view and mix matching model with view. It also explains why view needs to have value type context.</p><p name="cc3f" id="cc3f" class="graf graf--p graf-after--p">Two sides of the same coin.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="492b" id="492b" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UserInfo</span>: <span class="hljs-title class_">View</span> {<br />  <span class="hljs-keyword">let</span> username: <span class="hljs-type">String</span><br />  <span class="hljs-keyword">let</span> address: <span class="hljs-type">String</span><br />  <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {<span class="hljs-operator">...</span>}<br />}</span></pre><p name="d2a2" id="d2a2" class="graf graf--p graf-after--pre">Now let’s see what we can build on top of this building block.</p><h4 name="5b8b" id="5b8b" class="graf graf--h4 graf-after--p">Control. You must learn control.</h4><p name="8ab4" id="8ab4" class="graf graf--p graf-after--h4">In UIKit we rely on delegates for view to forward touch events to be handled by view controller.</p><p name="07ff" id="07ff" class="graf graf--p graf-after--p">The immediate result is that, one view controller has to handle many events from many views. Can we design a better control structure?</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="404c" id="404c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UserInfo</span>: <span class="hljs-title class_">View</span> {<br />  <span class="hljs-keyword">let</span> control <span class="hljs-operator">=</span> <span class="hljs-type">Controller</span>()<br />  <span class="hljs-operator">...</span><br />}</span></pre><p name="f492" id="f492" class="graf graf--p graf-after--pre">Let’s make some observations.</p><p name="ebbf" id="ebbf" class="graf graf--p graf-after--p">If we start with a controller, then it has to create multiple model-views, setup delegates, and handle callbacks depending on which model-view is calling… wait. Model is a value type. You can’t tell who is calling, so callbacks needs to be custom made. Since the model in model-view is custom to begin with, you might as well choose a specific type instead of protocol to be your controller.</p><p name="b192" id="b192" class="graf graf--p graf-after--p">This of course locks your model-view to a specific controller. But controller is special in UIKit, it has its own hierarchy, bridges across components … etc. If we remove all that, and use it like a standalone network service, a state management service of sorts, then it could work.</p><p name="b6d5" id="b6d5" class="graf graf--p graf-after--p">Instead of managing model-views in one place, let model-views manage themselves, especailly when they already carry model and view information. If some work is too much to handle in a model, refactor it out. Design a SDK that allows you to refactor freely without worrying about integrating to existing system functions. There’s one caveat though. How do you justify or even implement control in a value type model?</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="29e8" id="29e8" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UserInfo</span>: <span class="hljs-title class_">View</span> {<br />  <span class="hljs-comment">// reference type</span><br />  <span class="hljs-keyword">let</span> control <span class="hljs-operator">=</span> <span class="hljs-type">Controller</span>()<br />  <span class="hljs-keyword">var</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Yoda&quot;</span><br />  <span class="hljs-comment">// username = &quot;Luke&quot;, can&#x27;t mutate because immutable</span><br />}</span></pre><p name="ee03" id="ee03" class="graf graf--p graf-after--pre">I hate mutable model that has side effects. I want immutable model without side effects. But for you to do any real work, like changing <code class="markup--code markup--p-code">username</code> , I need to provide a reference type wrapper. E.g.;</p><p name="242d" id="242d" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">@Wrapper var username = &quot;Yoda&quot;</code></p><p name="744a" id="744a" class="graf graf--p graf-after--p">So when I mutate <code class="markup--code markup--p-code">username</code> , I acutally mutate <code class="markup--code markup--p-code">wrapper.username</code> .</p><p name="5588" id="5588" class="graf graf--p graf-after--p">But this is exactly why it’s dangerous to have reference type inside value type. You can circumvent immutability this easily.</p><p name="0401" id="0401" class="graf graf--p graf-after--p">However, note that we need a system to trigger view updates anyway, since we don’t have external property observer, and changes can come from reference type. What we need is a publisher-observer sytem.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="81f2" id="81f2" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-meta">@UIObserver</span> <br /><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UserInfo</span>: <span class="hljs-title class_">View</span> {<br />  <span class="hljs-meta">@Observer</span> <span class="hljs-keyword">let</span> control <span class="hljs-operator">=</span> <span class="hljs-type">Controller</span>()<br />  <span class="hljs-meta">@Wrapper</span> <span class="hljs-keyword">var</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Yoda&quot;</span><br />}</span></pre><p name="7e7b" id="7e7b" class="graf graf--p graf-after--pre">That is, if you are a reference type, you can publish changes to @Observer, which in turn notifies @UIObserver to trigger re-rendering.</p><p name="3340" id="3340" class="graf graf--p graf-after--p">And if you are a wrapper, you can publish changes to wrapped value type to @UIObserver to trigger re-rendering.</p><p name="8317" id="8317" class="graf graf--p graf-after--p">Obviously the setup needs to be automatic / hidden so we don’t write boilerplate on a per-model-view basis.</p><p name="bcf7" id="bcf7" class="graf graf--p graf-after--p">With this system, our value type object is re-created even when a reference type is mutated, well, at least on things that you explicitly observe.</p><p name="f25e" id="f25e" class="graf graf--p graf-after--p">In a way, this becomes a more generalized “immutable” value type, specifically made to support model-view binding. Because of the additional observer system required, it may even be safer than ordinary custom value type object which contains reference types. It does not save you from abusing side effects or mutating properties not explicitly observed, but hey, at some point you just have to be better at coding.</p><p name="45f5" id="45f5" class="graf graf--p graf-after--p">With these discussion, we finally reach a point to hit home with the idea of <strong class="markup--strong markup--p-strong">view as function of state</strong>. We want you to explicitly specify things you want to observer to trigger view update. Those things are <em class="markup--em markup--p-em">view states</em>. <code class="markup--code markup--p-code">body</code> is a computed property, and <code class="markup--code markup--p-code">UserInfo</code> is a value type. You have no direct access to a reference type view object. The only way you can change a view is by changing <em class="markup--em markup--p-em">view state</em>. These state can come from model itself, or from external object like network service. So we rename observers to reflect this:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="b023" id="b023" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UserInfo</span>: <span class="hljs-title class_">View</span> {<br />  <span class="hljs-meta">@StateObject</span> <span class="hljs-keyword">let</span> control <span class="hljs-operator">=</span> <span class="hljs-type">Controller</span>()<br />  <span class="hljs-meta">@State</span> <span class="hljs-keyword">var</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Yoda&quot;</span><br />}</span></pre><p name="227e" id="227e" class="graf graf--p graf-after--pre">There are other things we can improve over this design, like design a way to share <code class="markup--code markup--p-code">Controller</code> instance becasue it will be tedious to create the same service for EACH model-view. Again, always try to prevent a “solution” on a per-view basis.</p><p name="179b" id="179b" class="graf graf--p graf-after--p">But as far as SDK re-design goes, we’ve built a plausible design that builds control on top of model-view binding. Now if you compare this with SwiftUI…</p><p name="908a" id="908a" class="graf graf--p graf-after--p">We can conclude two points:</p><ol class="postList"><li name="41a6" id="41a6" class="graf graf--li graf-after--p">SwiftUI = Binding + refactor</li><li name="177a" id="177a" class="graf graf--li graf-after--li">Apple SwiftUI team is at least as good as me</li></ol><p name="80d0" id="80d0" class="graf graf--p graf-after--li">I’m writing all these design decisions in detail to convince you in what I’m about to make comparison of.</p><h4 name="023b" id="023b" class="graf graf--h4 graf-after--p">The greatest teacher, failure is.</h4><p name="604f" id="604f" class="graf graf--p graf-after--h4">Let’s look at some MVVM diagrams.</p><p name="ae4e" id="ae4e" class="graf graf--p graf-after--p"><a href="https://medium.com/geekculture/swiftui-mvvm-architecture-d00a29812d90" data-href="https://medium.com/geekculture/swiftui-mvvm-architecture-d00a29812d90" class="markup--anchor markup--p-anchor" target="_blank"><strong class="markup--strong markup--p-strong">Standard architecture of SwiftUI</strong></a></p><figure name="0540" id="0540" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*O_3Is5-TWnK9HjdysxSVKw.png" data-width="790" data-height="473" src="https://cdn-images-1.medium.com/max/800/1*O_3Is5-TWnK9HjdysxSVKw.png"></figure><p name="4fc4" id="4fc4" class="graf graf--p graf-after--figure">This diagram came from a <strong class="markup--strong markup--p-strong">STANDFORD </strong>class, as claimed by the article.</p><p name="0e9c" id="0e9c" class="graf graf--p graf-after--p">It is <strong class="markup--strong markup--p-strong">STANDARD</strong>. They say.</p><p name="4ecf" id="4ecf" class="graf graf--p graf-after--p">Let me ask you, if you read this far so some reason.</p><p name="3b08" id="3b08" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Where the F, do we spend most of the time, doing model-view binding?</strong></p><p name="fd14" id="fd14" class="graf graf--p graf-after--p">Model-view binding is so tight, there’s no room for middle man.</p><p name="4232" id="4232" class="graf graf--p graf-after--p">We already build around model-view binding, there’s no need for middle man.</p><p name="f6bd" id="f6bd" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">And where’s view?</strong></p><p name="4d1a" id="4d1a" class="graf graf--p graf-after--p">Recall that we designed view to be a model with binding. There is no indvidual reference type view object in SwiftUI. Two sides of the same coin, remember?</p><p name="42ca" id="42ca" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Don’t need view model, don’t need view. But is SwiftUI MVVM?</strong></p><p name="c413" id="c413" class="graf graf--p graf-after--p">It has binding. What else do you need?</p><p name="a891" id="a891" class="graf graf--p graf-after--p">A presenter? Use computed property in <code class="markup--code markup--p-code">struct UserInfo: View {...}</code> .</p><p name="644f" id="644f" class="graf graf--p graf-after--p">Put all the business logic in? Why? Why can’t I just create another single responsibility object to handle business logic, but have to mix it with binding, presenter and god knows what. In fact I may need to split business logic into different sub-secitons to handle more easily.</p><p name="1956" id="1956" class="graf graf--p graf-after--p">SwiftUI is an example of how to beat MVVM in their own game. Remove boilerplate! Learn from people who build SDK for entire industry. Learn how they design and refactor.</p><p name="3cb7" id="3cb7" class="graf graf--p graf-after--p">If you are still following such a diagram, you are a decade obsolete. If you add clean architecture, you are two decade behind.</p><p name="233e" id="233e" class="graf graf--p graf-after--p">Look at this <a href="https://clean-swift.com/clean-swift-ios-architecture/" data-href="https://clean-swift.com/clean-swift-ios-architecture/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">anti-pattern</a>.</p><p name="df69" id="df69" class="graf graf--p graf-after--p">Focus on how it triggers view update.</p><p name="8552" id="8552" class="graf graf--p graf-after--p">Create Interactor object -&gt; create worker object -&gt; get response object from worker do_something result -&gt; create presenter object -&gt; create view model object -&gt; trigger view update by passing view model as parameter.</p><p name="3150" id="3150" class="graf graf--p graf-after--p">F-ing dumbshit. This guy writes massive view controller, I guarantee it. This is inmates running asylum situation. Those who write massive view controller are now industry leaders in teaching people how not to write massive view controller while applying every anti-pattern that makes you write massive view controller.</p><p name="eba0" id="eba0" class="graf graf--p graf-after--p">OK. Rant over. Anger leads to hate. Hate leads to suffering. I’m gonna wrap up here.</p><h3 name="92c3" id="92c3" class="graf graf--h3 graf-after--p">That is why you fail.</h3><p name="342e" id="342e" class="graf graf--p graf-after--h3">If you are writing SwiftUI using obsolete diagram and lack refactor skill, you write dumb shit.</p><p name="617e" id="617e" class="graf graf--p graf-after--p">Every SwiftUI MVVM guru, influencer, industry titan writes dumb shit.</p><p name="f40f" id="f40f" class="graf graf--p graf-after--p">Look how binding and value type factor in our design. We build around it. You cannot expect decade old diagram without context you found on Internet somehow gives you clean architecture.</p><p name="2387" id="2387" class="graf graf--p graf-after--p">Creating a view model as observable object is dumb shit because you are moving “model” in model-view binding to outside, and the first thing you do is to “re-bind” it, which is useless work.</p><p name="c15d" id="c15d" class="graf graf--p graf-after--p">Remember how we emphasize over and over again on avoiding a “solution” that is on per-view basis? Remember how we discuss immutability and how we design to maintain it even with reference types? And the “solution” you came up with is one reference type object for every view? in which you lost SDK support for @EnvironmentObject and have to pass parameter all the way manually?</p><p name="258f" id="258f" class="graf graf--p graf-after--p">I don’t know why I seem to be alone in all these. It should be f-ing obvious.</p><p name="65cf" id="65cf" class="graf graf--p graf-after--p">Things I wrote here are things I’ve learned in first two projects.</p><h3 name="695e" id="695e" class="graf graf--h3 graf-after--p">Pass on what you have learned.</h3><p name="b61b" id="b61b" class="graf graf--p graf-after--h3 graf--trailing">I hope this article helped you in some way. And if possible, pass on what you have learned. I’m sick and tired of seeing MVVM dumb shit, especailly in SwiftUI… uh, I mean may the force be with you!</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/88bd85c3e4fa"><time class="dt-published" datetime="2022-11-22T10:19:02.652Z">November 22, 2022</time></a>.</p><p><a href="https://medium.com/@swift2931/mvvm-but-without-view-model-and-without-view-88bd85c3e4fa" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>