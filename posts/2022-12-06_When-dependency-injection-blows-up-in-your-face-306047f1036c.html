<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>When dependency injection blows up in your face</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">When dependency injection blows up in your face</h1>
</header>
<section data-field="subtitle" class="p-summary">
Man on fire
</section>
<section data-field="body" class="e-content">
<section name="a577" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="184a" id="184a" class="graf graf--h3 graf--leading graf--title">When dependency injection blows up in your face</h3><figure name="e210" id="e210" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*PgeBTaEpoI-O7e1HJeSxlw.png" data-width="1571" data-height="819" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*PgeBTaEpoI-O7e1HJeSxlw.png"><figcaption class="imageCaption">Denzel Washington explaining why a C4 injection is bad for your health in the movie “man on fire”</figcaption></figure><h4 name="1e7d" id="1e7d" class="graf graf--h4 graf-after--figure">Man on fire</h4><p name="bf94" id="bf94" class="graf graf--p graf-after--h4">If you had watched this movie before, you know where Denzel <em class="markup--em markup--p-em">injects </em>this. (Hint: not in the face)</p><p name="b6a4" id="b6a4" class="graf graf--p graf-after--p">Injecting a bomb and waiting for it to blow up is essentially what this tutorial is about:</p><p name="a884" id="a884" class="graf graf--p graf-after--p"><a href="https://www.kodeco.com/22203552-resolver-for-ios-dependency-injection-getting-started#toc-anchor-005" data-href="https://www.kodeco.com/22203552-resolver-for-ios-dependency-injection-getting-started#toc-anchor-005" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Resolver for iOS Dependency Injection: Getting Started</a></p><p name="e5e9" id="e5e9" class="graf graf--p graf-after--p">What better way to celebrate <strong class="markup--strong markup--p-strong">THE NEW RAYWENDERLICH.COM </strong>by pointing out the anti-pattern you are going to learn in one of its tutorials?</p><p name="e7de" id="e7de" class="graf graf--p graf-after--p">And better yet, the library introduced in the tutorial is written by the guy that got POP completely wrong, which was discussed in detail in my another article. <a href="https://medium.com/@swift2931/non-functional-dependency-injection-in-swift-beffe4151373" data-href="https://medium.com/@swift2931/non-functional-dependency-injection-in-swift-beffe4151373" class="markup--anchor markup--p-anchor" target="_blank">Non-functional dependency injection</a>.</p><p name="467d" id="467d" class="graf graf--p graf-after--p">Since then I’ve learned that this guy happens to be a top 1000 technical writter on this platform. As a courtesy, I’m going to point out more of his mistakes.</p><p name="e7e2" id="e7e2" class="graf graf--p graf-after--p">I’ll start from the tutorial, then review some article, then do a small code review on Resolver.</p><h4 name="797d" id="797d" class="graf graf--h4 graf-after--p">Be a strong man</h4><blockquote name="34d9" id="34d9" class="graf graf--blockquote graf-after--h4">Design patterns create weak men,</blockquote><blockquote name="9b8c" id="9b8c" class="graf graf--blockquote graf-after--blockquote">and weak men create hard times,</blockquote><blockquote name="7dcc" id="7dcc" class="graf graf--blockquote graf-after--blockquote">hard times create strong men,</blockquote><blockquote name="914c" id="914c" class="graf graf--blockquote graf-after--blockquote">strong men create design patterns.</blockquote><p name="c880" id="c880" class="graf graf--p graf-after--blockquote">The tutorial opens with this</p><figure name="8c63" id="8c63" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*3_Dq95_-VfQHHhXtfULkeg.png" data-width="1110" data-height="484" src="https://cdn-images-1.medium.com/max/800/1*3_Dq95_-VfQHHhXtfULkeg.png"></figure><p name="3ad3" id="3ad3" class="graf graf--p graf-after--figure">The first question then would be what are <strong class="markup--strong markup--p-strong">tightly coupled classes</strong>?</p><p name="dc26" id="dc26" class="graf graf--p graf-after--p">And the example of it is… <code class="markup--code markup--p-code">NetworkService</code>and <code class="markup--code markup--p-code">URLSession</code> .</p><p name="cbbf" id="cbbf" class="graf graf--p graf-after--p">Why? What is the implied criteria here? Because you use a class object it becomes tightly coupled? And we need IOC / DI / DIP to turn the class object to protocol object? By this logic we should only create protocol objects from now on because almost everything is called by something.</p><p name="6b66" id="6b66" class="graf graf--p graf-after--p">What makes it even more insane is the fact that it is <code class="markup--code markup--p-code">URLSession</code> . Say Apple suddenly changes the implementation of <code class="markup--code markup--p-code">URLSession</code> , but not function signatures, does that impact your code in anyway?</p><p name="7892" id="7892" class="graf graf--p graf-after--p">No. Because your code knows nothing about the implementation of <code class="markup--code markup--p-code">URLSession</code> , you access it via <strong class="markup--strong markup--p-strong">API (interface)</strong>. Your code does not <em class="markup--em markup--p-em">depend </em>on <code class="markup--code markup--p-code">URLSession</code> , it depends on its <strong class="markup--strong markup--p-strong">interface</strong>. It is not a protocol object, but it does not need to be, unless you want to implement it yourself.</p><p name="75bd" id="75bd" class="graf graf--p graf-after--p">That’s the neat part. You can’t! Even if you want to. It involves system calls to control hardware. That is not to say you can’t inject it, because there are use cases where you want a customized <code class="markup--code markup--p-code">URLSession</code> configured outside of network service. But even if you don’t inject it, you can configure it nevertheless! E.g.; <code class="markup--code markup--p-code">service.session = ...</code> It won’t become <em class="markup--em markup--p-em">tightly coupled</em> just because you don’t inject it.</p><p name="9c21" id="9c21" class="graf graf--p graf-after--p">DI wants you to depend on <strong class="markup--strong markup--p-strong">interface</strong>, not implementation.(if needed at all)</p><p name="f561" id="f561" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">That interface does not have to be a protocol.</strong></p><p name="4e7b" id="4e7b" class="graf graf--p graf-after--p">In practice, if you cause merge conflict after changing implementation, you know it needs DI. If it doesn’t, then nobody gives a shit about your implementation, and you might not need it. Usually you don’t need to worry about any of these DI shit, you will quickly learn it via regular code commits.</p><p name="3557" id="3557" class="graf graf--p graf-after--p">SDK of course won’t let you depend on its implementation. So why would this <em class="markup--em markup--p-em">dependency </em>become a problem? You plan on creating so many <code class="markup--code markup--p-code">URLSession</code> objects that you need a service to <em class="markup--em markup--p-em">manage </em>for you?</p><p name="8810" id="8810" class="graf graf--p graf-after--p">3 mins into the tutorial, the premises upon which it is based have collapsed. <em class="markup--em markup--p-em">Design patterns create weak men</em>.</p><p name="b2c7" id="b2c7" class="graf graf--p graf-after--p">As prophecy foretold, weak men are going to create hard times, i.e.; dumb shit code.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="56ab" id="56ab" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">NetworkServiceProtocol</span> {<br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">fetch</span>(<br />    <span class="hljs-params">with</span> <span class="hljs-params">urlRequest</span>: <span class="hljs-type">URLRequest</span>,<br />    <span class="hljs-params">completion</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">Result</span>&lt;<span class="hljs-type">Data</span>, <span class="hljs-type">AppError</span>&gt;) -&gt; <span class="hljs-type">Void</span><br />  )<br />}</span></pre><p name="75c7" id="75c7" class="graf graf--p graf-after--pre">What is wrong with this protocol?</p><p name="e046" id="e046" class="graf graf--p graf-after--p">First the word <code class="markup--code markup--p-code">Protocol</code> is redundant, it can be easily inferred from <code class="markup--code markup--p-code">protocol NetworkService</code> .</p><p name="c3db" id="c3db" class="graf graf--p graf-after--p">Second, recall that <strong class="markup--strong markup--p-strong">interface does not have to be a protocol. </strong>If we have a <code class="markup--code markup--p-code">class NetworkService {...}</code> and we only access it via API, say <code class="markup--code markup--p-code">service.fetch(...)</code> , it doesn’t violate DI.</p><p name="b42b" id="b42b" class="graf graf--p graf-after--p">Third, most of the time fetch code would be the same. You need a protocol extension to refactor it out.</p><p name="df42" id="df42" class="graf graf--p graf-after--p">Fourth, why do you expect there to be multiple network services? You don’t plan to create one network service per view right? I never need more than 1 network service, and I use the same network service every project. DI is NOT the only thing to consider in designing a robust, reusable network service. In fact it’s proabably the last thing to consider because again, you don’t need protocol for DI and are never going to swap out <code class="markup--code markup--p-code">URLSession</code>.</p><p name="f958" id="f958" class="graf graf--p graf-after--p">Instead of writing several lame protocol objects that conform to it without default implementation, hence having code duplication, put all your energy into writing an flexible and extendable service first. A real network service never contains just one fetch btw.</p><p name="238f" id="238f" class="graf graf--p graf-after--p">If you observe the hierarchy:</p><figure name="9f75" id="9f75" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*uIFRATAi5AUAjtkWT_HxpA.png" data-width="670" data-height="765" src="https://cdn-images-1.medium.com/max/800/1*uIFRATAi5AUAjtkWT_HxpA.png"></figure><p name="fb35" id="fb35" class="graf graf--p graf-after--figure">There are two reference type objects, namely <code class="markup--code markup--p-code">AssetListViewModel</code> and <code class="markup--code markup--p-code">AssetService</code> . Just by naming you know none of these are reusable. e.g.; if we have a another view that has nothing to do <code class="markup--code markup--p-code">Asset</code> , none of these work.</p><p name="8b1a" id="8b1a" class="graf graf--p graf-after--p">If we have two non-reusable objects, why not merge them into one? You’d argue that <em class="markup--em markup--p-em">some </em>of its functions are reusable. Then I’ll ask you why not refactor them out, you know you can refactor out functions to protocol extension, right? Protocol composition is all about extracting <em class="markup--em markup--p-em">some </em>functions to protocol extension so you can compose them later.</p><p name="3375" id="3375" class="graf graf--p graf-after--p">Or if you like inheritance, why not make <code class="markup--code markup--p-code">AssetService</code> inherits <code class="markup--code markup--p-code">NetworkService</code> ?</p><p name="a863" id="a863" class="graf graf--p graf-after--p">These are legit refactor considerations to <strong class="markup--strong markup--p-strong">simplify </strong>design. You need to justify it before moving on to minor details like DI, most of which are done when you create an object to call its API. This over-focus on DI <strong class="markup--strong markup--p-strong">complicates </strong>design and hides the lack of refactor skill. Say you don’t use library, after writing these boilerplate injection over and over again, you might start to ask: can I make it simpler?</p><p name="0eae" id="0eae" class="graf graf--p graf-after--p">Unfortuately, weak men in hard times turn to library instead of self-improvement. Before we move on to discuss library, let me highlight this statement:</p><blockquote name="5eed" id="5eed" class="graf graf--blockquote graf-after--p">Look at the code, and you’ll see tightly coupled classes. Even though you can run the app,<strong class="markup--strong markup--blockquote-strong"> this code is neither maintainable nor testable</strong>. Your goal is to refactor the code, so the classes become loosely coupled.</blockquote><p name="3d76" id="3d76" class="graf graf--p graf-after--blockquote">I love this arrogance that if we don’t create protocol objects, nothing is testable.</p><figure name="3fff" id="3fff" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*dppujMRyWrJIjd6d-qs5KQ.png" data-width="500" data-height="200" src="https://cdn-images-1.medium.com/max/800/1*dppujMRyWrJIjd6d-qs5KQ.png"></figure><p name="237c" id="237c" class="graf graf--p graf-after--figure">When you test a protocol object, you test its required functions. When you test a class object, you test… well, its functions.</p><p name="d88e" id="d88e" class="graf graf--p graf-after--p">This arrogance probably came from MVVM. I see a lot of MVVM devs say you can only have proper testing when you put everything in a sink object called view model. It is as if you don’t do MVVM, you don’t know how to <strong class="markup--strong markup--p-strong">create an object</strong> (if needed) for testing. I’ve also heard people tell me view controller is un-testable. Not only can I test it, I test it with storyboard not UI code. It’s not most efficient, yes, but that’s a long way from un-testable.</p><p name="ca5b" id="ca5b" class="graf graf--p graf-after--p">The testing using DI is total bullshit. I’ve covered it in my linked article above. DI is probably the worst way to do mocking. Think about it, why injecting a class that conforms to a protocol to provide a function that returns mock data in assignment, when you can just… assign mock data?</p><p name="dab9" id="dab9" class="graf graf--p graf-after--p">Before we look into Resolver, let’s hear from some dev using Swinject.</p><h3 name="2e1b" id="2e1b" class="graf graf--h3 graf-after--p">Why we don’t need Swinject</h3><blockquote name="e6bf" id="e6bf" class="graf graf--blockquote graf-after--h3">DI Container is a design pattern to implement Dependency injection. <strong class="markup--strong markup--blockquote-strong"><em class="markup--em markup--blockquote-em">Most of the time, you don’t need</em></strong><em class="markup--em markup--blockquote-em"> a Dependency Injection Container to benefit from Dependency Injection</em>. But when you need to manage a lot of different objects with a lot of dependencies, a Dependency Injection Container can be really helpful.</blockquote><p name="2ca1" id="2ca1" class="graf graf--p graf-after--blockquote">This is from the section “why we need Swinject”, in <a href="https://ali-akhtar.medium.com/ios-dependency-injection-using-swinject-9c4ceff99e41" data-href="https://ali-akhtar.medium.com/ios-dependency-injection-using-swinject-9c4ceff99e41" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">iOS Dependency Injection Using Swinject</a>.</p><p name="0fe3" id="0fe3" class="graf graf--p graf-after--p">Read between the lines.</p><ol class="postList"><li name="cc43" id="cc43" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Most of the time</strong> you don’t need DI container to benefit from DI.</li><li name="e44e" id="e44e" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">WHEN </strong>you need to manage a lot of different objects with a lot of dependencies</li></ol><p name="9ad2" id="9ad2" class="graf graf--p graf-after--li">So only in a small amount of the time <strong class="markup--strong markup--p-strong">WHEN </strong>you need to manage a lot of different objects with a lot of dependencies.</p><p name="3919" id="3919" class="graf graf--p graf-after--p">That is not how they sell DI container. They use it <strong class="markup--strong markup--p-strong">ALL THE TIME, </strong>for something as trivial as a tutorial example. Point 1 is consistent with our previous discussion where function API suffices.</p><p name="05d3" id="05d3" class="graf graf--p graf-after--p">If only small amount of time when you actually need to manage a lot of dependencies, yet they have to use it all the time to sell you this concept, what do you think will happen?</p><p name="e8ec" id="e8ec" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Create dependencies when you don’t need it.</strong></p><p name="17d3" id="17d3" class="graf graf--p graf-after--p">E.g.; you don’t need <code class="markup--code markup--p-code">URLSession</code> dependency, you probably don’t need <code class="markup--code markup--p-code">AssetService</code> dependency when you refactor out <code class="markup--code markup--p-code">AssetService</code> altogether. If you don’t do stupid MVVM, there’s no view model either.</p><p name="8b71" id="8b71" class="graf graf--p graf-after--p">The hierarchy then becomes: View -&gt; Controller -&gt; Network Service.</p><p name="77b3" id="77b3" class="graf graf--p graf-after--p">Isn’t the whole point of design / refactor to make things <strong class="markup--strong markup--p-strong">SIMPLER</strong>?</p><p name="5274" id="5274" class="graf graf--p graf-after--p">On the other hand, he does have legit refactor reasons though:</p><blockquote name="0386" id="0386" class="graf graf--blockquote graf-after--p">What can we observe by looking into this complex dependencies:</blockquote><blockquote name="415d" id="415d" class="graf graf--blockquote graf-after--blockquote">Duplicate code in Client A and Client B.</blockquote><blockquote name="e270" id="e270" class="graf graf--blockquote graf-after--blockquote">Can we have a central location, whose responsibility is to provide object by creating all its dependencies?</blockquote><p name="787c" id="787c" class="graf graf--p graf-after--blockquote">I guess that’s why he has 1K followers. There should be refactor reason for every design you do. But keep in mind he is assuming you are encountering a lot of dependencies, which should not be the case, like he said himself, <strong class="markup--strong markup--p-strong">most of the time</strong>. And the <em class="markup--em markup--p-em">duplicate code</em> he mentioned there is not some concrete function implementation. It is <em class="markup--em markup--p-em">object initialization</em><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">.</em></strong> A problem he created.</p><p name="191c" id="191c" class="graf graf--p graf-after--p">You have to wonder, if it takes this much effort to refactor <em class="markup--em markup--p-em">object initialization</em>, how is he supposed to handle function refactor? More singletons? First spot to check is protocol extension.</p><figure name="b47c" id="b47c" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*3Synvzu9-CBez5OfY3bUxw.png" data-width="363" data-height="208" src="https://cdn-images-1.medium.com/max/800/1*3Synvzu9-CBez5OfY3bUxw.png"></figure><p name="367e" id="367e" class="graf graf--p graf-after--figure">… which is non-existent.</p><p name="9af1" id="9af1" class="graf graf--p graf-after--p">He got another thing right though, by comparison. Note how he didn’t use <code class="markup--code markup--p-code">protocol NetworkService</code> , which will result in multiple network service objects that are supposed to implement fetch differently. But a network fetch has to follow HTTP, you’ll just end up with the same fetch.</p><p name="4d84" id="4d84" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">protocol Fetcher</code> , on the other hand, frees you from the restriction of “network”, e.g.; you can fetch from db, server, etc… which naturally requires different implementation, thereby justifying the abstraction. This is what I called, “refactor reason”, not following dogma on Internet blindly.</p><p name="99d8" id="99d8" class="graf graf--p graf-after--p">This is the skill difference in design pattern understanding and protocol desigh. But then he fell off the cliff.</p><figure name="b22f" id="b22f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*I67Bvu_gUFIhRZ9gaiMqDQ.png" data-width="1145" data-height="670" src="https://cdn-images-1.medium.com/max/800/1*I67Bvu_gUFIhRZ9gaiMqDQ.png"><figcaption class="imageCaption">refactor this</figcaption></figure><p name="a0c2" id="a0c2" class="graf graf--p graf-after--figure">The key here is<em class="markup--em markup--p-em"> function over object.</em></p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="430e" id="430e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataFetcher</span> {<br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">fromDB</span>(<span class="hljs-operator">...</span>) {<span class="hljs-operator">...</span>}<br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">fromServer</span>(<span class="hljs-operator">...</span>) {<span class="hljs-operator">...</span>}<br />  <span class="hljs-operator">...</span><br />}</span></pre><p name="e1f1" id="e1f1" class="graf graf--p graf-after--pre">ClientA should know the specific method to fetch data, because it has to provide arguments, e.g.; endpoint for network fetch, db commands for database. These abstractions just slows ClientA down, most of which are not even necessary. Note that there are only object initialization shown in the example. What are these objects used for? Do you really need all that for the things you want to do? E.g.; dude I just want to do a quick db fetch, who design these dumb shit?</p><p name="f057" id="f057" class="graf graf--p graf-after--p">Then this simplifies to</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="ca1b" id="ca1b" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientA</span> {<br />  <span class="hljs-keyword">let</span> fetcher <span class="hljs-operator">=</span> <span class="hljs-type">DataFetcher</span>()<br />  <span class="hljs-keyword">let</span> dataA <span class="hljs-operator">=</span> fetcher.fromDB(<span class="hljs-operator">...</span>) <span class="hljs-comment">// init arguments become function arguments</span><br />  <span class="hljs-keyword">let</span> dataB <span class="hljs-operator">=</span> fetcher.fromServer(<span class="hljs-operator">...</span>) <span class="hljs-comment">// depends on interface</span><br />  <span class="hljs-comment">// do something with data</span><br />}</span></pre><p name="bfd9" id="bfd9" class="graf graf--p graf-after--pre">If ClientA needs to customize <code class="markup--code markup--p-code">fromDB</code> , extend it! And since you call from function API, you are not dependent on implementation. There’s power in specialization, in knowing the exact type in compile time. The hard part is not doing abstraction, is doing specialization!</p><p name="92a1" id="92a1" class="graf graf--p graf-after--p">This is just to point you in a general direction. I don’t want to put too much effort in examples without knowing the usage. On a side note, his code felt very Java, don’t you think? Where’s the Swiftyness?</p><p name="3b97" id="3b97" class="graf graf--p graf-after--p">Now, let’s say you still decided to use a library like Resolver. Let’s see what kind of problems you might face.</p><h4 name="06ff" id="06ff" class="graf graf--h4 graf-after--p">Anti-pattern factory</h4><p name="6c7f" id="6c7f" class="graf graf--p graf-after--h4">A code snippet of the fabled <code class="markup--code markup--p-code">resolve</code> function that bears the hallmark of the pinnacle DI from <a href="https://github.com/hmlongco/Resolver/blob/master/Sources/Resolver/Resolver.swift" data-href="https://github.com/hmlongco/Resolver/blob/master/Sources/Resolver/Resolver.swift" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Resolver github</a>.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="4f53" id="4f53" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">resolve</span>&lt;<span class="hljs-type">Service</span>&gt;(<span class="hljs-keyword">_</span> <span class="hljs-params">type</span>: <span class="hljs-type">Service</span>.<span class="hljs-keyword">Type</span> <span class="hljs-operator">=</span> <span class="hljs-type">Service</span>.<span class="hljs-keyword">self</span>, <span class="hljs-params">name</span>: <span class="hljs-type">Resolver</span>.<span class="hljs-type">Name</span>? <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>, <span class="hljs-params">args</span>: <span class="hljs-keyword">Any</span><span class="hljs-operator">?</span> <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>) -&gt; <span class="hljs-type">Service</span> {<br />        lock.lock()<br />        <span class="hljs-keyword">defer</span> { lock.unlock() }<br />        registrationCheck()<br />        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> registration <span class="hljs-operator">=</span> root.lookup(type, name: name), <span class="hljs-keyword">let</span> service <span class="hljs-operator">=</span> registration.resolve(resolver: root, args: args) {<br /><span class="hljs-keyword">#if</span> <span class="hljs-type">DEBUG</span><br />            <span class="hljs-type">Resolver</span>.decorate<span class="hljs-operator">?</span>(service)<br /><span class="hljs-keyword">#endif</span><br />            <span class="hljs-keyword">return</span> service<br />        }<br />        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;RESOLVER: &#x27;<span class="hljs-subst">\(Service.<span class="hljs-keyword">self</span>)</span>:<span class="hljs-subst">\(name<span class="hljs-operator">?</span>.rawValue <span class="hljs-operator">??</span> <span class="hljs-string">&quot;NONAME&quot;</span>)</span>&#x27; not resolved. To disambiguate optionals use resolver.optional().&quot;</span>)<br />    }</span></pre><p name="4d2a" id="4d2a" class="graf graf--p graf-after--pre">Is that… <strong class="markup--strong markup--p-strong">LOCK</strong>? As in locks for threading?</p><p name="d5a0" id="d5a0" class="graf graf--p graf-after--p">Recall that this happens when you create an object. E.g.; <code class="markup--code markup--p-code">let fetcher = container.resolve(Fetcher.self, ... )</code></p><p name="a4d1" id="a4d1" class="graf graf--p graf-after--p">In what universe do you think a hidden lock during object creation is considered to be normal? You don’t need locks to do the same thing with SDK, but with library you somehow become involved in threading <strong class="markup--strong markup--p-strong">IMPLICITLY</strong>?</p><p name="87f8" id="87f8" class="graf graf--p graf-after--p">Look, I don’t know why it needs a lock, and it may well be justified. I’d even give it the benefits of doubt that it won’t cause performance impact on most use cases. But the fact is that it does something you shouldn’t have to do in the first place, for EVERY object, WITHOUT you knowing, to solve a problem it created.</p><p name="4e5a" id="4e5a" class="graf graf--p graf-after--p">Dude, I run a half meme / half rant channel here, yet even I have higher code quality standards than this. If it can’t solve the problem without inflicting side effects like <strong class="markup--strong markup--p-strong">LOCKING</strong>, then it shoudn’t pretend to be a solution.</p><p name="8abb" id="8abb" class="graf graf--p graf-after--p">Then, there’s <code class="markup--code markup--p-code">fatalError</code> . You should never have this in production code. You want to log it then enter error handling and try to recover. This is something you put in #if DEBUG, which is right above. But then he has to handle optional. This is what happens when you use static properties to store runtime objects. You now have to introduce optional to the system and cause optional unwrap cascade. Remember this quesiton?</p><blockquote name="6dd5" id="6dd5" class="graf graf--blockquote graf-after--p">Can we have a central location, whose responsibility is to provide object by creating all its dependencies?</blockquote><p name="ecd6" id="ecd6" class="graf graf--p graf-after--blockquote">That is one reason why the answer is no. In one function, this library has introduced implict thread <code class="markup--code markup--p-code">lock</code> , <code class="markup--code markup--p-code">fatalError</code> crash or optional as extra complexity to your system.</p><p name="56bb" id="56bb" class="graf graf--p graf-after--p">To be fair, I’m only the bottom 1000 technical writer on this platform. It is entirely possible that I got it all wrong. I didn’t really study it that much because I think it’s dumb to have that many dependencies to begin with.</p><p name="4c55" id="4c55" class="graf graf--p graf-after--p">That being said, let’s try to improve it. Observe that all @Injected does is to call <code class="markup--code markup--p-code">resolve</code> for you:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="759f" id="759f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">@propertyWrapper</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Injected</span>&lt;<span class="hljs-title class_">Service</span>&gt; {<br />    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> service: <span class="hljs-type">Service</span><br />    <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>() {<br />        <span class="hljs-keyword">self</span>.service <span class="hljs-operator">=</span> <span class="hljs-type">Resolver</span>.resolve(<span class="hljs-type">Service</span>.<span class="hljs-keyword">self</span>)<br />    }<br />    <span class="hljs-operator">...</span><br />}</span></pre><p name="ec21" id="ec21" class="graf graf--p graf-after--pre">And in order to “resolve”, it has to lock. So how about don’t do me this “favor”? I’ll resolve it myself, since I have to register it anyway. It will be like dynamic programming. E.g.;</p><p name="e3eb" id="e3eb" class="graf graf--p graf-after--p">To create A, I need B, which needs C.</p><p name="1c8f" id="1c8f" class="graf graf--p graf-after--p">To create D, I need A and E.</p><p name="9f80" id="9f80" class="graf graf--p graf-after--p">To create F, I need A and G.</p><p name="d813" id="d813" class="graf graf--p graf-after--p">I’ll create A manually first. Register it to a property <code class="markup--code markup--p-code">var a: A</code> in singleton. When I create D, I can use <code class="markup--code markup--p-code">a</code> directly instead of recreating it with B and C. Same goes with F. Then you can use <code class="markup--code markup--p-code">var d</code> and <code class="markup--code markup--p-code">var f</code> as well, and so on.</p><p name="9730" id="9730" class="graf graf--p graf-after--p">Some of them have to be computed properties to account for property changes. It’s good, because computed properties can be added via extension. For example, if I want an default object that won’t be overwritten during runtime, I extend it with a computed property. In fact I don’t even need “registry”.</p><p name="3686" id="3686" class="graf graf--p graf-after--p">I’d argue this is even more efficient and I have direct control over the “resolve” of complex dependencies. I’d even go so far as to say that I don’t even need a <em class="markup--em markup--p-em">central location</em>. E.g.;</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="2a8f" id="2a8f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectCreatorA</span> {<br />  <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> p1 <span class="hljs-operator">...</span> <br />  <span class="hljs-operator">...</span><br />}<br /><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectCreatorB</span> {<br />  <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> p2 <span class="hljs-operator">...</span> <br />   <span class="hljs-operator">...</span><br />}<br /><span class="hljs-operator">...</span></span></pre><p name="7913" id="7913" class="graf graf--p graf-after--pre">Have you considered any of these alternatives before jumping straight to singleton?</p><p name="f365" id="f365" class="graf graf--p graf-after--p">The last example I’m going to discuss is this:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="4f4a" id="4f4a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NamedInjectedViewController</span>: <span class="hljs-title class_">UIViewController</span> {<br />    <span class="hljs-keyword">var</span> editMode: <span class="hljs-type">Bool</span> <span class="hljs-comment">// set, perhaps, by calling segue</span><br />    <span class="hljs-meta">@LazyInjected</span> <span class="hljs-keyword">var</span> viewModel: <span class="hljs-type">XYZViewModelProtocol</span><br />    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewDidLoad</span>() {<br />        <span class="hljs-keyword">super</span>.viewDidLoad()<br />        <span class="hljs-variable">$viewModel</span>.name <span class="hljs-operator">=</span> editMode <span class="hljs-operator">?</span> .edit : .add<br />        viewModel.load()<br />    }<br />}</span></pre><p name="9d3d" id="9d3d" class="graf graf--p graf-after--pre">Step by step breakdown:</p><ol class="postList"><li name="a5d3" id="a5d3" class="graf graf--li graf-after--p">Put everything in a sink object called view model. (I love how this is considered a display of skill, this is not refactor, this is repackaging which requires overheads like callback, it’s not a free lunch)</li><li name="3e73" id="3e73" class="graf graf--li graf-after--li">Ignore binding completely, the view in view controller won’t update itself; you need some kind of callback.</li><li name="5d93" id="5d93" class="graf graf--li graf-after--li">Ccreate a protocol for wrong DI reason. Check: view controller depends on <em class="markup--em markup--li-em">functions </em>from the view model API; the same <em class="markup--em markup--li-em">functions </em>you are going to put in protocol.</li><li name="4b8e" id="4b8e" class="graf graf--li graf-after--li">Since protocol is created after view model, it isn’t exactly what I call protocol-oriented. You may argue that he can start with protocol and build view model later. His protocol still has to describe everything without default implementation. It isn’t POP either.</li><li name="0263" id="0263" class="graf graf--li graf-after--li">Check: what he has done so far. He re-packages everything into an object then create a protocol to re-describe API.</li><li name="5732" id="5732" class="graf graf--li graf-after--li">To support <code class="markup--code markup--li-code">editMode</code> , his only choice is to use polymorphism because he already uses view model as a protocol object to hook up everything with view controller. If he doesn’t use inheritance, then he has to create another view model class object from scratch.</li><li name="f830" id="f830" class="graf graf--li graf-after--li">Check: do you see a pattern? If you start with an object that contains everything then are forced to use it as a protocol object, polymorphism is going to be your solution to everything. <strong class="markup--strong markup--li-strong">Polymorphsim-oriented programming.</strong></li><li name="baad" id="baad" class="graf graf--li graf-after--li">Btw he is also the guy who publishes <a href="https://betterprogramming.pub/best-practices-in-swiftui-composition-282b02772a24" data-href="https://betterprogramming.pub/best-practices-in-swiftui-composition-282b02772a24" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Best Practices in SwiftUI Composition</a> in which he talks about <strong class="markup--strong markup--li-strong">view composition instead of protocol composition. </strong>Published in <em class="markup--em markup--li-em">better programming</em> and member-only no less. No, don’t waste your monthly free reads to watch it. I regret it to this day. This is consistent with what we observed so far.</li><li name="5c59" id="5c59" class="graf graf--li graf-after--li">Let’s compare it with what I might do:</li></ol><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="e1c4" id="e1c4" class="graf graf--pre graf-after--li graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewController</span>: <span class="hljs-title class_">UIViewController</span> {<br />  <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> edit <span class="hljs-operator">=</span> <span class="hljs-type">EditViewModel</span>()<br />  <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> add <span class="hljs-operator">=</span> <span class="hljs-type">AddViewModel</span>()<br />  <span class="hljs-keyword">var</span> editMode <span class="hljs-operator">=</span> <span class="hljs-literal">false</span><br />  <span class="hljs-keyword">let</span> vm: <span class="hljs-type">ViewModelProtocol</span> <span class="hljs-operator">=</span> <span class="hljs-type">ViewController</span>.edit<br />  <span class="hljs-operator">...</span><br />  vm <span class="hljs-operator">=</span> editMode <span class="hljs-operator">?</span> <span class="hljs-type">ViewController</span>.edit : <span class="hljs-type">ViewController</span>.add<br />  <span class="hljs-comment">// vm needs binding</span><br />}<br /><br /></span></pre><p name="f70f" id="f70f" class="graf graf--p graf-after--pre">Slower? I don’t need to bother with registry, naming, @Injected…etc. Everything is in one place. And remember there’s auto-complete, and this doesn’t have hidden side effects of thread locks or god knows what.</p><p name="9810" id="9810" class="graf graf--p graf-after--p">OK. Let’s summarize.</p><h4 name="2865" id="2865" class="graf graf--h4 graf-after--p">They are professionals</h4><figure name="d59c" id="d59c" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*j76ecVaPq7XcHylsbhVAgA.png" data-width="1134" data-height="535" src="https://cdn-images-1.medium.com/max/800/1*j76ecVaPq7XcHylsbhVAgA.png"><figcaption class="imageCaption">He is a professional</figcaption></figure><p name="abf7" id="abf7" class="graf graf--p graf-after--figure">I’ve talked about one commercial grade tutorial written by a hired professional; one article about Swinject written by a senior iOS dev with 1K followers; and a library written by a top 1000 technical writter on this platform.</p><p name="1ca2" id="1ca2" class="graf graf--p graf-after--p">My opinion is that, they are all wrong. Not only that they are wrong, they are rewarded and become part of a commercial program to pump corporate dog shits.</p><p name="a5bc" id="a5bc" class="graf graf--p graf-after--p">It is not about refactor. Only one of them vaguely mentions code duplication of object initialization, which should not become a problem in the first place. None of them recognize the basic fact that interface doesn’t mean protocol only, and the concept of over-generalization. None of them bother to justify the use of singleton, or attempt alternatives.</p><p name="9576" id="9576" class="graf graf--p graf-after--p">It’s about selling you a product. Consume the product, and be excited for the next product.</p><p name="b17a" id="b17a" class="graf graf--p graf-after--p">I’ve checked the source code of Swinject and it has locks as well. There’s no avoiding this dumb shit. If you don’t need lock in standard SDK operation, you shouldn’t need lock with library (that claims to help you create objects!). I have higher code standards than 3 <em class="markup--em markup--p-em">professionals </em>COMBINED.</p><p name="c9c2" id="c9c2" class="graf graf--p graf-after--p">Majority don’t mean right. Galileo was alone when he said earth is not flat. Minority don’t mean right either. I provided my arguments, you can make your call.</p><p name="8cdc" id="8cdc" class="graf graf--p graf-after--p">I’ll conclude by saying how much I love watching top professionals’ work:</p><p name="e342" id="e342" class="graf graf--p graf-after--p">view model without binding -&gt; DI but ignore function API -&gt; create dependencies to manage dependencies -&gt; singleton without justification -&gt; property wrapper with insane side effects -&gt; polymorphism as solution to everything -&gt; mocking using boilerplate injection -&gt; no inheritance and no extensions -&gt; lack of computed properties -&gt; view composition as best practice of POP.</p><blockquote name="2dd7" id="2dd7" class="graf graf--blockquote graf-after--p">Design patterns create weak men,</blockquote><blockquote name="e622" id="e622" class="graf graf--blockquote graf-after--blockquote graf--trailing">and weak men create hard times</blockquote></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/306047f1036c"><time class="dt-published" datetime="2022-12-06T06:50:52.539Z">December 6, 2022</time></a>.</p><p><a href="https://medium.com/@swift2931/when-dependency-injection-blows-up-in-your-face-306047f1036c" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>