<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>The last of POP</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">The last of POP</h1>
</header>
<section data-field="subtitle" class="p-summary">
Survive the post apocalyptic world where MVVM has turned most devs into zombies
</section>
<section data-field="body" class="e-content">
<section name="1676" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="2f69" id="2f69" class="graf graf--h3 graf--leading graf--title">The last of POP</h3><h4 name="5bc2" id="5bc2" class="graf graf--h4 graf-after--h3 graf--subtitle">Survive the post apocalyptic world where MVVM has turned most devs into zombies</h4><figure name="5470" id="5470" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*Lsi6qTcyDLgl8uHpMaJ6vg.png" data-width="840" data-height="473" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*Lsi6qTcyDLgl8uHpMaJ6vg.png"><figcaption class="imageCaption">The last of two people who know how to write POP</figcaption></figure><h4 name="de62" id="de62" class="graf graf--h4 graf-after--figure">When you are lost in the darkness, turn on the damn light</h4><p name="fc86" id="fc86" class="graf graf--p graf-after--h4">Decided to write a code review while waiting on the new episode of the last of us on HBO.</p><p name="bc7b" id="bc7b" class="graf graf--p graf-after--p">There are only two people in the world right now who can write POP. One is the dude in Apple that pitches Swift as the first POP language; the other one, well, is not anyone who writes MVVM.</p><p name="62ff" id="62ff" class="graf graf--p graf-after--p">There are 3 quick checks to see if a dev knows POP:</p><ol class="postList"><li name="2d26" id="2d26" class="graf graf--li graf-after--p">If he uses view model =&gt; he doesn’t know shit</li><li name="4086" id="4086" class="graf graf--li graf-after--li">If he uses protocol extension =&gt; if not, he doesn’t refactor for shit</li><li name="db43" id="db43" class="graf graf--li graf-after--li">If he uses computed properties effectively =&gt; we will later see an example</li></ol><p name="42ca" id="42ca" class="graf graf--p graf-after--li">Note that these are not even direct checks to underlying principles of POP. The hard truth is that most devs fail even at the basic refactor. Let’s look at an example:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="48be" id="48be" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrdersAPI</span>: <span class="hljs-title class_">OrdersStoreProtocol</span>, <span class="hljs-title class_">OrdersStoreUtilityProtocol</span><br />{<br />  <span class="hljs-comment">// MARK: - CRUD operations - Optional error</span><br />  <br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">fetchOrders</span>(<span class="hljs-params">completionHandler</span>: <span class="hljs-keyword">@escaping</span> ([<span class="hljs-type">Order</span>], <span class="hljs-type">OrdersStoreError</span>?) -&gt; <span class="hljs-type">Void</span>)<br />  {<br />  }<br />  <br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">fetchOrder</span>(<span class="hljs-params">id</span>: <span class="hljs-type">String</span>, <span class="hljs-params">completionHandler</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">Order</span>?, <span class="hljs-type">OrdersStoreError</span>?) -&gt; <span class="hljs-type">Void</span>)<br />  {<br />  }<br />  <br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">createOrder</span>(<span class="hljs-params">orderToCreate</span>: <span class="hljs-type">Order</span>, <span class="hljs-params">completionHandler</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">Order</span>?, <span class="hljs-type">OrdersStoreError</span>?) -&gt; <span class="hljs-type">Void</span>)<br />  {<br />  }<br />  <br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">updateOrder</span>(<span class="hljs-params">orderToUpdate</span>: <span class="hljs-type">Order</span>, <span class="hljs-params">completionHandler</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">Order</span>?, <span class="hljs-type">OrdersStoreError</span>?) -&gt; <span class="hljs-type">Void</span>)<br />  {<br />  }<br />  <br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">deleteOrder</span>(<span class="hljs-params">id</span>: <span class="hljs-type">String</span>, <span class="hljs-params">completionHandler</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">Order</span>?, <span class="hljs-type">OrdersStoreError</span>?) -&gt; <span class="hljs-type">Void</span>)<br />  {<br />  }<br />  <br />  <span class="hljs-comment">// MARK: - CRUD operations - Generic enum result type</span><br />  <br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">fetchOrders</span>(<span class="hljs-params">completionHandler</span>: <span class="hljs-keyword">@escaping</span> <span class="hljs-type">OrdersStoreFetchOrdersCompletionHandler</span>)<br />  {<br />  }<br />  <br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">fetchOrder</span>(<span class="hljs-params">id</span>: <span class="hljs-type">String</span>, <span class="hljs-params">completionHandler</span>: <span class="hljs-keyword">@escaping</span> <span class="hljs-type">OrdersStoreFetchOrderCompletionHandler</span>)<br />  {<br />  }<br />  <br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">createOrder</span>(<span class="hljs-params">orderToCreate</span>: <span class="hljs-type">Order</span>, <span class="hljs-params">completionHandler</span>: <span class="hljs-keyword">@escaping</span> <span class="hljs-type">OrdersStoreCreateOrderCompletionHandler</span>)<br />  {<br />  }<br />  <br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">updateOrder</span>(<span class="hljs-params">orderToUpdate</span>: <span class="hljs-type">Order</span>, <span class="hljs-params">completionHandler</span>: <span class="hljs-keyword">@escaping</span> <span class="hljs-type">OrdersStoreUpdateOrderCompletionHandler</span>)<br />  {<br />  }<br />  <br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">deleteOrder</span>(<span class="hljs-params">id</span>: <span class="hljs-type">String</span>, <span class="hljs-params">completionHandler</span>: <span class="hljs-keyword">@escaping</span> <span class="hljs-type">OrdersStoreDeleteOrderCompletionHandler</span>)<br />  {<br />  }<br />  <br />  <span class="hljs-comment">// MARK: - CRUD operations - Inner closure</span><br />  <br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">fetchOrders</span>(<span class="hljs-params">completionHandler</span>: <span class="hljs-keyword">@escaping</span> (() <span class="hljs-keyword">throws</span> -&gt; [<span class="hljs-type">Order</span>]) -&gt; <span class="hljs-type">Void</span>)<br />  {<br />  }<br />  <br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">fetchOrder</span>(<span class="hljs-params">id</span>: <span class="hljs-type">String</span>, <span class="hljs-params">completionHandler</span>: <span class="hljs-keyword">@escaping</span> (() <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">Order</span>?) -&gt; <span class="hljs-type">Void</span>)<br />  {<br />  }<br />  <br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">createOrder</span>(<span class="hljs-params">orderToCreate</span>: <span class="hljs-type">Order</span>, <span class="hljs-params">completionHandler</span>: <span class="hljs-keyword">@escaping</span> (() <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">Order</span>?) -&gt; <span class="hljs-type">Void</span>)<br />  {<br />  }<br />  <br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">updateOrder</span>(<span class="hljs-params">orderToUpdate</span>: <span class="hljs-type">Order</span>, <span class="hljs-params">completionHandler</span>: <span class="hljs-keyword">@escaping</span> (() <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">Order</span>?) -&gt; <span class="hljs-type">Void</span>)<br />  {<br />  }<br />  <br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">deleteOrder</span>(<span class="hljs-params">id</span>: <span class="hljs-type">String</span>, <span class="hljs-params">completionHandler</span>: <span class="hljs-keyword">@escaping</span> (() <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">Order</span>?) -&gt; <span class="hljs-type">Void</span>)<br />  {<br />  }<br />}</span></pre><p name="ee04" id="ee04" class="graf graf--p graf-after--pre">Refactor this.</p><p name="2542" id="2542" class="graf graf--p graf-after--p">Note that he has to write an <code class="markup--code markup--p-code">OrderAPI</code> for a specific return type <code class="markup--code markup--p-code">Order</code> , he has to write 4 variations for different http methods, plus 1 fetch with an extra argument, then he has to write 3 variations of each variation for different completion handler types.</p><p name="b2d2" id="b2d2" class="graf graf--p graf-after--p">You should be able to do it with 1. You write one, he needs to write at least 15. And you can reuse the same one for different endpoints.</p><p name="5b46" id="5b46" class="graf graf--p graf-after--p">Applying our checks, there’s no sign of protocol extension that might help you implement these; there are no computed properties anywhere.</p><p name="054a" id="054a" class="graf graf--p graf-after--p">It’s all but guaranteed that he would create a view model somewhere from this sheer dog shit level of refactor, and he did.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="a4e6" id="a4e6" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">  <span class="hljs-keyword">func</span> <span class="hljs-title function_">presentUpdatedOrder</span>(<span class="hljs-params">response</span>: <span class="hljs-type">CreateOrder</span>.<span class="hljs-type">UpdateOrder</span>.<span class="hljs-type">Response</span>)<br />  {<br />    <span class="hljs-keyword">let</span> viewModel <span class="hljs-operator">=</span> <span class="hljs-type">CreateOrder</span>.<span class="hljs-type">UpdateOrder</span>.<span class="hljs-type">ViewModel</span>(order: response.order)<br />    viewController<span class="hljs-operator">?</span>.displayUpdatedOrder(viewModel: viewModel)<br />  }</span></pre><p name="4f07" id="4f07" class="graf graf--p graf-after--pre">I know what you are thinking, that I’m cherry-picking the worst case to make my point.</p><p name="0f64" id="0f64" class="graf graf--p graf-after--p">This came straight from clean swift github: <a href="https://github.com/Clean-Swift/CleanStore" data-href="https://github.com/Clean-Swift/CleanStore" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">clean store</a>, written by Mr. <em class="markup--em markup--p-em">Clean Swift</em> himself. From <a href="https://clean-swift.com/vip-cycle-or-property/" data-href="https://clean-swift.com/vip-cycle-or-property/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">whom </a>I quote:</p><blockquote name="9290" id="9290" class="graf graf--blockquote graf-after--p">I wanted to make sure<strong class="markup--strong markup--blockquote-strong"> I didn’t create a bloated architecture</strong> that adds cruft instead of substance</blockquote><p name="35f4" id="35f4" class="graf graf--p graf-after--blockquote">He did not succeed.</p><p name="de4b" id="de4b" class="graf graf--p graf-after--p">The important lesson here is that <strong class="markup--strong markup--p-strong">before you even think about design pattern, refactor your shit. But even if you didn’t refactor your shit, you can sell it as clean. </strong>Greater fool theory is that, well, there’s always a greater fool.</p><p name="e9ef" id="e9ef" class="graf graf--p graf-after--p">When you are lost in the darkness, I am that light.</p><h4 name="5193" id="5193" class="graf graf--h4 graf--startsWithDoubleQuote graf-after--p">“I will not turn in to one of those things. Come on. Make this easy for me”</h4><p name="11de" id="11de" class="graf graf--p graf-after--h4">I heard you. You have some integrity, and you heard POP fixed some problems so you wanted to learn more. Then you went to <a href="https://www.kodeco.com/books/expert-swift/v1.0/chapters/3-protocols" data-href="https://www.kodeco.com/books/expert-swift/v1.0/chapters/3-protocols" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">THE NEW RAYWENDERLICH.COM</a> for a POP lesson in <em class="markup--em markup--p-em">expert Swift</em>.</p><p name="f839" id="f839" class="graf graf--p graf-after--p">It’s there you got infected by MVVM virus, and the story ends.</p><p name="cd25" id="cd25" class="graf graf--p graf-after--p">How did this happen? We have to examine the corporate sales pitch that is <em class="markup--em markup--p-em">expert Swift</em>.</p><p name="9aa5" id="9aa5" class="graf graf--p graf-after--p">Obviously there has to be a view model for <em class="markup--em markup--p-em">expert</em> level content. So you feel like an <em class="markup--em markup--p-em">expert</em>. It obviously won’t have binding and won’t dicuss the fact you have to create one for each API endpoint.</p><p name="8590" id="8590" class="graf graf--p graf-after--p">In the protocol oriented programming section of the tutorial, you will find this example:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="b1bb" id="b1bb" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Request</span> {<br />  <span class="hljs-keyword">var</span> url: <span class="hljs-type">URL</span> { <span class="hljs-keyword">get</span> }<br />  <span class="hljs-keyword">var</span> method: <span class="hljs-type">HTTPMethod</span> { <span class="hljs-keyword">get</span> }<br />}</span></pre><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="2f80" id="2f80" class="graf graf--pre graf-after--pre graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArticleRequest</span>: <span class="hljs-title class_">Request</span> {<br />  <span class="hljs-keyword">var</span> url: <span class="hljs-type">URL</span> {<br />    <span class="hljs-keyword">let</span> baseURL <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://api.raywenderlich.com/api&quot;</span><br />    <span class="hljs-keyword">let</span> path <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/contents?filter[content_types][]=article&quot;</span><br />    <span class="hljs-keyword">return</span> <span class="hljs-type">URL</span>(string: baseURL <span class="hljs-operator">+</span> path)<span class="hljs-operator">!</span><br />  }<br /><br />  <span class="hljs-keyword">var</span> method: <span class="hljs-type">HTTPMethod</span> { .get }<br />}</span></pre><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="7963" id="7963" class="graf graf--pre graf-after--pre graf--preV2"><span class="pre--content"><span class="hljs-keyword">import</span> Combine<br /><br /><span class="hljs-keyword">class</span> <span class="hljs-title class_">Networker</span> {<br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">request</span>: <span class="hljs-type">Request</span>) -&gt; <span class="hljs-type">AnyPublisher</span>&lt;<span class="hljs-type">Data</span>, <span class="hljs-type">URLError</span>&gt; {<br />    <span class="hljs-keyword">var</span> urlRequest <span class="hljs-operator">=</span> <span class="hljs-type">URLRequest</span>(url: request.url)<br />    urlRequest.httpMethod <span class="hljs-operator">=</span> request.method.rawValue<br /><br />    <span class="hljs-keyword">return</span> <span class="hljs-type">URLSession</span>.shared<br />      .dataTaskPublisher(for: urlRequest)<br />      .compactMap { <span class="hljs-variable">$0</span>.data }<br />      .eraseToAnyPublisher()<br />  }<br />}</span></pre><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="4394" id="4394" class="graf graf--pre graf-after--pre graf--preV2"><span class="pre--content"><span class="hljs-keyword">init</span>(<span class="hljs-params">networker</span>: <span class="hljs-type">Networking</span>) {<br />  <span class="hljs-keyword">self</span>.networker <span class="hljs-operator">=</span> networker<br />}</span></pre><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="bf8c" id="bf8c" class="graf graf--pre graf-after--pre graf--preV2"><span class="pre--content"><span class="hljs-meta">@ObservedObject</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> viewModel <span class="hljs-operator">=</span> <span class="hljs-type">ArticlesViewModel</span>(<br />  networker: <span class="hljs-type">Networker</span>())</span></pre><p name="b199" id="b199" class="graf graf--p graf-after--pre">Note that he uses <code class="markup--code markup--p-code">HttpMethod</code> as an argument, and uses general type in function signature. That is 15 to 1 reduction comparing to <em class="markup--em markup--p-em">Clean Swift </em>right here.</p><p name="f4c2" id="f4c2" class="graf graf--p graf-after--p">Pop quiz: refactor this.</p><p name="df0f" id="df0f" class="graf graf--p graf-after--p">Obviously you want to refactor out <code class="markup--code markup--p-code">baseURL</code> , no point repeating (hard-coded even) in every request. <code class="markup--code markup--p-code">path</code> (or endpoint) and <code class="markup--code markup--p-code">method</code> can be parameters to <code class="markup--code markup--p-code">fetch(...)</code> . For a <code class="markup--code markup--p-code">post</code> you need payload, so you need an argument <code class="markup--code markup--p-code">params</code> , and some computed properties to build<code class="markup--code markup--p-code">params</code> on the fly.</p><p name="73c4" id="73c4" class="graf graf--p graf-after--p">Putting all these together in POP fashion, we may start with:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="b237" id="b237" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Fetch</span> {<br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-params">endpoint</span>: <span class="hljs-type">String</span>, <span class="hljs-params">method</span>: <span class="hljs-type">HttpMethod</span>, <span class="hljs-params">params</span>: <span class="hljs-type">JSON</span>, <span class="hljs-params">callback</span>: <span class="hljs-operator">...</span>) -&gt; <span class="hljs-operator">...</span> <br />}</span></pre><p name="ff9f" id="ff9f" class="graf graf--p graf-after--pre">Then we provide default implementation!</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="a0d4" id="a0d4" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Fetch</span> {<br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-params">endpoint</span>: <span class="hljs-type">String</span>, <span class="hljs-params">method</span>: <span class="hljs-type">HttpMethod</span>, <span class="hljs-params">params</span>: <span class="hljs-type">JSON</span>, <span class="hljs-params">callback</span>: <span class="hljs-operator">...</span>) -&gt; <span class="hljs-operator">...</span> {<br />    <span class="hljs-operator">...</span> <span class="hljs-comment">// build urlrequest</span><br />  }<br />}</span></pre><p name="3ff7" id="3ff7" class="graf graf--p graf-after--pre">We are refactoring before any object is created. The mindset is not we are waiting to be implemented; the mindset is we are creating a piece of functioning, self-contained code to be used as a mix-in, a library that involves instance variables.</p><p name="4d3f" id="4d3f" class="graf graf--p graf-after--p">Then we conform to it:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="d9eb" id="d9eb" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelWithState</span> {<span class="hljs-operator">...</span>} <span class="hljs-comment">// doesn&#x27;t have to be view-specific</span><br /> <br /><span class="hljs-keyword">extension</span> <span class="hljs-title class_">ModelWithState</span>: <span class="hljs-title class_">Fetch</span> {<br />  <span class="hljs-comment">// computed property</span><br />  <span class="hljs-keyword">var</span> params: <span class="hljs-type">JSON</span> {<span class="hljs-operator">...</span>}<br />}</span></pre><p name="4184" id="4184" class="graf graf--p graf-after--pre">Applying quick checks: we have protocol extension, computed property, and no view model.</p><p name="223a" id="223a" class="graf graf--p graf-after--p">Do we bother with <code class="markup--code markup--p-code">ArticleRequest</code> , <code class="markup--code markup--p-code">Networker</code> , <code class="markup--code markup--p-code">ArticleViewModel</code> , <code class="markup--code markup--p-code">init(...)</code> … etc?</p><p name="dc2b" id="dc2b" class="graf graf--p graf-after--p">Or in other words, why do you need all these objects? This isn’t OOP. Most of the efforts are in extension. <strong class="markup--strong markup--p-strong">Think in composition, build in extension.</strong></p><p name="9c61" id="9c61" class="graf graf--p graf-after--p">What does the <em class="markup--em markup--p-em">expert Swift</em> do? First thing he did is to add dependency to a specific view, e.g.; <code class="markup--code markup--p-code">struct ArticleRequest</code>. So if you want to call it from some other view, say <code class="markup--code markup--p-code">DogShit</code> , you have to create a <code class="markup--code markup--p-code">struct DogShitRequest: Request</code> , then <strong class="markup--strong markup--p-strong">HARD-CODE</strong> them as computed properties. You can’t even create an instance and mutate it later, e.g.;</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="64da" id="64da" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">var</span> req <span class="hljs-operator">=</span> <span class="hljs-type">DogShitRequest</span>()<br />req.method <span class="hljs-operator">=</span> .post <span class="hljs-comment">// you can&#x27;t</span></span></pre><p name="ba99" id="ba99" class="graf graf--p graf-after--pre">So to change <code class="markup--code markup--p-code">method</code> , you have to <strong class="markup--strong markup--p-strong">DECLARE A NEW TYPE</strong>, say</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="fb8b" id="fb8b" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DogShitRequestForPost</span>: <span class="hljs-title class_">Request</span> {<br />  <span class="hljs-comment">// copy paste baseURL again!</span><br />  <span class="hljs-comment">// ... </span><br />  <span class="hljs-keyword">var</span> method: <span class="hljs-type">HTTPMethod</span>{.post}<br />}<br />  </span></pre><p name="e682" id="e682" class="graf graf--p graf-after--pre">Do you know what <strong class="markup--strong markup--p-strong">VARIABLE</strong> is? Because <em class="markup--em markup--p-em">expert Swift </em>doesn’t!</p><p name="6fa4" id="6fa4" class="graf graf--p graf-after--p">You can determine if a design is dog shit from computed property. That’s why check#3 exists. As we have seen, <em class="markup--em markup--p-em">Clean Swfit</em> doesn’t even bother, <em class="markup--em markup--p-em">expert Swift </em>has it, but done it wrong.</p><p name="d47d" id="d47d" class="graf graf--p graf-after--p">But why is view model a problem? Because this view dependency came from view model, e.g; <code class="markup--code markup--p-code">ArticleViewModel</code> , then you build everything around it. There’s no POP to begin with. Just MVVM with a new paint. All paths lead to view model. Then view model gives you appearance of “clean”, “expert”, because nobody dares to challenge MVVM. Nobody but me.</p><p name="ea1c" id="ea1c" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Do you want to turn into one of those view model zombies?</strong></p><h4 name="e55f" id="e55f" class="graf graf--h4 graf-after--p">You can still rise with us</h4><p name="8f2d" id="8f2d" class="graf graf--p graf-after--h4">Believe in Fireflies. Uh, I mean POP.</p><p name="1d51" id="1d51" class="graf graf--p graf-after--p">MVVM devs still use protocol in very OOP way. Because creating an object called view model is a ritual, that is all they know. That’s why MVVM is stagnant. Take a guess where this <a href="https://clean-swift.com/protocol-oriented-principle/" data-href="https://clean-swift.com/protocol-oriented-principle/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">quote </a>is coming from:</p><blockquote name="318c" id="318c" class="graf graf--blockquote graf-after--p">There has been a lot of buzz ever since the 2015 WWDC talk on Protocol Oriented Programming. But the underlying principle has been around forever. Protocol is a feature provided by the programming language to facilitate <strong class="markup--strong markup--blockquote-strong">polymorphism</strong>.</blockquote><p name="fd25" id="fd25" class="graf graf--p graf-after--blockquote">lol no. POP is not just polymorphism. Otherwise why isn’t Java POP?</p><p name="db54" id="db54" class="graf graf--p graf-after--p">The keyword he should hightlight is <strong class="markup--strong markup--p-strong">extension</strong>.</p><p name="6ba8" id="6ba8" class="graf graf--p graf-after--p">Let me showcase this in a more complex example.</p><p name="066a" id="066a" class="graf graf--p graf-after--p">Step 0: Refactor</p><p name="4a7e" id="4a7e" class="graf graf--p graf-after--p">Observe that <code class="markup--code markup--p-code">fetch(...)</code> needs <code class="markup--code markup--p-code">baseURL</code> and <code class="markup--code markup--p-code">endpoint</code> , among many other arguments. Networking is <em class="markup--em markup--p-em">stateful</em>. You may need to keep track of progress, finishing status… etc, on top of providing storage for whatever resource you retrived from API call. This suggests that we need a<code class="markup--code markup--p-code">NetworkService</code> to manage at least <code class="markup--code markup--p-code">baseURL</code> and <code class="markup--code markup--p-code">endpoint</code> ; and a reference type <code class="markup--code markup--p-code">Resource</code> to provide storage and status tracking.</p><p name="dbef" id="dbef" class="graf graf--p graf-after--p">It might look like this:</p><p name="b26f" id="b26f" class="graf graf--p graf-after--p">Step1: Protocol</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="f738" id="f738" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Resource</span>: <span class="hljs-title class_">class</span> {<br />  <span class="hljs-comment">// url and delegate</span><br />  <span class="hljs-keyword">var</span> endpoint: <span class="hljs-type">String</span> {<span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span>}<br />  <span class="hljs-keyword">var</span> delegate: <span class="hljs-type">NetworkService</span>? {<span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span>}<br />  <span class="hljs-comment">// optional header and other params</span><br />  <span class="hljs-keyword">var</span> header: [<span class="hljs-type">String</span>: <span class="hljs-keyword">Any</span>]<span class="hljs-operator">?</span> {<span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span>}<br />  <span class="hljs-comment">// storage</span><br />  <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">ResourceType</span><br />  <span class="hljs-keyword">var</span> data: <span class="hljs-type">ResourceType</span> {<span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span>}<br />  <span class="hljs-comment">// status tracking</span><br />  <span class="hljs-keyword">var</span> status: <span class="hljs-type">ResourceStatus</span> {<span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span>}<br />  <span class="hljs-comment">// if you use Combine</span><br />  <span class="hljs-keyword">var</span> cancellable: <span class="hljs-type">AnyCancellable</span>? {<span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span>}<br />  <span class="hljs-comment">// restful</span><br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">post</span>(<span class="hljs-operator">...</span>)<br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">get</span>(<span class="hljs-operator">...</span>)<br />}<br /><br /></span></pre><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="b600" id="b600" class="graf graf--pre graf-after--pre graf--preV2"><span class="pre--content"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">NetworkService</span>: <span class="hljs-title class_">class</span> {<br />  <span class="hljs-keyword">var</span> commonHeader: [<span class="hljs-type">String</span>: <span class="hljs-keyword">Any</span>] {<span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span>}<br />  <span class="hljs-keyword">var</span> baseURL: <span class="hljs-type">String</span> {<span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span>}<br />  <span class="hljs-keyword">var</span> session: <span class="hljs-type">URLSession</span> {<span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span>}<br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">buildRequest</span>(<span class="hljs-operator">...</span>) -&gt; <span class="hljs-type">URLRequest</span>?<br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">dataTask</span>(<span class="hljs-operator">...</span>) -&gt; <span class="hljs-operator">...</span><br />  <span class="hljs-comment">// publishers if you use Combine</span><br />  <span class="hljs-operator">...</span><br />  <span class="hljs-comment">// various config functions</span><br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">configure</span>(<span class="hljs-operator">...</span>)<br />  <span class="hljs-comment">// chain request, reqular expression filter, other fancy shit</span><br />  <span class="hljs-operator">...</span><br />  <span class="hljs-comment">// error handler</span><br />  <span class="hljs-operator">...</span><br />}  </span></pre><p name="0771" id="0771" class="graf graf--p graf-after--pre">Step 2: Protocol extension</p><p name="ab8c" id="ab8c" class="graf graf--p graf-after--p">I leave it as an exercise. Only show an interesting example here:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="a289" id="a289" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Resource</span> {<br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">post</span>(<span class="hljs-operator">...</span>) -&gt; <span class="hljs-operator">...</span> {<br />    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> delegate <span class="hljs-operator">=</span> delegate <span class="hljs-keyword">else</span> {<span class="hljs-operator">...</span>}<br />    <span class="hljs-keyword">return</span> delegate.dataTaskPublisher(delegate.buildRequest(endpoint, <span class="hljs-operator">...</span>))<br />  }<br />}</span></pre><p name="02b1" id="02b1" class="graf graf--p graf-after--pre">Which one is dependency injection? <code class="markup--code markup--p-code">delegate</code> or <code class="markup--code markup--p-code">delegate.dataTaskPublisher(delegate.buildRequest(endpoint, …))</code> ?</p><p name="c2b9" id="c2b9" class="graf graf--p graf-after--p">Which one do you really need? Can you improve it if you are not going to change <code class="markup--code markup--p-code">delegate</code> ? Do you wonder why I don’t seem to bother with initializer? In fact it’s quick check #4: don’t bother with initializer.</p><p name="cb2f" id="cb2f" class="graf graf--p graf-after--p">Step 3: Conform</p><p name="1ae0" id="1ae0" class="graf graf--p graf-after--p">Up to this point, do I give a shit about polymorphism? I do not.</p><p name="f9c7" id="f9c7" class="graf graf--p graf-after--p">I started with a refactor, proposed a prototype interface, then provided default implementation, during which the prototype will be modified multiple times to adjust for problems found in implementation.</p><p name="b127" id="b127" class="graf graf--p graf-after--p">It’s about functions and properties and how they fit together to accomplish pre-determined tasks. I want the type to be as specific as possible, to the point I added <code class="markup--code markup--p-code">associatedtype</code> . This is how I would use it.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="bdbe" id="bdbe" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Json</span>: <span class="hljs-title class_">Resource</span> {<br />  <span class="hljs-keyword">typealias</span> <span class="hljs-type">ResourceType</span> <span class="hljs-operator">=</span> <span class="hljs-type">JSON</span>  <span class="hljs-comment">// Json != JSON, JSON = nested array or dict</span><br />  <span class="hljs-operator">...</span> <span class="hljs-comment">// specialization using JSON properties</span><br />}<br /><span class="hljs-keyword">class</span> <span class="hljs-title class_">RImage</span>: <span class="hljs-title class_">Resource</span> {<br />  <span class="hljs-keyword">typealias</span> <span class="hljs-type">ResourceType</span> <span class="hljs-operator">=</span> <span class="hljs-type">UIImage</span><br />   <span class="hljs-operator">...</span> <span class="hljs-comment">// specialization using UIImage properties</span><br />}</span></pre><p name="d87b" id="d87b" class="graf graf--p graf-after--pre">Would I type-erase both and pass them as protocol objects? No.</p><p name="6681" id="6681" class="graf graf--p graf-after--p">You implement the specialized part, while the rest has default implementation, and is refactored out already before you even create the object. The polymorphism is a byproduct; I only need 2, not 20. And I know it, so I specialize rather than generalize.</p><p name="772c" id="772c" class="graf graf--p graf-after--p">Dumb shIt on the other hand, requires nothing but type-erased protocol object, without protocol extension whatsoever, with initializer so complex that <strong class="markup--strong markup--p-strong">SINGLETONS </strong>for <strong class="markup--strong markup--p-strong">INSTANCE VARIABLES</strong> become acceptable.</p><p name="3a1a" id="3a1a" class="graf graf--p graf-after--p">We are not the same.</p><h4 name="3add" id="3add" class="graf graf--h4 graf-after--p">Swear to me</h4><blockquote name="385c" id="385c" class="graf graf--blockquote graf--startsWithDoubleQuote graf-after--h4">“Swear To Me That Everything That You Said About The Fireflies Was True.”</blockquote><p name="3d82" id="3d82" class="graf graf--p graf-after--blockquote">I’m gonna wrap up with some highlights, and go to bed. Wake up to watch the last of us.</p><figure name="cc82" id="cc82" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ll4mTtKjQP2NZZaEtzMcsw.png" data-width="904" data-height="239" src="https://cdn-images-1.medium.com/max/800/1*ll4mTtKjQP2NZZaEtzMcsw.png"></figure><p name="dad1" id="dad1" class="graf graf--p graf-after--figure">What does this “completely decoupled your view model from any outside dependencies” even mean?</p><p name="9ae8" id="9ae8" class="graf graf--p graf-after--p">Because from the looks of it, it <strong class="markup--strong markup--p-strong">COMPLETELY DEPENDS ON INSTANCE PROVIDED FROM OUTSIDE!</strong></p><p name="70a9" id="70a9" class="graf graf--p graf-after--p">First you can depend on function signature instead of protocol type. The “interface” does not mean protocol only.</p><p name="4ccf" id="4ccf" class="graf graf--p graf-after--p">Second, it’s a god damn fetch. What are you going to do? Swap out for another fetch that does the exact same http post for the exact same parameters??? Over-fking-generalization.</p><p name="2dc2" id="2dc2" class="graf graf--p graf-after--p">Third, why not use closure???</p><p name="53c1" id="53c1" class="graf graf--p graf-after--p">Then there’s this:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="ac78" id="ac78" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">ArticlesViewModel</span>: <span class="hljs-title class_">NetworkingDelegate</span> {<br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">headers</span>(<span class="hljs-params">for</span> <span class="hljs-params">networking</span>: <span class="hljs-type">Networking</span>) -&gt; [<span class="hljs-type">String</span>: <span class="hljs-type">String</span>] {<br />    <span class="hljs-keyword">return</span> [<span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/vnd.api+json; charset=utf-8&quot;</span>]<br />  }<br />}</span></pre><p name="e47a" id="e47a" class="graf graf--p graf-after--pre">It’s hard coded in a specific view model.</p><p name="5841" id="5841" class="graf graf--p graf-after--p">Quick check #3: computed property. E.g.;</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="bffe" id="bffe" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Fetch</span> {<br />  <span class="hljs-keyword">var</span> jsonHeader: [<span class="hljs-type">String</span>: <span class="hljs-type">String</span>] {<br />    [<span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/vnd.api+json; charset=utf-8&quot;</span>]<br />  }<br />}</span></pre><p name="5852" id="5852" class="graf graf--p graf-after--pre">So when you conform to it, you get it automatically. On the other hand, you can’t reuse it when it is buried in a delegate function in a view model that contains everything. That is the whole point of POP: refactor out reusable smaller parts, and compose them as needed.</p><p name="6066" id="6066" class="graf graf--p graf-after--p">So either you stick with inheritance, which gives you some reusability, or you learn POP. But no, while <em class="markup--em markup--p-em">expert Swift </em>recognizes the problems of inheritance, it decided that DI == POP, so it has a legacy view model without inheritance, without binding, all the complex initializer and over-generalization, but 0 POP! <em class="markup--em markup--p-em">Expert Swift</em>!</p><p name="5bbe" id="5bbe" class="graf graf--p graf-after--p">Alright, I’ll conclude with this screenshot from <em class="markup--em markup--p-em">Clean Swift.</em></p><figure name="b106" id="b106" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Rc-7Pv3FRJ-M6W0t9Bv-Yw.png" data-width="757" data-height="193" src="https://cdn-images-1.medium.com/max/800/1*Rc-7Pv3FRJ-M6W0t9Bv-Yw.png"></figure><p name="ea84" id="ea84" class="graf graf--p graf-after--figure">You cannot say this, then get refactored 15 to 1 by random people on Internet. Not just me, <em class="markup--em markup--p-em">expert Swift too! </em>And <em class="markup--em markup--p-em">expert Swift</em> got almost everything wrong!</p><p name="4e81" id="4e81" class="graf graf--p graf-after--p">Polymorphism is not new. It’s like CS101 as first OOP example. The underlying principle is taken out of context. You don’t use polymorphism because the same<code class="markup--code markup--p-code">fetch</code> code can be used to fetch network, database, or userdefaults data. The first question is what the spec says? Do I need to support all these? Then you determine the best approach based on refactor. You don’t generalize everything so it <em class="markup--em markup--p-em">may </em>support different implementation like a hammer seeing everything as nails.</p><p name="2f9c" id="2f9c" class="graf graf--p graf-after--p">I’m tired. So excuse me if I made more mistakes than usual. But I swear to you, everything I said about POP is true.</p><figure name="f573" id="f573" class="graf graf--figure graf-after--p graf--trailing"><img class="graf-image" data-image-id="1*yQjcoivAOCjJjAQLV543EA.jpeg" data-width="1528" data-height="1028" src="https://cdn-images-1.medium.com/max/800/1*yQjcoivAOCjJjAQLV543EA.jpeg"><figcaption class="imageCaption">(from a certain point of view)</figcaption></figure></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/3771cb30953c"><time class="dt-published" datetime="2023-02-05T19:18:38.789Z">February 5, 2023</time></a>.</p><p><a href="https://medium.com/@swift2931/the-last-of-pop-3771cb30953c" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>