<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>How to fail basic refactor using Clean Architecture</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">How to fail basic refactor using Clean Architecture</h1>
</header>
<section data-field="subtitle" class="p-summary">
The new progression paradigm for Swift
</section>
<section data-field="body" class="e-content">
<section name="37d6" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="cbd2" id="cbd2" class="graf graf--h3 graf--leading graf--title">How to fail basic refactor using Clean Architecture</h3><h4 name="b6ca" id="b6ca" class="graf graf--h4 graf-after--h3 graf--subtitle">The new progression paradigm for Swift</h4><figure name="06eb" id="06eb" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*vs6FKvBPfNM3BNEekKzpqg.png" data-width="620" data-height="1120" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*vs6FKvBPfNM3BNEekKzpqg.png"><figcaption class="imageCaption">iOS skill progression chart</figcaption></figure><h4 name="c380" id="c380" class="graf graf--h4 graf-after--figure">Does Bob know you are writing dumb shit in his name?</h4><p name="507e" id="507e" class="graf graf--p graf-after--h4">Here is a question.</p><p name="623e" id="623e" class="graf graf--p graf-after--p">How many lines of code do you think it’s reasonable to add an URL endpoint?</p><p name="dd34" id="dd34" class="graf graf--p graf-after--p">Clean Architecture under the collective wisdom of industry titans with over a decade of experiences decided that number is &gt; 40. With a setup for presentation it will be &gt; 120. That is just setup, not actual presentation.</p><p name="1783" id="1783" class="graf graf--p graf-after--p">Source: <a href="https://tech.olx.com/clean-architecture-and-mvvm-on-ios-c9d167d9f5b3" data-href="https://tech.olx.com/clean-architecture-and-mvvm-on-ios-c9d167d9f5b3" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Clean Architecture and MVVM on iOS</a></p><p name="5107" id="5107" class="graf graf--p graf-after--p">I did it &lt; 5 in my first project.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="3817" id="3817" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">// in Api.swift</span><br /><span class="hljs-keyword">var</span> endpoint <span class="hljs-operator">=</span> <span class="hljs-type">Resource</span>(<span class="hljs-string">&quot;/endpoint&quot;</span>)<br /><span class="hljs-comment">// in view controller</span><br /><span class="hljs-keyword">var</span> json: <span class="hljs-type">JSON</span> { <span class="hljs-keyword">didSet</span> {updateView()}}<br /><span class="hljs-comment">// fetch call</span><br />api.endpoint.post(params).onSuccess(json <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.json <span class="hljs-operator">=</span> json)</span></pre><p name="5aba" id="5aba" class="graf graf--p graf-after--pre">Value type model. Property observer to map it to view. One way to do presentation is to use computed properties:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="84f1" id="84f1" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">var</span> title: <span class="hljs-type">String</span> { json[<span class="hljs-string">&quot;Result&quot;</span>][<span class="hljs-string">&quot;Title&quot;</span>].stringValue }</span></pre><p name="5628" id="5628" class="graf graf--p graf-after--pre">For reuse you can refactor it out as a protocol extension</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="95e2" id="95e2" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Presenter</span> {<br />  <span class="hljs-keyword">var</span> json:　<span class="hljs-type">JSON</span> {<span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span>}<br />}<br /><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Presenter</span> {<br />  <span class="hljs-keyword">var</span> title: <span class="hljs-type">String</span> { json[<span class="hljs-string">&quot;Result&quot;</span>][<span class="hljs-string">&quot;Title&quot;</span>].stringValue }<br />}<br /><span class="hljs-comment">// self-contained with default impl, unlike Java protocol </span></span></pre><p name="a3cb" id="a3cb" class="graf graf--p graf-after--pre">All these come together to<strong class="markup--strong markup--p-strong"> SPEED UP</strong> the workflow, using Swift language features with <strong class="markup--strong markup--p-strong">RESPECT</strong> to SDK. And I only use pre-defined types. I can use the same types for every endpoint.</p><p name="f2b5" id="f2b5" class="graf graf--p graf-after--p">Clean architecture has to beat this, or at least has some advantages over it.</p><p name="d9bf" id="d9bf" class="graf graf--p graf-after--p">Does it? Bob didn’t know Swift. MVVM didn’t consider value type. The article has no mention of value type, property observer nor any comparison. It used protocol like Java. In fact it is written like Java.</p><p name="cff4" id="cff4" class="graf graf--p graf-after--p">What I’m going to do here is to debunk his “conclusion”:</p><blockquote name="894b" id="894b" class="graf graf--blockquote graf-after--p">More software engineering best practices:</blockquote><blockquote name="885c" id="885c" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong">Do not write code without tests (try TDD)</strong></blockquote><blockquote name="96eb" id="96eb" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong">Do continuous refactoring</strong></blockquote><blockquote name="61bd" id="61bd" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong">Do not over-engineer and be pragmatic</strong></blockquote><blockquote name="93d1" id="93d1" class="graf graf--blockquote graf-after--blockquote">Avoid using third-party framework dependencies in your project as much as you can</blockquote><p name="b3cc" id="b3cc" class="graf graf--p graf-after--blockquote">That is, he over-engineered, <strong class="markup--strong markup--p-strong">didn’t refactor for shit</strong>, and in fact needs to write a lot more tests to cover his boilerplate.</p><p name="4bfb" id="4bfb" class="graf graf--p graf-after--p">Some disclaimer first: I didn’t read Bob’s book. But from the work of his pupils, I don’t think it works on any practical level.</p><h4 name="9b9b" id="9b9b" class="graf graf--h4 graf-after--p">Do not over-engineer and be pragmatic</h4><p name="d6dd" id="d6dd" class="graf graf--p graf-after--h4">Let’s start with this snippet:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="7b6a" id="7b6a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">SearchMoviesUseCase</span> {<br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>(<span class="hljs-params">requestValue</span>: <span class="hljs-type">SearchMoviesUseCaseRequestValue</span>,<br />                 <span class="hljs-params">completion</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">Result</span>&lt;<span class="hljs-type">MoviesPage</span>, <span class="hljs-type">Error</span>&gt;) -&gt; <span class="hljs-type">Void</span>) -&gt; <span class="hljs-type">Cancellable</span>?<br />}<br /><br /><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultSearchMoviesUseCase</span>: <span class="hljs-title class_">SearchMoviesUseCase</span> {<br /><br />    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> moviesRepository: <span class="hljs-type">MoviesRepository</span><br />    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> moviesQueriesRepository: <span class="hljs-type">MoviesQueriesRepository</span><br />    <br />    <span class="hljs-keyword">init</span>(<span class="hljs-params">moviesRepository</span>: <span class="hljs-type">MoviesRepository</span>, <span class="hljs-params">moviesQueriesRepository</span>: <span class="hljs-type">MoviesQueriesRepository</span>) {<br />        <span class="hljs-keyword">self</span>.moviesRepository <span class="hljs-operator">=</span> moviesRepository<br />        <span class="hljs-keyword">self</span>.moviesQueriesRepository <span class="hljs-operator">=</span> moviesQueriesRepository<br />    }<br />    <br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>(<span class="hljs-params">requestValue</span>: <span class="hljs-type">SearchMoviesUseCaseRequestValue</span>,<br />                 <span class="hljs-params">completion</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">Result</span>&lt;<span class="hljs-type">MoviesPage</span>, <span class="hljs-type">Error</span>&gt;) -&gt; <span class="hljs-type">Void</span>) -&gt; <span class="hljs-type">Cancellable</span>? {<br />        <span class="hljs-keyword">return</span> moviesRepository.fetchMoviesList(query: requestValue.query, page: requestValue.page) { result <span class="hljs-keyword">in</span><br />            <br />            <span class="hljs-keyword">if</span> <span class="hljs-keyword">case</span> .success <span class="hljs-operator">=</span> result {<br />                <span class="hljs-keyword">self</span>.moviesQueriesRepository.saveRecentQuery(query: requestValue.query) { <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span> }<br />            }<br /><br />            completion(result)<br />        }<br />    }<br />}</span></pre><p name="ea6b" id="ea6b" class="graf graf--p graf-after--pre">This is a fetch request. Where’s network service?</p><p name="439b" id="439b" class="graf graf--p graf-after--p">It’s hidden under <em class="markup--em markup--p-em">Repository, </em>which is supposed to be a<em class="markup--em markup--p-em"> reference type </em><strong class="markup--strong markup--p-strong">model</strong><em class="markup--em markup--p-em">.</em></p><p name="c463" id="c463" class="graf graf--p graf-after--p">Why reference type model when you can have value type? The implication is that you have to refactor out mutable side effects in Swift. It’s more strict, that’s why it is safer. A good Swift dev makes mutable side effects explict, via protocol requirement or other means, not hidden via nested injection.</p><p name="01ad" id="01ad" class="graf graf--p graf-after--p">From this point on, you need a whole new set of thinking. We are not in Kansas(Java) anymore.</p><p name="5284" id="5284" class="graf graf--p graf-after--p">You inject <code class="markup--code markup--p-code">MoviesRepository</code> because you want to swap it out at runtime for…</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="d5cb" id="d5cb" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">MoviesRepository</span> {<br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">fetchMoviesList</span>(<span class="hljs-params">query</span>: <span class="hljs-type">MovieQuery</span>, <span class="hljs-params">page</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">completion</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">Result</span>&lt;<span class="hljs-type">MoviesPage</span>, <span class="hljs-type">Error</span>&gt;) -&gt; <span class="hljs-type">Void</span>) -&gt; <span class="hljs-type">Cancellable</span>?<br />}</span></pre><p name="af6c" id="af6c" class="graf graf--p graf-after--pre">Which means, in order to have some parameter changes for a fetch, e.g.; endpoint or callback handler, you need to write a new class from scratch.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="41df" id="41df" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultMoviesRepository</span> {<br />    <br />    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> dataTransferService: <span class="hljs-type">DataTransfer</span><br />    <br />    <span class="hljs-keyword">init</span>(<span class="hljs-params">dataTransferService</span>: <span class="hljs-type">DataTransfer</span>) {<br />        <span class="hljs-keyword">self</span>.dataTransferService <span class="hljs-operator">=</span> dataTransferService<br />    }<br />}</span></pre><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="10c8" id="10c8" class="graf graf--pre graf-after--pre graf--preV2"><span class="pre--content"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">DefaultMoviesRepository</span>: <span class="hljs-title class_">MoviesRepository</span> {<br />    <br />    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">fetchMoviesList</span>(<span class="hljs-params">query</span>: <span class="hljs-type">MovieQuery</span>, <span class="hljs-params">page</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">completion</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">Result</span>&lt;<span class="hljs-type">MoviesPage</span>, <span class="hljs-type">Error</span>&gt;) -&gt; <span class="hljs-type">Void</span>) -&gt; <span class="hljs-type">Cancellable</span>? {<br />        <br />        <span class="hljs-keyword">let</span> endpoint <span class="hljs-operator">=</span> <span class="hljs-type">APIEndpoints</span>.getMovies(with: <span class="hljs-type">MoviesRequestDTO</span>(query: query.query,<br />                                                                     page: page))<br />        <span class="hljs-keyword">return</span> dataTransferService.request(with: endpoint) { (response: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">MoviesResponseDTO</span>, <span class="hljs-type">Error</span>&gt;) <span class="hljs-keyword">in</span><br />            <span class="hljs-keyword">switch</span> response {<br />            <span class="hljs-keyword">case</span> .success(<span class="hljs-keyword">let</span> moviesResponseDTO):<br />                completion(.success(moviesResponseDTO.toDomain()))<br />            <span class="hljs-keyword">case</span> .failure(<span class="hljs-keyword">let</span> error):<br />                completion(.failure(error))<br />            }<br />        }<br />    }<br />}</span></pre><p name="1243" id="1243" class="graf graf--p graf-after--pre">Let’s pause and ponder for a moment.</p><p name="fb7f" id="fb7f" class="graf graf--p graf-after--p">If you want to change endpoint, you can pass it as a function parameter without writing a whole new class. E.g.; <code class="markup--code markup--p-code">api.fetch(“/newEndpoint”)</code></p><p name="989b" id="989b" class="graf graf--p graf-after--p">But he can’t. Because he hard-coded endpoint in <code class="markup--code markup--p-code">APIEndpoints.getMovies(DTOShit(...))</code></p><p name="a71c" id="a71c" class="graf graf--p graf-after--p">The one parameter you most likely would need, he doesn’t have it.</p><p name="b2d9" id="b2d9" class="graf graf--p graf-after--p">Instead he went through all the trouble of injecting some DTO shit, which basically turns a response to a <code class="markup--code markup--p-code">Codable</code> . Then again, you are expecting to swap it out at runtime for… ? Another <code class="markup--code markup--p-code">Codable</code> type from the same response? So once again, you have to create a new class from scratch for another type because it’s hard-coded?</p><p name="7a2d" id="7a2d" class="graf graf--p graf-after--p">And note that, he hard-coded all these specific to one endpoint, he has to start from scratch AGAIN for another endpoint. It’s a deep-nested process with insane overheads! E.g.;</p><p name="2c1c" id="2c1c" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">ViewModel(UseCase(Repository(DataTransferService(APIEndpoints(...), ...))))</code></p><p name="60f7" id="60f7" class="graf graf--p graf-after--p">Each of which requires a protocol, a default implementation, and any variation requires a news class from scratch.</p><p name="506d" id="506d" class="graf graf--p graf-after--p">You see problem(s) here?</p><p name="5ae2" id="5ae2" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Clean Architecture under the collective wisdom of industry titans with over a decade of experiences, doesn’t know how to use variable or pass parameter. And it doesn’t give a shit about anything other than injection.</strong></p><p name="9814" id="9814" class="graf graf--p graf-after--p">When in practice, injeciton is NOT a priority. As the case here, the flexibility to pass parameters is far more useful. What’s the point of injection when all it does is pass parameters? And in a shit-y way! What if you don’t use DTO injection shit and use plain old function?</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="73db" id="73db" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">getMovieData</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">json</span>: <span class="hljs-type">JSON</span>) -&gt; <span class="hljs-type">MovieData</span><br /><span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">getMovieArray</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">json</span>: <span class="hljs-type">JSON</span>) -&gt; <span class="hljs-type">MovieArray</span></span></pre><p name="94df" id="94df" class="graf graf--p graf-after--pre">Obviously you can then improve this by using generics, I leave it as an exercise.</p><p name="29ce" id="29ce" class="graf graf--p graf-after--p">This highlights another key point: <strong class="markup--strong markup--p-strong">function over object</strong>. This is a consequence of having value type, and we are breaking away from OOP. Not everything needs to be an object, which is abused in MVVM. These functions can be easily extended in protocol, hence POP.</p><p name="9e06" id="9e06" class="graf graf--p graf-after--p">The icing on the cake is this</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="e7aa" id="e7aa" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultMoviesRepository</span> {<span class="hljs-operator">...</span>}</span></pre><p name="8b3b" id="8b3b" class="graf graf--p graf-after--pre">It’s <code class="markup--code markup--p-code">final</code> . Nobody can reuse your “<strong class="markup--strong markup--p-strong">default</strong>”. So when they start from scratch, they literally start from scratch, because protocol has no default implementation, and defaut implementation is <code class="markup--code markup--p-code">fianl</code> . They have to copy paste your shit, otherwise they are just re-doing most of your work.</p><p name="36ee" id="36ee" class="graf graf--p graf-after--p">It’s time to remind ourselves what Clean Architecture is all about.</p><blockquote name="648c" id="648c" class="graf graf--blockquote graf-after--p">Do not over-engineer and be pragmatic</blockquote><p name="89c2" id="89c2" class="graf graf--p graf-after--blockquote">Did he succeed? No.</p><p name="d41c" id="d41c" class="graf graf--p graf-after--p">There’s nothing pragmatic about this. It’s easy when you can ignore all the nested injection, type declaration overheads, and object interactions.</p><p name="06ec" id="06ec" class="graf graf--p graf-after--p">None of these injections have meaningful purpose. They just do the same thing with slight variation, which can be done in far simpler ways.</p><p name="3a31" id="3a31" class="graf graf--p graf-after--p">None of the dependency shit has practical use here. In use case like this, you don’t need a design for N network services, M DTOs, K repositories, that can be swapped during runtime.</p><p name="2319" id="2319" class="graf graf--p graf-after--p">You need ONE that WORKS EFFICIENTLY. Get one right before generalizing it. He can’t even get ONE right!</p><p name="255c" id="255c" class="graf graf--p graf-after--p">Do you notice he didn’t bother discussing why his use case needs it? As it turns out it doesn’t! This is the danger of following abstract principles from a book published a decade ago.</p><p name="d92a" id="d92a" class="graf graf--p graf-after--p">Now if you want to build a system that supports swapping N objects during runtime, they better be refactored to perfection. Otherwise you are going to copy paste N times.</p><p name="8920" id="8920" class="graf graf--p graf-after--p">Is it? Refacored to perfection?</p><h4 name="9f46" id="9f46" class="graf graf--h4 graf-after--p">Do continuous refactoring</h4><p name="3ddc" id="3ddc" class="graf graf--p graf-after--h4">Take this for example:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="2196" id="2196" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">return</span> dataTransferService.request(with: endpoint) { (response: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">MoviesResponseDTO</span>, <span class="hljs-type">Error</span>&gt;) <span class="hljs-keyword">in</span><br />            <span class="hljs-keyword">switch</span> response {<br />            <span class="hljs-keyword">case</span> .success(<span class="hljs-keyword">let</span> moviesResponseDTO):<br />                completion(.success(moviesResponseDTO.toDomain()))<br />            <span class="hljs-keyword">case</span> .failure(<span class="hljs-keyword">let</span> error):<br />                completion(.failure(error))<br />            }<br />        }</span></pre><p name="cb3d" id="cb3d" class="graf graf--p graf-after--pre">How many times do you need to repeat the same <code class="markup--code markup--p-code">swtich case</code> ? You design to have N DTOs, remember?</p><p name="c727" id="c727" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">.failure</code> case will be the same in almost all cases. This brings us to yet another problem: where’s basic refactor?</p><p name="4e66" id="4e66" class="graf graf--p graf-after--p">Isn’t <em class="markup--em markup--p-em">Clean Architecture </em>supposed to be held up to highest standards?</p><p name="c634" id="c634" class="graf graf--p graf-after--p">Nah, Clean Architecture and MVVM is somehow above the law. They are not bound by overheads or refactor. They have Bob and his <em class="markup--em markup--p-em">magnum opus</em>.</p><p name="5028" id="5028" class="graf graf--p graf-after--p">Let’s take a look at protocol design.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="f37c" id="f37c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">MoviesRepository</span> {<br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">fetchMoviesList</span>(<span class="hljs-params">query</span>: <span class="hljs-type">MovieQuery</span>, <span class="hljs-params">page</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">completion</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">Result</span>&lt;<span class="hljs-type">MoviesPage</span>, <span class="hljs-type">Error</span>&gt;) -&gt; <span class="hljs-type">Void</span>) -&gt; <span class="hljs-type">Cancellable</span>?<br />}<br /><br /><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">MoviesQueriesRepository</span> {<br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">fetchRecentsQueries</span>(<span class="hljs-params">maxCount</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">completion</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">Result</span>&lt;[<span class="hljs-type">MovieQuery</span>], <span class="hljs-type">Error</span>&gt;) -&gt; <span class="hljs-type">Void</span>)<br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">saveRecentQuery</span>(<span class="hljs-params">query</span>: <span class="hljs-type">MovieQuery</span>, <span class="hljs-params">completion</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">Result</span>&lt;<span class="hljs-type">MovieQuery</span>, <span class="hljs-type">Error</span>&gt;) -&gt; <span class="hljs-type">Void</span>)<br />}</span></pre><p name="4c4f" id="4c4f" class="graf graf--p graf-after--pre">There’s this insistency to hide networking for no reason in MVVM. Because they can’t have control. It’s MVC and it’s bad for selling tutorial.</p><p name="b1ab" id="b1ab" class="graf graf--p graf-after--p">All of these can be refactored into networking. E.g.;</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="22c8" id="22c8" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">func</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">endpoint</span>: <span class="hljs-type">String</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">params</span>: <span class="hljs-type">JSON</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">callback</span>: (<span class="hljs-type">JSON</span>) -&gt; ())</span></pre><p name="4d95" id="4d95" class="graf graf--p graf-after--pre">There’s no point to conform to these protocols. What are you going to do?</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="1b8b" id="1b8b" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">func</span> <span class="hljs-title function_">fetchMoviesList</span>(<span class="hljs-params">query</span>: <span class="hljs-type">MovieQuery</span>, <span class="hljs-params">page</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">completion</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">Result</span>&lt;<span class="hljs-type">MoviesPage</span>, <span class="hljs-type">Error</span>&gt;) -&gt; <span class="hljs-type">Void</span>) -&gt; <span class="hljs-type">Cancellable</span>?</span></pre><p name="53d4" id="53d4" class="graf graf--p graf-after--pre">Fetch the same move list again?</p><p name="1e51" id="1e51" class="graf graf--p graf-after--p">What you need is library functions with enough flexibility for various networking task. You can refactor it out to protocol, provided you have extension, so it becomes library functions, not requirement. Who is going to implement this shit again? Any sane person would copy paste. E.g.;</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="404c" id="404c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">MovieFetch</span>: <span class="hljs-title class_">class</span> {<br />  <span class="hljs-keyword">var</span> api: <span class="hljs-type">NetworkService</span> {<span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span>}<br />  <span class="hljs-keyword">var</span> json: <span class="hljs-type">JSON</span> {<span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span>}<br />}<br />extenstion <span class="hljs-type">MovieFetch</span> {<br />  <span class="hljs-keyword">func</span> <span class="hljs-title function_">fetchMoviesList</span>(<span class="hljs-params">query</span>: <span class="hljs-type">MovieQuery</span>, <span class="hljs-params">page</span>: <span class="hljs-type">Int</span>) {api.fetch(<span class="hljs-operator">...</span>)} <span class="hljs-comment">// update JSON</span><br />}</span></pre><p name="5401" id="5401" class="graf graf--p graf-after--pre">I’d avoid putting <code class="markup--code markup--p-code">@escaping (Result&lt;MoviesPage, Error&gt;) -&gt; Void)</code> in signature, because it’s just a wrapper to pass it to network service, which is redundant and you need to repeat it for another fetch like <code class="markup--code markup--p-code">fetchRecentsQueries</code> . This usually works because again, you don’t need that much runtime capability to pass a closure. What you are going to do with a fetch can be determined in compile time. You need a function, and have default implementation, which we do. Know the problem you are working on so you can optimize it.</p><p name="47fe" id="47fe" class="graf graf--p graf-after--p">Since your requirement consists of a network service, and json as response data, you can see that it natually builds around it. This is why Swift is POP.</p><p name="533f" id="533f" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">api</code> and <code class="markup--code markup--p-code">json</code> are front and center. <code class="markup--code markup--p-code">class</code> means mutable. Extension because you have to refactor out mutable functions out from model so model, i.e.; <code class="markup--code markup--p-code">json</code> is value type. Make it self-contained so they are reusble as mix-in. Start with concrete types not abstract principles, and only add more if needed.</p><p name="dc07" id="dc07" class="graf graf--p graf-after--p">You know,<strong class="markup--strong markup--p-strong"> basic refactor</strong>.</p><p name="c480" id="c480" class="graf graf--p graf-after--p">If you are wondering why Clean Architecture is at the bottom of progression, it can’t even do such a basic flow. Is it possible to learn this power? Not from MVVM, and least of all Clean Architecture.</p><p name="bb1c" id="bb1c" class="graf graf--p graf-after--p">Speaking of MVVM, we haven’t even covered view model yet.</p><p name="e91b" id="e91b" class="graf graf--p graf-after--p">This is binding.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="fb28" id="fb28" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewDidLoad</span>() {<br />        <span class="hljs-keyword">super</span>.viewDidLoad()<br />        bind(to: viewModel)<br />        viewModel.viewDidLoad()<br />    }</span></pre><p name="e8b5" id="e8b5" class="graf graf--p graf-after--pre">How did he do binding?</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="3fbf" id="3fbf" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Observable</span>&lt;<span class="hljs-title class_">Value</span>&gt; {<br />    <br />    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> closure: ((<span class="hljs-type">Value</span>) -&gt; ())<span class="hljs-operator">?</span><br /><br />    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> value: <span class="hljs-type">Value</span> {<br />        <span class="hljs-keyword">didSet</span> { closure<span class="hljs-operator">?</span>(value) }   <span class="hljs-comment">// &lt;------------- HERE!</span><br />    }<br /><br />    <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">value</span>: <span class="hljs-type">Value</span>) {<br />        <span class="hljs-keyword">self</span>.value <span class="hljs-operator">=</span> value<br />    }<br /><br />    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">observe</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">closure</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">Value</span>) -&gt; <span class="hljs-type">Void</span>) {<br />        <span class="hljs-keyword">self</span>.closure <span class="hljs-operator">=</span> closure<br />        closure(value)<br />    }<br />}</span></pre><p name="0c2f" id="0c2f" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Property observer.</strong></p><p name="20f9" id="20f9" class="graf graf--p graf-after--p">What’s the difference between this and my approach at the start?</p><p name="28d9" id="28d9" class="graf graf--p graf-after--p">He had to delegate it outside to a view model object, whereas I didn’t.</p><p name="192b" id="192b" class="graf graf--p graf-after--p">Do we accomplish the same thing? Yes. He had to take a detour because he has to have a view model object. Obvisouly he is going to ignore any overhead costs, and talks about unit test…</p><p name="6227" id="6227" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Basic refactor.</strong></p><p name="bde8" id="bde8" class="graf graf--p graf-after--p">If there’s an easier to do the same thing, refactor. E.g.;</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="9083" id="9083" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"> viewModel.items.observe(on: <span class="hljs-keyword">self</span>) { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span><span class="hljs-operator">?</span>.tableViewController<span class="hljs-operator">?</span>.items <span class="hljs-operator">=</span> <span class="hljs-variable">$0</span> }</span></pre><p name="e706" id="e706" class="graf graf--p graf-after--pre">This becomes</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="2c7f" id="2c7f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">var</span> items <span class="hljs-operator">=</span> [<span class="hljs-type">Item</span>]() { <span class="hljs-keyword">didSet</span> { tableViewController.items <span class="hljs-operator">=</span> items }}</span></pre><p name="e425" id="e425" class="graf graf--p graf-after--pre">Which you can see require another refactor! Because a wrapper that only pass data is usually a code smell. I leave it as an exercise.</p><p name="366d" id="366d" class="graf graf--p graf-after--p">What’s the wisdom again? “<strong class="markup--strong markup--p-strong">Continuous refactor</strong>”? Which is odd, coming from a guy who didn’t bother at all.</p><p name="508f" id="508f" class="graf graf--p graf-after--p">If you argue that I’d be having massive view controller, then I’d argue I can refactor out things if needed with extension. What ground breaking techniques does MVVM offer in a SDK that does NOT support binding anyway? You create objects and put things there too! It’s not like the rest of us don’t know how to CREATE OBJECTS. Let’s see how MVVM avoids massive view cotroller.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="ae67" id="ae67" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">// Step 1: Define action closure to communicate to another ViewModel, e.g. here we notify MovieList when query is selected</span><br /><span class="hljs-keyword">typealias</span> <span class="hljs-type">MoviesQueryListViewModelDidSelectAction</span> <span class="hljs-operator">=</span> (<span class="hljs-type">MovieQuery</span>) -&gt; <span class="hljs-type">Void</span><br /><br /><span class="hljs-comment">// Step 2: Call action closure when needed</span><br /><span class="hljs-keyword">class</span> <span class="hljs-title class_">MoviesQueryListViewModel</span> {<br />    <span class="hljs-keyword">init</span>(<span class="hljs-params">didSelect</span>: <span class="hljs-type">MoviesQueryListViewModelDidSelectAction</span>? <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>) {<br />        <span class="hljs-keyword">self</span>.didSelect <span class="hljs-operator">=</span> didSelect<br />    }<br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">didSelect</span>(<span class="hljs-params">item</span>: <span class="hljs-type">MoviesQueryListItemViewModel</span>) {<br />        didSelect<span class="hljs-operator">?</span>(<span class="hljs-type">MovieQuery</span>(query: item.query))<br />    }<br />}</span></pre><p name="4d92" id="4d92" class="graf graf--p graf-after--pre">He passes closures to view model as event handler.</p><p name="b515" id="b515" class="graf graf--p graf-after--p">Pleasse tell me how many times he repeats <code class="markup--code markup--p-code">didSelect</code> , and <code class="markup--code markup--p-code">ViewModel</code> .</p><p name="bd99" id="bd99" class="graf graf--p graf-after--p">Not to mention you have to pass closure, which is harder to track than functions, because it can be assigned from anywhere.</p><p name="c2c6" id="c2c6" class="graf graf--p graf-after--p">Just from this code snippet, you have no idea what <code class="markup--code markup--p-code">MoviesQueryListViewModelDidSelectAction</code> really is. Hell I give up reading the word half way. If I search where it is assigned, don’t tell me I’ll find it in view controller.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="1c7c" id="1c7c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">func</span> <span class="hljs-title function_">makeMoviesQueriesSuggestionsListViewController</span>(<span class="hljs-params">didSelect</span>: <span class="hljs-keyword">@escaping</span> <span class="hljs-type">MoviesQueryListViewModelDidSelectAction</span>) -&gt; <span class="hljs-type">UIViewController</span> {<br />   <span class="hljs-keyword">if</span> <span class="hljs-keyword">#available</span>(<span class="hljs-keyword">iOS</span> <span class="hljs-number">13.0</span>, <span class="hljs-operator">*</span>) { <span class="hljs-comment">// SwiftUI</span><br />       <span class="hljs-keyword">let</span> view <span class="hljs-operator">=</span> <span class="hljs-type">MoviesQueryListView</span>(viewModelWrapper: makeMoviesQueryListViewModelWrapper(didSelect: didSelect))<br />       <span class="hljs-keyword">return</span> <span class="hljs-type">UIHostingController</span>(rootView: view)<br />   } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// UIKit</span><br />       <span class="hljs-keyword">return</span> <span class="hljs-type">MoviesQueriesTableViewController</span>.create(with: makeMoviesQueryListViewModel(didSelect: didSelect))<br />   }<br />}</span></pre><p name="1b73" id="1b73" class="graf graf--p graf-after--pre">Thank god it’s not. It is in the Dependency Injection Container (DIC) that makes view controller.</p><p name="a4ed" id="a4ed" class="graf graf--p graf-after--p">Wait, what?</p><p name="ae2a" id="ae2a" class="graf graf--p graf-after--p">A singleton that can be accessed by anyone providing a function to make a view controller that takes a view model as a parameter which has a wrapper that takes a closure that can be anything.</p><p name="0550" id="0550" class="graf graf--p graf-after--p">That is easy to read, easy to track, easy to test, and easy to maintain.</p><p name="05e3" id="05e3" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">MoviesQueryListViewModelDidSelectAction</code> ? It’s passed in from singleton. Duh?</p><p name="63c0" id="63c0" class="graf graf--p graf-after--p">We still don’t know what it does btw. It takes hard work and real talent to try and build a more useless architecture.</p><p name="2505" id="2505" class="graf graf--p graf-after--p">Genious work. Really. Be proud of yourself, Bob.</p><p name="e35e" id="e35e" class="graf graf--p graf-after--p">It’s funny because encapsulation is one of the pillars of OOP, and these guys don’t seem to give a shit. Imagine view controller not knowing what <code class="markup--code markup--p-code">didSelect</code> does. It has to be told by an external entity whose identity remains a mystery.</p><p name="4d34" id="4d34" class="graf graf--p graf-after--p">Unlike Clean Architecture, which operates solely on theory and abstract principles. i.e.;</p><figure name="8341" id="8341" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ZKQNxVP3MvVSrX59I8XicA.jpeg" data-width="259" data-height="194" src="https://cdn-images-1.medium.com/max/800/1*ZKQNxVP3MvVSrX59I8XicA.jpeg"><figcaption class="imageCaption">Dependency management</figcaption></figure><p name="5841" id="5841" class="graf graf--p graf-after--figure">We work on codes. Do I explain SOLID principle and dependency management first and build solely on them regardless of the problem?</p><p name="2597" id="2597" class="graf graf--p graf-after--p">No. We add what we need. And refactor along the way. And most importantly, we don’t write 0 refactor shit and publish it as “clean”, and lecture people about it.</p><p name="4b3e" id="4b3e" class="graf graf--p graf-after--p">Alright, I’ve got to do hair cut in an hour, so I’m gonna skip this overhead mess:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="15dc" id="15dc" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> viewModel: <span class="hljs-type">MoviesListItemViewModel</span>! { <span class="hljs-keyword">didSet</span> { unbind(from: oldValue) } }<br />  <br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">fill</span>(<span class="hljs-params">with</span> <span class="hljs-params">viewModel</span>: <span class="hljs-type">MoviesListItemViewModel</span>) { <br />        <span class="hljs-keyword">self</span>.viewModel <span class="hljs-operator">=</span> viewModel<br />        bind(to: viewModel)<br />    }<br />    <br />    <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">bind</span>(<span class="hljs-params">to</span> <span class="hljs-params">viewModel</span>: <span class="hljs-type">MoviesListItemViewModel</span>) {<br />        viewModel.posterImage.observe(on: <span class="hljs-keyword">self</span>) { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span><span class="hljs-operator">?</span>.imageView.image <span class="hljs-operator">=</span> <span class="hljs-variable">$0</span>.flatMap(<span class="hljs-type">UIImage</span>.<span class="hljs-keyword">init</span>) }<br />    }<br />    <br />    <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">unbind</span>(<span class="hljs-params">from</span> <span class="hljs-params">item</span>: <span class="hljs-type">MoviesListItemViewModel</span>?) {<br />        item<span class="hljs-operator">?</span>.posterImage.remove(observer: <span class="hljs-keyword">self</span>)<br />    }</span></pre><p name="9b7b" id="9b7b" class="graf graf--p graf-after--pre">Binding is not free is UIKit. Force unwrap is code smell. My standard is that it is only allowed for @IBObservable, which you don’t have choice. But it’s <em class="markup--em markup--p-em">Clean Architecture</em> so it can have lowest standards.</p><p name="964b" id="964b" class="graf graf--p graf-after--p">I&#39;m going to skip all the setup codes here and there, which are hard to test and prone to human errors. Oh yes, test.</p><h4 name="4505" id="4505" class="graf graf--h4 graf-after--p">Do not write code without tests (try TDD)</h4><p name="d5d7" id="d5d7" class="graf graf--p graf-after--h4">MVVM devs are automatic TDD titans. But let’s try fact-checking them.</p><p name="6d28" id="6d28" class="graf graf--p graf-after--p">What is the proof or comparison that this is easier to test?</p><p name="f116" id="f116" class="graf graf--p graf-after--p">What are the objective facts here?</p><p name="3b4b" id="3b4b" class="graf graf--p graf-after--p">He used way more protocols and classes, he had a lot of imperative assignments, he used a lot of closures. He used singleton. Every instance came with non-trival initializer that are <strong class="markup--strong markup--p-strong">NESTED</strong>. For view model you have to setup binding which involves view, hence hard to unit test.</p><p name="2495" id="2495" class="graf graf--p graf-after--p">For a same fetch function, he had to test N times with different classes and initializers. As a comparison, I use the same function for every fetch, so I test the function in library test, test parameters and responses in development. Even without writing any unit test, I know it would work reasonably well without edge cases. I will try edge cases if I have the time. The priority is lower.</p><p name="0855" id="0855" class="graf graf--p graf-after--p">Unlike TDD titans, we average devs don’t have the kind of skill to write bullet-proof tests easily. A lot of time could go into waste and still can’t find the bug.</p><p name="a55d" id="a55d" class="graf graf--p graf-after--p">Can you really say Clean Architecture, from what we’ve seen so far, provide any advantages in testing? (we know how to create object too)</p><p name="9ef3" id="9ef3" class="graf graf--p graf-after--p">His conclusion is:</p><blockquote name="d452" id="d452" class="graf graf--blockquote graf-after--p">MVVM and Clean Architecture can be used separately of course, but MVVM provides separation of concerns only inside the Presentation Layer, whereas Clean Architecture splits your code into modular layers that can be <strong class="markup--strong markup--blockquote-strong">easily tested, reused</strong>, and <strong class="markup--strong markup--blockquote-strong">understood</strong>.</blockquote><p name="469d" id="469d" class="graf graf--p graf-after--blockquote">Let me remind Clean Architecture again that it needs to beat this:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="0907" id="0907" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">// in Api.swift</span><br /><span class="hljs-keyword">var</span> endpoint <span class="hljs-operator">=</span> <span class="hljs-type">Resource</span>(<span class="hljs-string">&quot;/endpoint&quot;</span>)<br /><span class="hljs-comment">// in view controller</span><br /><span class="hljs-keyword">var</span> json: <span class="hljs-type">JSON</span> { <span class="hljs-keyword">didSet</span> {updateView()}}<br /><span class="hljs-comment">// fetch call</span><br />api.endpoint.post(params).onSuccess(json <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.json <span class="hljs-operator">=</span> json)</span></pre><p name="5b11" id="5b11" class="graf graf--p graf-after--pre"><em class="markup--em markup--p-em">Easily tested, reused, and understood</em>.</p><p name="6594" id="6594" class="graf graf--p graf-after--p">Let me say that again, with the code review we just had in mind.</p><p name="4f27" id="4f27" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">Easily tested, reused, and understood</em>.</p><p name="af2f" id="af2f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Than this? </strong>I’ll leave the judgement to you.</p><p name="fb52" id="fb52" class="graf graf--p graf-after--p">Let’s wrap up.</p><h4 name="1c89" id="1c89" class="graf graf--h4 graf-after--p">Learn some basic refactor, please</h4><p name="cc59" id="cc59" class="graf graf--p graf-after--h4">That article is the top google result for Swift Clean Architecture with 3.6K claps; His repo has almost 3K stars.</p><p name="b8aa" id="b8aa" class="graf graf--p graf-after--p">My opinion? Dude, learn some basic refacor, or basic Swift features.</p><p name="78ad" id="78ad" class="graf graf--p graf-after--p">I particularly like this gem from the comment section:</p><blockquote name="fab0" id="fab0" class="graf graf--blockquote graf-after--p">In the session “What data crosses the boundaries”, the Entity should not crosses the boundary and only be dependent by Use Case. Therefore, the Interface Adapter should not dependent on the Entity: the ViewModel should not know the classes (Movie / MovieQuery) in the Entity.</blockquote><blockquote name="5b51" id="5b51" class="graf graf--blockquote graf-after--blockquote">But if I transform the data from the Entity to DTO, it would break the DRY principle easily.</blockquote><blockquote name="16c7" id="16c7" class="graf graf--blockquote graf-after--blockquote">However, I like you solution that you group the Entity and Use Case layers into one bigger Domain layer.</blockquote><p name="3b25" id="3b25" class="graf graf--p graf-after--blockquote">Dude, you get all that from a <em class="markup--em markup--p-em">fetch?</em></p><p name="1feb" id="1feb" class="graf graf--p graf-after--p">Here’s an idea, maybe instead worrying about “boundary”, “use case”, “interface adapter”, DTO, DRY principle, domain layer… etc, you can uh… what’s the word…</p><p name="8221" id="8221" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">REFACTOR YOUR SHIT!</strong></p><p name="dcc4" id="dcc4" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">BUILD A HALF-DECENT NETWORK SERVICE FIRST!</strong></p><p name="35df" id="35df" class="graf graf--p graf-after--p">I’m going to quote from House. M.D.</p><blockquote name="b700" id="b700" class="graf graf--blockquote graf-after--p"><strong class="markup--strong markup--blockquote-strong">Dr. Gregory House : </strong>You wake up in the morning, your paint’s peeling, your curtains are gone and the water is boiling. Which problem do you deal with first?</blockquote><blockquote name="366e" id="366e" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong">Dr. Eric Foreman : </strong>House!</blockquote><blockquote name="1d32" id="1d32" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong">Dr. Gregory House : None of them! The building’s on fire!</strong></blockquote><p name="7b70" id="7b70" class="graf graf--p graf-after--blockquote">You wake up in the morning, your “entity” crosses the “boundary”, your “adapter” depends on “entity”, your view model knows “the class”, which problem do you deal with first?</p><p name="9698" id="9698" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">None of them!</strong></p><p name="6dce" id="6dce" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Your networking is dog shit!</strong></p><p name="0348" id="0348" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">You don’t have basic refactor!</strong></p><p name="87c7" id="87c7" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Your code is boilerplate mess!</strong></p><p name="2077" id="2077" class="graf graf--p graf-after--p">I hope by now you can appreciate why Clean Architecture ranks the shit-est iOS skill in the progression chart.</p><p name="de27" id="de27" class="graf graf--p graf-after--p graf--trailing">There’s a lot more interesting things that I can say about this chart, perhaps after I’m done playing Diablo 4.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/c1b3d1ce3e43"><time class="dt-published" datetime="2023-06-12T09:16:30.639Z">June 12, 2023</time></a>.</p><p><a href="https://medium.com/@swift2931/how-to-fail-basic-refactor-using-clean-architecture-c1b3d1ce3e43" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>