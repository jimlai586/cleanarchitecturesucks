<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Aim for the bushes</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Aim for the bushes</h1>
</header>
<section data-field="subtitle" class="p-summary">
Epic fails of dependency injection
</section>
<section data-field="body" class="e-content">
<section name="c52f" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="dbc3" id="dbc3" class="graf graf--h3 graf--leading graf--title">Aim for the bushes</h3><h4 name="36bf" id="36bf" class="graf graf--h4 graf-after--h3 graf--subtitle">Epic fails of dependency injection</h4><figure name="49a6" id="49a6" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*fN5NShq5OCThj1Sns2_aKQ.jpeg" data-width="500" data-height="539" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*fN5NShq5OCThj1Sns2_aKQ.jpeg"></figure><h4 name="700b" id="700b" class="graf graf--h4 graf-after--figure">Maybe it was just pride</h4><p name="7d12" id="7d12" class="graf graf--p graf-after--h4">Saw this Meta guy pumping dependency injection to the point that he thinks every subview needs to be injected… as a module.</p><p name="9b74" id="9b74" class="graf graf--p graf-after--p"><a href="https://betterprogramming.pub/dependencies-injection-in-a-modularized-swiftui-app-with-mvvm-e72ae6d898ef" data-href="https://betterprogramming.pub/dependencies-injection-in-a-modularized-swiftui-app-with-mvvm-e72ae6d898ef" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Dependencies Injection in a Modularized SwiftUI App With MVVM</a></p><p name="094e" id="094e" class="graf graf--p graf-after--p">At the height of its power, MVVM + DI pumpers think it can do no wrong. It is the best practice and should be applied to everything.</p><p name="c7c7" id="c7c7" class="graf graf--p graf-after--p">The fact is that, this “power” comes at a cost that they simply ignore.</p><p name="a3b8" id="a3b8" class="graf graf--p graf-after--p">For example, this is his code:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="1561" id="1561" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PokemonDetails</span>: <span class="hljs-title class_">View</span> {<br />    <span class="hljs-meta">@StateObject</span> <span class="hljs-keyword">var</span> viewModel: <span class="hljs-type">ViewModel</span><br />    <br />    <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(<br />        <span class="hljs-params">pokemonId</span>: <span class="hljs-type">Int</span>,<br />        <span class="hljs-params">pokemonName</span>: <span class="hljs-type">String</span>,<br />        <span class="hljs-params">pokemonService</span>: <span class="hljs-type">PokemonDetailsService</span><br />    ) {<br />        <span class="hljs-keyword">self</span>._viewModel <span class="hljs-operator">=</span> <span class="hljs-type">StateObject</span>(<br />            wrappedValue: <span class="hljs-type">ViewModel</span>(<br />                pokemonId: pokemonId,<br />                pokemonName: pokemonName,<br />                pokemonService: pokemonService<br />            )<br />        )<br />    }<br />    <span class="hljs-comment">// ...</span><br />}</span></pre><p name="dfbc" id="dfbc" class="graf graf--p graf-after--pre">Then of course in view model:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="e861" id="e861" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewModel</span>: <span class="hljs-title class_">ObservableObject</span> {<br />        <span class="hljs-meta">@Published</span> <span class="hljs-keyword">var</span> pokemon: <span class="hljs-type">PokemonDetail</span>? <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br />    <br />        <span class="hljs-keyword">let</span> pokemonId: <span class="hljs-type">Int</span><br />        <span class="hljs-keyword">let</span> pokemonName: <span class="hljs-type">String</span><br />        <span class="hljs-keyword">let</span> pokemonService: <span class="hljs-type">PokemonDetailsService</span><br />    <br />        <span class="hljs-keyword">init</span>(<br />            <span class="hljs-params">pokemonId</span>: <span class="hljs-type">Int</span>,<br />            <span class="hljs-params">pokemonName</span>: <span class="hljs-type">String</span>,<br />            <span class="hljs-params">pokemonService</span>: <span class="hljs-type">PokemonDetailsService</span><br />        ) {<br />            <span class="hljs-keyword">self</span>.pokemonId <span class="hljs-operator">=</span> pokemonId<br />            <span class="hljs-keyword">self</span>.pokemonName <span class="hljs-operator">=</span> pokemonName<br />            <span class="hljs-keyword">self</span>.pokemonService <span class="hljs-operator">=</span> pokemonService<br />        }<br />        <span class="hljs-comment">// ...</span><br />    }</span></pre><p name="be39" id="be39" class="graf graf--p graf-after--pre">Do you notice the code duplication here?</p><p name="c74d" id="c74d" class="graf graf--p graf-after--p">You should start refactoring right here. But MVVM devs are above the basic refactor. You think a Meta iOS dev / <em class="markup--em markup--p-em">Better Programming</em> author doesn’t know how to refactor? You are just not on thier level to see the bigger picture.</p><p name="67af" id="67af" class="graf graf--p graf-after--p">If we were to accept this, what might happen next?</p><p name="18af" id="18af" class="graf graf--p graf-after--p">You can’t pass this shit across view hierarchy, which happens in navigation.</p><p name="e1d7" id="e1d7" class="graf graf--p graf-after--p">Which means you need a shared storage, preferably supported by SDK…</p><p name="7101" id="7101" class="graf graf--p graf-after--p">He used @EnvironmentObject, right? Nah, you peasants. That’s beneath our Lord.</p><p name="2185" id="2185" class="graf graf--p graf-after--p">He used a top level <code class="markup--code markup--p-code">enum</code> object that can’t have stored properties to HARD-CODE every pass of parameters via nested classes with functions that take closures. And on top of that, subviews are placed in module to make sure you can’t do anything without this central God object…</p><p name="c5d2" id="c5d2" class="graf graf--p graf-after--p">Maybe it was just pride. You can’t expect a Meta dev to write code like a beginner out of the bootcamp using @EnvironmentObject.</p><p name="283b" id="283b" class="graf graf--p graf-after--p">What I’m going to do here is to go into some details and argue why this is an epic fail of historic porpotion.</p><p name="d73f" id="d73f" class="graf graf--p graf-after--p">Note that his article has dependency to his other articles. I’m too lazy to link them, but will quote them as needed.</p><h4 name="b3eb" id="b3eb" class="graf graf--h4 graf-after--p">There wasn’t even an awning in their direction</h4><p name="0a14" id="0a14" class="graf graf--p graf-after--h4">For some reason, he thinks all subviews need to be injected.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="194e" id="194e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">JournalView</span>&lt;<span class="hljs-title class_">Goals</span>: <span class="hljs-title class_">View</span>, <span class="hljs-title class_">Moods</span>: <span class="hljs-title class_">View</span>&gt;: <span class="hljs-title class_">View</span> {<br />    <br />    <span class="hljs-keyword">var</span> moodViewProvider: () -&gt; <span class="hljs-type">Moods</span><br />    <span class="hljs-keyword">var</span> goalsViewProvider: () -&gt; <span class="hljs-type">Goals</span><br />    <br />    <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(<br />        <span class="hljs-params">moodViewProvider</span>: <span class="hljs-keyword">@escaping</span>  () -&gt; <span class="hljs-type">Moods</span>,<br />        <span class="hljs-params">goalsViewProvider</span>: <span class="hljs-keyword">@escaping</span>  () -&gt; <span class="hljs-type">Goals</span><br />    ) {<br />        <span class="hljs-keyword">self</span>.moodViewProvider <span class="hljs-operator">=</span> moodViewProvider<br />        <span class="hljs-keyword">self</span>.goalsViewProvider <span class="hljs-operator">=</span> goalsViewProvider<br />    }<br />    <span class="hljs-comment">// ...</span><br />}</span></pre><p name="ebc6" id="ebc6" class="graf graf--p graf-after--pre">Our Lord didn’t bother to explain why. You just need it, alright? It’s clean. It’s got electrolytes.</p><p name="5deb" id="5deb" class="graf graf--p graf-after--p">This snippet is the code-equivalent of jumping from the roof of a 20-story building.</p><p name="969f" id="969f" class="graf graf--p graf-after--p">It’s not worth it, man. Step away from the ledge.</p><p name="c761" id="c761" class="graf graf--p graf-after--p">There are cases where SDK will limit your options. But there’s almost always some alternative that is better than fighting SDK. This is why you need to learn SDK to know the limitations.</p><p name="1125" id="1125" class="graf graf--p graf-after--p">Think about the implications here.</p><p name="4c6e" id="4c6e" class="graf graf--p graf-after--p">First there’s no limitation to the number of subviews. What if you have 20 subviews?</p><p name="5ad4" id="5ad4" class="graf graf--p graf-after--p">Second, say you use a subview <code class="markup--code markup--p-code">MoodView</code> , what does it look like? Well it is defined in <code class="markup--code markup--p-code">MoodView</code> . So you don’t know its implementation. Same as whatever you get from generic <code class="markup--code markup--p-code">moodViewProvider</code> .</p><p name="87e8" id="87e8" class="graf graf--p graf-after--p">Then wtf do you think you’ve achived? So <code class="markup--code markup--p-code">MoodView</code> is not hard-coded in <code class="markup--code markup--p-code">JournalView</code> ? But <code class="markup--code markup--p-code">moodViewProvider</code> has nothing to do with <code class="markup--code markup--p-code">MoodView</code> ? It’s not hard-coded in any way? It’s the same shit! You can predict it’s hard-coded somewhere.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="8dce" id="8dce" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ComposableNavigationApp</span>: <span class="hljs-title class_">App</span> {<br />    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">Scene</span> {<br />        <span class="hljs-type">WindowGroup</span> {<br />            <span class="hljs-type">Tabbar</span>(tabProviders: [<br />                journalTabProvider,<br />                profileTabProvider<br />            ])<br />        }<br />    }<br />    <br />    <span class="hljs-keyword">var</span> journalTabProvider: <span class="hljs-type">TabViewProvider</span> {<br />        <span class="hljs-keyword">return</span> .<span class="hljs-keyword">init</span>(<br />            systemImageName: <span class="hljs-string">&quot;heart.circle.fill&quot;</span>,<br />            tabName: <span class="hljs-string">&quot;Journal&quot;</span><br />        ) {<br />            <span class="hljs-keyword">return</span> <span class="hljs-type">JournalView</span>(<br />                moodViewProvider: { <span class="hljs-keyword">return</span> <span class="hljs-type">MoodView</span>() }, <span class="hljs-operator">&lt;---------------</span> here<br />        <span class="hljs-comment">// ...</span><br />}</span></pre><p name="55ed" id="55ed" class="graf graf--p graf-after--pre">Even better, it’s hard-coded in a closure returned by computed property, not variable. There’s no flexiblity whatsoever. Oh did I mention it is a nested 4 level closure?</p><p name="7e59" id="7e59" class="graf graf--p graf-after--p">Third, how the F does a top level object know the details of a particular subview nested deep in the hierarchy? It is not supposed to know!</p><p name="9601" id="9601" class="graf graf--p graf-after--p">You are breaking encapsulation and delegation to clean up the mess you created. Why view hierarchy in the first place? So you don’t need to know every detail. It’s like solving a problem recursively.</p><p name="7ab2" id="7ab2" class="graf graf--p graf-after--p">Can a flat strcture work? Maybe. But not when you suddenly need to manage parameters of every subview in the app. It’s a far too simplified version that hides insane overheads and scalability issue.</p><p name="f09c" id="f09c" class="graf graf--p graf-after--p">But of course, everything with MVVM + DI will be a success.</p><blockquote name="e47a" id="e47a" class="graf graf--blockquote graf-after--p">Finally, we composed the whole application in the <code class="markup--code markup--blockquote-code">CompositionRoot</code>. This approach is very <strong class="markup--strong markup--blockquote-strong">flexible</strong>:</blockquote><blockquote name="5b5e" id="5b5e" class="graf graf--blockquote graf-after--blockquote">we can change how a module behaves, by swapping implementations.</blockquote><blockquote name="0b46" id="0b46" class="graf graf--blockquote graf-after--blockquote">we can change the navigation by providing different views.</blockquote><blockquote name="c1c3" id="c1c3" class="graf graf--blockquote graf-after--blockquote">we can inject other functionalities decorating the closures or the service implementations. For example, we can easily add some analytics tracking code before loading the views or performing network calls.</blockquote><p name="826e" id="826e" class="graf graf--p graf-after--blockquote">If you think about it, it’s full of shit.</p><blockquote name="8afe" id="8afe" class="graf graf--blockquote graf-after--p">we can change how a module behaves, by swapping implementations.</blockquote><p name="ab71" id="ab71" class="graf graf--p graf-after--blockquote">Can you? Say we swap <code class="markup--code markup--p-code">moodViewProvider</code> to provide… uh.. <code class="markup--code markup--p-code">AnotherMoodView</code> . It behaves exactly the same, i.e.; a view. Implementation might be different, but you are not supposed to depend on them anway. The protocol / function signature is fixed. So your behavior is exactly the same.</p><blockquote name="a34a" id="a34a" class="graf graf--blockquote graf-after--p">we can change the navigation by providing different views.</blockquote><p name="8ca7" id="8ca7" class="graf graf--p graf-after--blockquote">Navigation is <em class="markup--em markup--p-em">supposed </em>to navigate you to different views. That’s why you can provide destination using VARIABLE. In this case you change navigation by hard-coding another view in nested closure.</p><blockquote name="9ba2" id="9ba2" class="graf graf--blockquote graf-after--p">we can inject other functionalities decorating the closures or the service implementations.</blockquote><p name="37b2" id="37b2" class="graf graf--p graf-after--blockquote">As opposed to what? You can do it with some basic refactor. You can even do it in brute force.</p><h4 name="4397" id="4397" class="graf graf--h4 graf-after--p">My first desk pop</h4><p name="e68c" id="e68c" class="graf graf--p graf-after--h4">You know there’s beginner trap. Do you know there’s industry titan trap?</p><blockquote name="476d" id="476d" class="graf graf--blockquote graf-after--p">Allen Gamble: Hey, Terry, I did it! I did my first desk pop!</blockquote><blockquote name="2711" id="2711" class="graf graf--blockquote graf-after--blockquote">[<em class="markup--em markup--blockquote-em">Fosse and Martin roar with laughter</em>]</blockquote><blockquote name="42f3" id="42f3" class="graf graf--blockquote graf-after--blockquote">Allen Gamble: It’s a real thing, right?</blockquote><blockquote name="c5f9" id="c5f9" class="graf graf--blockquote graf-after--blockquote">Terry Hoitz: A desk pop?</blockquote><blockquote name="b587" id="b587" class="graf graf--blockquote graf-after--blockquote">Allen Gamble: Yeah.</blockquote><blockquote name="f891" id="f891" class="graf graf--blockquote graf-after--blockquote">Terry Hoitz: No, that’s not real!</blockquote><blockquote name="7d48" id="7d48" class="graf graf--blockquote graf-after--blockquote">Allen Gamble: <strong class="markup--strong markup--blockquote-strong">They were so convincing in their argument, they swung me.</strong></blockquote><p name="e9e3" id="e9e3" class="graf graf--p graf-after--blockquote">Appearance of <em class="markup--em markup--p-em">Clean</em> is one such trap. E.g.;</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="less" name="eb99" id="eb99" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-selector-tag">struct</span> <span class="hljs-selector-tag">MyView</span>: <span class="hljs-selector-tag">View</span> {<br />  <span class="hljs-variable">@StateObject</span> var <span class="hljs-attribute">vm</span>: ViewModel<br />  var <span class="hljs-attribute">body</span>: some View {<br />      <span class="hljs-comment">// ...</span><br />  }<br />}</span></pre><p name="0dfb" id="0dfb" class="graf graf--p graf-after--pre">It’s clean because properties are moved to view model.</p><p name="de2e" id="de2e" class="graf graf--p graf-after--p">It’s convincing, isn’t it?</p><p name="7193" id="7193" class="graf graf--p graf-after--p">But in fact all the properties are still there. Whatever shit you think it’s too dirty will be there when you open view model.</p><p name="4e35" id="4e35" class="graf graf--p graf-after--p">This has profound impacts on DI. Use this as example:</p><p name="1f45" id="1f45" class="graf graf--p graf-after--p"><a href="https://www.swiftbysundell.com/articles/dependency-injection-using-factories-in-swift/" data-href="https://www.swiftbysundell.com/articles/dependency-injection-using-factories-in-swift/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Dependency injection using factories in Swift</a></p><p name="3ea0" id="3ea0" class="graf graf--p graf-after--p">in which it says:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="c211" id="c211" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserManager</span> {<br />    <span class="hljs-keyword">init</span>(<span class="hljs-params">dataLoader</span>: <span class="hljs-type">DataLoader</span>, <span class="hljs-params">database</span>: <span class="hljs-type">Database</span>, <span class="hljs-params">cache</span>: <span class="hljs-type">Cache</span>,<br />         <span class="hljs-params">keychain</span>: <span class="hljs-type">Keychain</span>, <span class="hljs-params">tokenManager</span>: <span class="hljs-type">TokenManager</span>) {<br />        <span class="hljs-operator">...</span><br />    }<br />}</span></pre><p name="9f51" id="9f51" class="graf graf--p graf-after--pre">This is dog shit. But what if we do this:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="627c" id="627c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserManager</span> {<br />    <span class="hljs-keyword">init</span>(<span class="hljs-params">factory</span>: <span class="hljs-type">Factory</span>) {<br />        <span class="hljs-operator">...</span><br />    }<br />}</span></pre><p name="b43d" id="b43d" class="graf graf--p graf-after--pre">Now this is <em class="markup--em markup--p-em">Clean</em>. Whatever dog shit singleton abuse in <code class="markup--code markup--p-code">Factory</code> is no longer our problem.</p><p name="2230" id="2230" class="graf graf--p graf-after--p">It is convincing, isn’t it?</p><p name="c870" id="c870" class="graf graf--p graf-after--p">Better yet, let’s call whatever dog shit singleton abuse in <code class="markup--code markup--p-code">Factory</code> a <em class="markup--em markup--p-em">factory pattern</em>.</p><figure name="aa45" id="aa45" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*NSNWqEDkelfrFcv5Lv5AgA.jpeg" data-width="650" data-height="365" src="https://cdn-images-1.medium.com/max/800/1*NSNWqEDkelfrFcv5Lv5AgA.jpeg"><figcaption class="imageCaption">Now you are getting it</figcaption></figure><p name="dec5" id="dec5" class="graf graf--p graf-after--figure">That’s the beauty of MVVM. You can get away with anything. The problems are for those who bought your tutorial. They are not your problems.</p><p name="d548" id="d548" class="graf graf--p graf-after--p">But let’s not stop here. We are going to push this line of thinking to new heights.</p><p name="b634" id="b634" class="graf graf--p graf-after--p">Inpired by the success of</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="73a2" id="73a2" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserManager</span> {<br />    <span class="hljs-keyword">init</span>(<span class="hljs-params">dataLoader</span>: <span class="hljs-type">DataLoader</span>, <span class="hljs-params">database</span>: <span class="hljs-type">Database</span>, <span class="hljs-params">cache</span>: <span class="hljs-type">Cache</span>,<br />         <span class="hljs-params">keychain</span>: <span class="hljs-type">Keychain</span>, <span class="hljs-params">tokenManager</span>: <span class="hljs-type">TokenManager</span>) {<br />        <span class="hljs-operator">...</span><br />    }<br />}</span></pre><p name="76e5" id="76e5" class="graf graf--p graf-after--pre">Is there something else large that can be broken into smaller parts so we can inject them like above? We can leverage the same appearance of <em class="markup--em markup--p-em">clean </em>so we don’t need to prove shit.</p><p name="afb8" id="afb8" class="graf graf--p graf-after--p">Ah, subviews. Behold: <strong class="markup--strong markup--p-strong">Modularization of subviews.</strong></p><blockquote name="61ec" id="61ec" class="graf graf--blockquote graf-after--p">Modularization</blockquote><blockquote name="44e6" id="44e6" class="graf graf--blockquote graf-after--blockquote">The goal of this article is to <strong class="markup--strong markup--blockquote-strong">decouple all the modules: no one of them should know about any of the others.</strong> Only the <code class="markup--code markup--blockquote-code">ComposableNavigationApp</code> would know all the components and it will put together the whole application.</blockquote><p name="5790" id="5790" class="graf graf--p graf-after--blockquote">It’s a real thing, right? “No one of them should know about any of the others”.</p><p name="e02a" id="e02a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">No! That’s not real!!!</strong></p><p name="ac0e" id="ac0e" class="graf graf--p graf-after--p">They are parent and child view! They <strong class="markup--strong markup--p-strong">SHOULD </strong>know about each other!</p><p name="0df4" id="0df4" class="graf graf--p graf-after--p">If you want to go so far as to put subview in a separate module, you put all relevent views in it. Not that you should put view in separate module at all, but if you insist on doing that, that’s what you should do.</p><p name="396d" id="396d" class="graf graf--p graf-after--p">Because it’s far easier for them to communicate in the same module than across modules. He did not remove passing data, he did it in some God object. He could have just chosen a better collection of views to put in a module to reduce the amount of extra work, which has nothing to do the real App work.</p><p name="70fe" id="70fe" class="graf graf--p graf-after--p">In short, you don’t use module on subview level. It’s too fine-grained. At least put a partial tree in view hierarchy in it.</p><p name="be23" id="be23" class="graf graf--p graf-after--p">This is a Meta iOS dev with over 3K followers that publishes on <em class="markup--em markup--p-em">Better Programming.</em></p><p name="ced1" id="ced1" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">An epic fail in my opinion.</strong></p><p name="ddfd" id="ddfd" class="graf graf--p graf-after--p">There’s this obsession to <em class="markup--em markup--p-em">decouple </em>everything. The end result is some God object that <em class="markup--em markup--p-em">couples </em>everything. Simple example:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="a584" id="a584" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyView</span>: <span class="hljs-title class_">View</span> {<br />  <span class="hljs-meta">@StateObject</span> <span class="hljs-keyword">var</span> vm: <span class="hljs-type">ViewModel</span><br />  <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {<br />      <span class="hljs-comment">// ...</span><br />  }<br />}</span></pre><p name="3e34" id="3e34" class="graf graf--p graf-after--pre">They told you logic is <em class="markup--em markup--p-em">decoupled </em>from view. End result?</p><p name="6795" id="6795" class="graf graf--p graf-after--p">You transport everything to view model where they are coupled again. He even specifically used <code class="markup--code markup--p-code">@StateObject</code> so view model is a local object. Quote:</p><blockquote name="57ab" id="57ab" class="graf graf--blockquote graf-after--p">If the object is local to the view and its lifecycle is bound to the view’s one, it should be a <code class="markup--code markup--blockquote-code">StateObject</code>. The <code class="markup--code markup--blockquote-code">ViewModel</code> is an object of that kind: a <code class="markup--code markup--blockquote-code">ViewModel</code> make sense only with its associated <code class="markup--code markup--blockquote-code">View</code>. <strong class="markup--strong markup--blockquote-strong">We rarely reuse it</strong>, and the <code class="markup--code markup--blockquote-code">View</code> is the only entity that should have a strong reference to it.</blockquote><p name="23e2" id="23e2" class="graf graf--p graf-after--blockquote">Obviously MVVM devs never bothered reusing view model despite claiming it to be reusable, but a bigger problem is that:</p><p name="0060" id="0060" class="graf graf--p graf-after--p">Then you just move properties from one place to another, which is exactly what I said at the beginning. The appearance of <em class="markup--em markup--p-em">Clean</em>.</p><p name="26e8" id="26e8" class="graf graf--p graf-after--p">You are telling me that this is <em class="markup--em markup--p-em">decoupled</em>, <em class="markup--em markup--p-em">Clean</em>.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="f410" id="f410" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewModel</span>: <span class="hljs-title class_">ObservableObject</span> {<br />        <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> pokedexService: <span class="hljs-type">PokedexService</span> <br />        <span class="hljs-keyword">init</span>(<br />            <span class="hljs-params">pokedexService</span>: <span class="hljs-type">PokedexService</span>,<br />        ) {<br />            <span class="hljs-keyword">self</span>.pokedexService <span class="hljs-operator">=</span> pokedexService<br />        } <br />}</span></pre><p name="ae15" id="ae15" class="graf graf--p graf-after--pre">But this is <em class="markup--em markup--p-em">coupled</em>.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="less" name="1205" id="1205" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-selector-tag">struct</span> <span class="hljs-selector-tag">MyView</span>: <span class="hljs-selector-tag">View</span> {<br />  <span class="hljs-variable">@StateObject</span> var pokedexService = <span class="hljs-built_in">PokedexService</span>()<br />  <span class="hljs-comment">// ...</span><br />}</span></pre><p name="de6b" id="de6b" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">@StateObject</code> is supposed to be local. Because it’s a reference. If somebody can assign it from outside, he can mutate it if he holds the reference.</p><p name="8be6" id="8be6" class="graf graf--p graf-after--p">So what’s the first thing he did?</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="89c8" id="89c8" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PokedexList</span>: <span class="hljs-title class_">View</span> {<br />    <span class="hljs-meta">@StateObject</span> <span class="hljs-keyword">var</span> viewModel: <span class="hljs-type">ViewModel</span><br />    <br />    <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(<br />        <span class="hljs-params">pokedexService</span>: <span class="hljs-type">PokedexService</span>,<br />    ) {<br />        <span class="hljs-keyword">self</span>._viewModel <span class="hljs-operator">=</span> <span class="hljs-type">StateObject</span>(wrappedValue: <span class="hljs-type">ViewModel</span>(pokedexService: pokedexService))<br />    }<br />  <br />    <span class="hljs-comment">// ... body ...</span><br />}</span></pre><p name="3bf4" id="3bf4" class="graf graf--p graf-after--pre">Injecting from outside. He may not hold reference outside, but that doesn’t mean other devs won’t.</p><p name="cd63" id="cd63" class="graf graf--p graf-after--p">If Meta guy didn’t give a shit about this, what are the chances of average devs that will respect immutability, the reason why the “view” is designed to be a value type?</p><h4 name="469d" id="469d" class="graf graf--h4 graf-after--p">The other guys</h4><blockquote name="2d33" id="2d33" class="graf graf--blockquote graf-after--h4">[Narrator]: Maybe their egos pushed them off. I don’t know.</blockquote><blockquote name="2c57" id="2c57" class="graf graf--blockquote graf-after--blockquote">But that shit was crazy.</blockquote><p name="6fd9" id="6fd9" class="graf graf--p graf-after--blockquote">After watching MVVM and DI jumped off a 20-story building, let’s think how we can do better.</p><p name="e059" id="e059" class="graf graf--p graf-after--p">Let’s look at a snippet from Meta guy:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="9d1d" id="9d1d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewModel</span>&lt;<span class="hljs-title class_">DetailsView</span>: <span class="hljs-title class_">View</span>&gt;: <span class="hljs-title class_">ObservableObject</span> {<br />        <span class="hljs-meta">@Published</span> <span class="hljs-keyword">var</span> pokemons: [<span class="hljs-type">Pokemon</span>]<br />        <span class="hljs-keyword">let</span> detailsProvider: <span class="hljs-type">PokemonDetailsProvider</span>&lt;<span class="hljs-type">DetailsView</span>&gt;<br />        <span class="hljs-keyword">let</span> pokedexId: <span class="hljs-type">Int</span><br />        <span class="hljs-keyword">let</span> pokedexName: <span class="hljs-type">String</span><br />        <br />        <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> pokemonService: <span class="hljs-type">PokemonService</span><br />        <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> cancellables: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">AnyCancellable</span>&gt; <span class="hljs-operator">=</span> []<br />        <br />        <br />        <span class="hljs-keyword">init</span>(<br />            <span class="hljs-params">pokedexId</span>: <span class="hljs-type">Int</span>,<br />            <span class="hljs-params">pokedexName</span>: <span class="hljs-type">String</span>,<br />            <span class="hljs-params">pokemonService</span>: <span class="hljs-type">PokemonService</span>,<br />            <span class="hljs-params">detailsProvider</span>: <span class="hljs-keyword">@escaping</span> <span class="hljs-type">PokemonDetailsProvider</span>&lt;<span class="hljs-type">DetailsView</span>&gt;<br />        ) {<br />            <span class="hljs-keyword">self</span>.pokedexId <span class="hljs-operator">=</span> pokedexId<br />            <span class="hljs-keyword">self</span>.pokedexName <span class="hljs-operator">=</span> pokedexName<br />            <span class="hljs-keyword">self</span>.pokemons <span class="hljs-operator">=</span> []<br />            <span class="hljs-keyword">self</span>.pokemonService <span class="hljs-operator">=</span> pokemonService<br />            <span class="hljs-keyword">self</span>.detailsProvider <span class="hljs-operator">=</span> detailsProvider<br />        }<br />        <br />        <span class="hljs-keyword">func</span> <span class="hljs-title function_">loadPokemons</span>() {<br />            <span class="hljs-keyword">self</span>.pokemonService<br />                .getPokemons(pokedexId: <span class="hljs-keyword">self</span>.pokedexId)<br />                .sink(<br />                    receiveCompletion: { completion <span class="hljs-keyword">in</span><br />                    <span class="hljs-keyword">switch</span> completion {<br />                        <span class="hljs-keyword">case</span> .finished: <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Finished&quot;</span>)<br />                        <span class="hljs-keyword">case</span> .failure(<span class="hljs-keyword">let</span> error): <span class="hljs-built_in">print</span>(error)<br />                        }<br />                    }, receiveValue: { pokemons <span class="hljs-keyword">in</span><br />                        <span class="hljs-keyword">self</span>.pokemons <span class="hljs-operator">=</span> pokemons<br />                    }<br />                )<br />                .store(in: <span class="hljs-operator">&amp;</span>cancellables)<br />        }<br />    }</span></pre><p name="4837" id="4837" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">pokemonService</code> is tied specifically to an endpoint or model type.</p><p name="7c20" id="7c20" class="graf graf--p graf-after--p">You write the same <code class="markup--code markup--p-code">sink</code> , <code class="markup--code markup--p-code">store</code> , <code class="markup--code markup--p-code">cancellable</code> everytime, which needs refactor. You also have to assume the service is Combine-based.</p><p name="10b4" id="10b4" class="graf graf--p graf-after--p">Code duplication is still there after all these modular injection shit. How many F-ing times you need to write <code class="markup--code markup--p-code">pokemonService</code> or <code class="markup--code markup--p-code">ViewModel</code> ?</p><p name="f64e" id="f64e" class="graf graf--p graf-after--p">Completion handler every F-ing time. Who wrote this shit?</p><p name="38b5" id="38b5" class="graf graf--p graf-after--p">What does this tell you? Injection is moving stuff from one place to another. <strong class="markup--strong markup--p-strong">It’s not a substitute for refactor.</strong> And if you are never going to swap <code class="markup--code markup--p-code">pokemonService</code> , all of these are worthless shit.</p><p name="e8fa" id="e8fa" class="graf graf--p graf-after--p">Now I’m going to use a technique called dependency injection. No, not his dumb shit. A better one.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="fcd9" id="fcd9" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Model</span>: <span class="hljs-title class_">View</span> {<br />    <span class="hljs-keyword">let</span> pokedexId: <span class="hljs-type">Int</span><br />    <span class="hljs-keyword">let</span> pokedexName: <span class="hljs-type">String</span><br />    <span class="hljs-meta">@State</span> <span class="hljs-keyword">var</span> pokemons <span class="hljs-operator">=</span> [<span class="hljs-type">Pokemon</span>]()<br />    <span class="hljs-meta">@EnvironmentObject</span> <span class="hljs-keyword">var</span> env: <span class="hljs-type">SharedState</span><br />    <span class="hljs-comment">// call env.loadPokemons(pokedexId) to updates pokemons</span><br />}</span></pre><p name="1a02" id="1a02" class="graf graf--p graf-after--pre">There’s no need to swap subview. Look at his App description. It doesn’t define anything related to view swap.</p><p name="a252" id="a252" class="graf graf--p graf-after--p">How <code class="markup--code markup--p-code">loadPokemons(...)</code> is implemented does not concern me. The value type <code class="markup--code markup--p-code">[Pokemon]</code> I get in return is what I need for view state.</p><p name="254b" id="254b" class="graf graf--p graf-after--p">The use of the word “dependency” is quite misleading, really. It made you want to get rid of it. Then you made mistakes trying to get rid of it thinking you’ve got rid of it and publishing it as clean but it is actually not.</p><p name="0a90" id="0a90" class="graf graf--p graf-after--p">Instead of “dependency”, let’s say I “use” <code class="markup--code markup--p-code">loadPokemons()</code> , and I assume it can be “shared”. <code class="markup--code markup--p-code">@State </code>is local while <code class="markup--code markup--p-code">@EnvironmentObject</code> is shared. These scope decorators are far more useful than the so-called “dependency”.</p><p name="3712" id="3712" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">You don’t need dumb shit dependency management, factory, modularization… AT ALL.</strong></p><p name="682c" id="682c" class="graf graf--p graf-after--p">This is the progression chart I presented in another article:</p><figure name="109d" id="109d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*vs6FKvBPfNM3BNEekKzpqg.png" data-width="620" data-height="1120" src="https://cdn-images-1.medium.com/max/800/1*vs6FKvBPfNM3BNEekKzpqg.png"></figure><p name="3fa2" id="3fa2" class="graf graf--p graf-after--figure">This is why MVVM + DI is below beginner level (at least in Swift).</p><p name="2529" id="2529" class="graf graf--p graf-after--p">I can’t speculate his line of reasoning when designing this, but I can arrive at his design by making the most lazy, dumb shit, brute force design choices as discussed above.</p><p name="f7e0" id="f7e0" class="graf graf--p graf-after--p">And his design <strong class="markup--strong markup--p-strong">DID NOT</strong> do the job better than using basic SDK. In fact I encourage beginners to re-write this using basic SDK like I did.</p><p name="fdd4" id="fdd4" class="graf graf--p graf-after--p">Finally I want to make some counter-points to his <em class="markup--em markup--p-em">Modularization Utopia</em>.</p><blockquote name="1906" id="1906" class="graf graf--blockquote graf-after--p">Modularize an app has several benefits:</blockquote><blockquote name="940f" id="940f" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong">Reduced build times.</strong> Xcode can cache the modules and avoid recompiling those that have not changed.</blockquote><blockquote name="cabb" id="cabb" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong">Parallel development. </strong>Different team members can work on different modules in isolation. This implies a reduced number of conflicts.</blockquote><blockquote name="36d9" id="36d9" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong">Isolated development. </strong>Every module lives in isolation and therefore we can ignore the rest of the system.</blockquote><blockquote name="fc42" id="fc42" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong">Better separation of concerns. </strong>Every module embodies a single feature or a service. Its responsibility should always be clear.</blockquote><p name="c5f8" id="c5f8" class="graf graf--p graf-after--blockquote">For avoid recompiling to work, you can’t put parent and child view in two modules. Most of the time you will need to modify both.</p><p name="3df0" id="3df0" class="graf graf--p graf-after--p">Parallel development is funny. We assigned view controllers (using Storyboard!) to devs to work in parallel back in UIKit days. You don’t need modules to do that. Same goes to isolated development.</p><p name="17a6" id="17a6" class="graf graf--p graf-after--p">Better separation of concerns is what made his design an epic fail.</p><p name="727e" id="727e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">There’s great power in putting everything in one place. There’s greater power in specializing the relevant stuff you put in one place. It simplifies your code.</strong></p><p name="4495" id="4495" class="graf graf--p graf-after--p">DI has pushed abstract principle to an extreme that it detaches from reality. Look at his top object:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="ab8c" id="ab8c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">@main</span><br /><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PokedexApp</span>: <span class="hljs-title class_">App</span> {<br />    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">Scene</span> {<br />        <span class="hljs-type">WindowGroup</span> {<br />            <span class="hljs-type">CompositionRoot</span>.composeApp<br />        }<br />    }<br />}</span></pre><p name="240c" id="240c" class="graf graf--p graf-after--pre">What’s the single responsibility in this?</p><p name="0f89" id="0f89" class="graf graf--p graf-after--p">To tell you my single responsibility is to ask you to navigate to <code class="markup--code markup--p-code">CompositionRoot.composeApp</code> ?</p><p name="e16e" id="e16e" class="graf graf--p graf-after--p">This is a classic pretentious boilerplate dumb shit whose only purpose is virtue signaling.</p><p name="bd2b" id="bd2b" class="graf graf--p graf-after--p">And what’s the single responsibility in this?</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="f407" id="f407" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">CompositionRoot</span> {<br />    <br />    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> composeApp: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {<br />        <span class="hljs-keyword">return</span> <span class="hljs-type">NavigationView</span> {<br />            <span class="hljs-type">PokedexList</span>&lt;<span class="hljs-type">PokemonList</span>&gt;(<br />                pokedexService: <span class="hljs-type">MockedPokedexService</span>(),<br />                pokedexDetailsProvider: goToPokemonList<br />            )<br />        }<br />    }<br /><br />    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">goToPokemonList</span>(<span class="hljs-params">pokedexId</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">pokedexName</span>: <span class="hljs-type">String</span>) {<br />      <span class="hljs-operator">...</span><br />    }<br />    <span class="hljs-comment">//... </span><br />}</span></pre><p name="a374" id="a374" class="graf graf--p graf-after--pre">To pass every parameter in every subview in the app? Htf do you know that? Single responsibility? Really?</p><p name="d66b" id="d66b" class="graf graf--p graf-after--p">This is just one step away from dog shit singleton abuse<code class="markup--code markup--p-code">Factory</code> <em class="markup--em markup--p-em">design pattern</em>. Don’t respect SDK. Don’t follow view hierarchy. Use singleton for everything. Inject everything. And one module for one subview.</p><p name="fd95" id="fd95" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">SINGLE RESPONSIBILITY</strong>.</p><p name="8857" id="8857" class="graf graf--p graf-after--p">Do you see now why this progression chart makes sense?</p><figure name="3621" id="3621" class="graf graf--figure graf-after--p graf--trailing"><img class="graf-image" data-image-id="1*Tlp6BFnHXOCRNaTF703S2A.png" data-width="1034" data-height="535" src="https://cdn-images-1.medium.com/max/800/1*Tlp6BFnHXOCRNaTF703S2A.png"><figcaption class="imageCaption">The other guys</figcaption></figure></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@swift2931" class="p-author h-card">Jim Lai</a> on <a href="https://medium.com/p/4045825f4f34"><time class="dt-published" datetime="2023-07-16T09:45:05.838Z">July 16, 2023</time></a>.</p><p><a href="https://medium.com/@swift2931/aim-for-the-bushes-4045825f4f34" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 9, 2023.</p></footer></article></body></html>